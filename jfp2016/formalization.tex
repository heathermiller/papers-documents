%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                  & \mbox{{\it{terms:}}} \\
\gap \:\:\:\:  x                                                       & \mbox{variable} \\
\gap ~|~  (x: T) \Rightarrow t                                         & \mbox{abstraction} \\
\gap ~|~  t~t                                                          & \mbox{application} \\
\gap ~|~  \unit                                                        & \mbox{unit} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{populate}(t, t)                                      & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t)                                           & \mbox{map} \\
\gap ~|~  \texttt{flatMap}(t, t)                                       & \mbox{flatMap} \\
\gap ~|~  \texttt{send}(t)                                             & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                            & \mbox{await future} \\   % await :: Fut a -> a
\gap ~|~  \texttt{respond}(h, t, t)                                    & \mbox{respond} \\
\gap ~|~  \iota                                                        & \mbox{decentralized identifier} \\
\gap ~|~  r                                                            & \mbox{silo reference} \\
\gap ~|~  h                                                            & \mbox{host} \\
                                                                       & \\
v ::=                                                                  & \mbox{{\it{values:}}} \\
\gap \:\:\:\: (x: T) \Rightarrow t                                     & \mbox{abstraction value} \\
\gap ~|~  \unit                                                        & \mbox{unit} \\
\gap ~|~  p                                                            & \mbox{spore value} \\
\gap ~|~  \iota                                                        & \mbox{decentralized identifier} \\
\gap ~|~  r                                                            & \mbox{silo reference} \\
\gap ~|~  h                                                            & \mbox{host} \\
                                                                       & \\
p ::= \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}      & \\
& \\
l ::=                                                  & \mbox{{\it{lineages:}}}              \\
\gap \:\:\:\: \text{Mat}(\iota)                        & \mbox{materialized}                  \\
\gap ~|~  \text{Mapped}(\iota, l, p)                   & \mbox{lineage with \texttt{map}}     \\
\gap ~|~  \text{FMapped}(\iota, l, p)                  & \mbox{lineage with \texttt{flatMap}} \\
                                                       & \\
r ::= {\Ref l h} \quad \text{where}~h \in \mathcal{H}  & \mbox{silo reference} \\
                                                       & \\
\iota  ::= (h,i) \quad \text{where}~h \in \mathcal{H}~\text{and}~i \in \mathbb{N}   & \mbox{decentralized identifier} \\
\ea$
\caption{Abstract syntax of core language.}\label{fig:syntax}
\end{figure}


We formalize our programming model in the context of a typed lambda
calculus. Figure~\ref{fig:syntax} shows the abstract syntax of our
core language. Besides standard terms, the language includes terms
related to (a) spores, (b) silos, and (c) futures. The \verb|spore|
term creates a new spore. It contains a list of variable definitions,
the spore header, and a closure which may only refer to its parameter
and variables in the spore header. The \verb|populate| term
initializes a new silo on a given host with a given value. The \verb|map| and
\verb|flatMap| terms create lineages of silo transformations
represented as silo references.  The \verb|send| term forces the
materialization of the argument silo. The \verb|send| expression
returns a future which is asynchronously completed with the silo's
value. The \verb|await| term waits for the completion of its argument
future and returns the future's value. Decentralized identifiers
$\iota$ are used to refer to futures and to identify silos via their
lineages (each element in a lineage carries a decentralized
identifier).

Values in our language are as expected: besides abstractions they
include spore values, decentralized identifiers, and silo
references. Decentralized identifiers and silo references are not part
of the ``surface syntax'' of our language; they are only introduced by
evaluation (see Section~\ref{sec:opsem}). Silo reference values have
the form ${\Ref l h}$ where $l$ is a lineage and $h$ is a
host. Lineages are values of a simple datatype with constructors {\em
  Mat}, {\em Mapped}, and {\em FMapped}. The constructors include all
information required for {\em materializing} a silo with the result of
applying the described transformations. We defer a detailed
explanation of the transformations described by a lineage to the
following Section~\ref{sec:opsem}.

\begin{figure}[h!]
\centering
$\ba[t]{l@{\hspace{2mm}}l}
T ::=                                                                  & \mbox{{\it{types:}}} \\
\gap \:\:\:\: T \Rightarrow T                                          & \mbox{abstraction type} \\
\gap ~|~  \texttt{Unit}                                                & \mbox{unit type} \\
\gap ~|~  \mathcal{S}                                                  & \mbox{} \\
\gap ~|~  \texttt{Future}[T]                                           & \mbox{future type} \\
\gap ~|~  \texttt{SiloRef}[T]                                          & \mbox{silo reference type} \\
\gap ~|~  \texttt{Host}                                                & \mbox{host type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}               & \mbox{abstract spore type} \\
\ea$
\caption{Types of core language.}\label{fig:types}
\end{figure}

In addition to standard function types, the language has types for
spores, futures, silo references, and hosts (see
Figure~\ref{fig:types}). A spore type $T \Rightarrow
T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}$ includes the types
$\seq{T}$ of the variables declared in the header of the spore.

\subsection{Operational Semantics}\label{sec:opsem}

In the following we present a small-step operational semantics of the
introduced core language. The semantics is clearly stratified into a
local (sequential) layer and a distributed (concurrent)
layer. Importantly, this means our programming model can benefit from
existing reasoning techniques for sequential programs. Program
transformations that are correct for sequential programs are also
correct for distributed programs. Our programming model shares this
property with some existing approaches~\cite{ConcurrentHaskell}.

\begin{figure}
\centering
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{populate}(E, t)                                                                         & \mbox{populate (host)} \\
\gap ~|~  \texttt{populate}(v, E)                                                                         & \mbox{populate (val)} \\
\gap ~|~  \texttt{map}(E, t)                                                                              & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E)                                                                              & \mbox{map (fun)} \\
\gap ~|~  \texttt{flatMap}(E, t)                                                                          & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E)                                                                          & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{send}(E)                                                                                & \mbox{send} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\gap ~|~  \texttt{respond}(h, E, t)                                                                       & \mbox{respond (fut)} \\
\gap ~|~  \texttt{respond}(h, v, E)                                                                       & \mbox{respond (val)} \\
\ea$
\caption{Evaluation contexts.}\label{fig:eval-ctx}
\end{figure}

The semantics is based on two reduction relations for (a) local
reduction of terms and (b) distributed reduction of sets of hosts.
The reduction relations use the definition of evaluation contexts
shown in Figure~\ref{fig:eval-ctx}. Evaluation contexts capture the
notion of the ``next subterm to be evaluated.''  Following a standard
approach~\cite{TAPL}, we write $E[t]$ for the term obtained by
replacing the hole in evaluation context $E$ with term $t$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Local (sequential) reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\centering
\begin{mathpar}

\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v]~|~\sigma
  \rightarrow^h
  E[[x \mapsto v]t]~|~\sigma
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v]~|~\sigma
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v]t]~|~\sigma
}

\inferrule[\textsc{R-Await}] {
  \sigma(\iota) = v
} {
  E[\texttt{await}(\iota)]~|~\sigma
  \rightarrow^h
  E[v]~|~\sigma
}

\inferrule[\textsc{R-Map}] {
  r = {\Ref l {h'}} \quad l' = {\Mapped {(h, i)} l p} \quad i~\text{fresh}
} {
  E[\texttt{map}(r, p)]~|~\sigma
  \rightarrow^h
  E[{\Ref {l'} {h'}}]~|~\sigma
}

\inferrule[\textsc{R-FMap}] {
  r = {\Ref l {h'}} \quad l' = {\FMapped {(h, i)} l p} \quad i~\text{fresh}
} {
  E[\texttt{flatMap}(r, p)]~|~\sigma
  \rightarrow^h
  E[{\Ref {l'} {h'}}]~|~\sigma
}

\end{mathpar}
\caption{Local reduction.}\label{fig:seq-reduction}
\end{figure}

Figure~\ref{fig:seq-reduction} shows the rules for local
reduction. The local reduction relation has the form $E[t]~|~\sigma
\rightarrow^h E[t']~|~\sigma'$ with stores $\sigma$ and
$\sigma'$. Stores are required for the dynamic allocation of silos. A
store $\sigma$ is a partial function mapping decentralized identifiers
$\iota$ to values $v$.  The annotation with host $h$ is used for
creating decentralized identifiers $\iota = (h, i)$ for lineages.
Rule \textsc{R-AppAbs} is completely standard.  Analogous to rule
\textsc{R-AppAbs}, rule \textsc{R-AppSpore} describes the application
of a spore value to an argument value. Rule \textsc{R-Await} reduces
$\texttt{await}(\iota)$ to $v$ if future $\iota$ is already completed
with $v$ in $\sigma$.

Rules \textsc{R-Populate}, \textsc{R-Map}, and \textsc{R-FMap}
describe the creation of lineages.  Rules \textsc{R-Map} and
\textsc{R-FMap} create lineages using the constructors {\em Mapped}
and {\em FMapped}, respectively. The new lineage has a fresh
identifier $(h, i)$ which uniquely identifies the corresponding
(logical) silo. In each case, the spore value $p$ is stored in the new
lineage; this enables a materialization of the silo identified by $(h,
i)$ using parent lineage $l$ and spore $p$.

\comment{
Rules \textsc{R-Persist} and
\textsc{R-Unpersist} create silo reference values using the {\em
  Persist} constructor. {\em Persist} contains a function enabling
host $h$ to persist ($\cdot \cup \cdot$) or unpersist ($\cdot
\setminus \cdot$) silo $r$, respectively.}

\begin{figure}
\centering
$\ba[t]{l@{\hspace{2mm}}l}
m      ::= & \mbox{{\it{messages:}}} \\
\gap \:\:\:\: {\Req h r \iota}      & \mbox{request} \\
\gap ~|~      {\Res \iota v}        & \mbox{response} \\
 & \\
Q      ::=                          & \mbox{{\it{message queues:}}} \\
\gap \:\:\:\: \epsilon  & \mbox{empty queue} \\
\gap ~|~    m \cdot Q      & \mbox{non-empty queue} \\
\ea$
\caption{Message queues.}\label{fig:queues}
\end{figure}

\comment{
The deterministic reduction relation has the form $(E[t], \mu, Q, S)^h
\longrightarrow (E[t'], \mu', Q', S')^h$ where $Q$ is a {\em message
  queue} and $S$ is a {\em silo store}. Figure~\ref{fig:queues} shows
the definition of message queues. A message queue $Q$ may contain
three kinds of messages. A message of the form ${\Req h r \omega}$
requests the value of silo $r$ to be sent to host $h$ for
materialization of identifier $\omega$. A message of the form ${\Res
  \omega v P}$ represents the corresponding response, containing the
identifier $\omega$ to be materialized, value $v$, and persist set $P$
(the set of hosts which have persisted the silo identified by
$\omega$). A message of the form ${\ReqF \iota \omega}$ requests
future $\iota$ to be completed with the value of silo $\omega$.  A
{\em silo store} $S$ is a partial function mapping identifiers
$\omega$ to values of the form $(\Val{v}, P)$ or $(\Fwd{r}, P)$ where
$P$ is a set of hosts which have persisted the silo (the persist set).
The former represents a materialized silo with value $v$. The latter
represents a {\em proxy} forwarding to the silo specified by lineage
$r$.}

\paragraph{Distributed reduction.}
The distributed reduction rules use helper functions $host$, $id$, and
$parent$, which are defined as follows:

\begin{defn}[Host]
  The host of a silo reference.

  $host({\Ref l h}) := h$
\end{defn}

\begin{defn}[Lineage identifier]\label{def:id}
  The identifier of a lineage.

  $id(l) := \left\{\ba{ll}
    \iota  & \text{if } l = {\Mat \iota} \\
    \iota  & \text{if } l = {\Mapped \iota \_ \_} \\
    \iota  & \text{if } l = {\FMapped \iota \_ \_}
  \ea\right.$
\end{defn}

\begin{defn}[Lineage parent]\label{def:parent}
  The parent of a lineage.

  $parent(l) := \left\{\ba{ll}
    l' & \text{if } l = {\Mapped \_ {l'} \_} \\
    l' & \text{if } l = {\FMapped \_ {l'} \_} \\
  \ea\right.$
\end{defn}

The distributed reduction relation has the form $H~|~M
\twoheadrightarrow H'~|~M'$ where $H, H'$ are sets of hosts and $M,
M'$ are sets of messages. A host with identifier $h$ in $H$ has the
form $(t, \sigma, Q)^h$. $t$ is the term reduced by $h$; $\sigma$ is
the local store of $h$; finally, $Q$ is a queue of incoming messages
used for {\em asynchronous communication} with other hosts in $H$.

Figure~\ref{fig:queues} shows the definition of message queues. A
message queue $Q$ may contain two kinds of messages. A message of the
form ${\Req h r \iota}$ requests the value of silo $r$ to be sent to
host $h$ for materialization of identifier $\iota$. A message of the
form ${\Res \iota v}$ represents the corresponding response,
containing the identifier $\iota$ to be materialized using value $v$.

The sets $M, M'$ in a distributed reduction $H~|~M \twoheadrightarrow
H'~|~M'$ model {\it message sends} that are currently ``in flight;'' a
message send $h \leftarrow m$ expresses the sending of message $m$ to
host $h$. If $h \leftarrow m \in M$ then message $m$ has not yet been
delivered to the message queue of $h$ (the message is still in
transit). Separating in-flight messages from delivered messages
(residing in some local message queue) allows us to closely model real
distributed systems, in particular non-deterministic message ordering.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Distributed reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{R-Local}] {
  t~|~\sigma \rightarrow^h t'~|~\sigma'
} {
  \{ (t, \sigma)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (t', \sigma')^h \} \cup H ~|~ M
}

\inferrule[\textsc{R-Send}] {
  r  = {\Ref l {h'}}      \quad
  m  = {\Req h r {id(l)}} \quad
  M' = M \uplus \{ h' \leftarrow m \}
} {
  \{ (E[\texttt{send}(r)], \sigma)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[id(l)], \sigma)^h \} \cup H ~|~ M'
}

\inferrule[\textsc{R-Populate}] {
  \iota = (h, i) \quad i~\text{fresh} \quad
  l = {\Mat \iota} \quad M' = M \uplus \{ h' \leftarrow {\Res \iota v} \}
} {
  \{ (E[\texttt{populate}(h', v)], \sigma)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[{\Ref l {h'}}], \sigma)^h \} \cup H ~|~ M'
}

\inferrule[\textsc{R-Respond}] {
  M' = M \uplus \{ h' \leftarrow {\Res \iota v} \}
} {
  \{ (E[\texttt{respond}(h', \iota, v)], \sigma)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[\texttt{unit}], \sigma)^h \} \cup H ~|~ M'
}

\inferrule[\textsc{R-Process}] {
  \iota \notin dom(\sigma) \quad
  M = M' \uplus \{ h \leftarrow m \} \quad
  process(h, m, \sigma) = (t, M'', \sigma')
} {
  \{ (E[\texttt{await}(\iota)], \sigma)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[t~;~\texttt{await}(\iota)], \sigma')^h \} \cup H ~|~ M' \uplus M''
}

\inferrule[\textsc{R-Process-Val}] {
  M = M' \uplus \{ h \leftarrow m \} \quad
  process(h, m, \sigma) = (t, M'', \sigma')
} {
  \{ (v, \sigma)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (t, \sigma')^h \} \cup H ~|~ M' \uplus M''
}
\end{mathpar}
\caption{Distributed reduction.}\label{fig:dist-rules}
\end{figure}

Rule \textsc{R-Local} reduces a host $h$ chosen non-deterministically
from the set of hosts (the rule ``schedules'' host $h$ for
execution). Term $t$ of host $h$ is reduced according to the local
reduction rules. Thus, no communication is taking place; this means
that both the message queue $Q$ of $h$ and the set of in-flight
messages $M$ remain unchanged.

Rule \textsc{R-Send} reduces a term $\texttt{send}(r)$ on host
$h$. The reduction initiates the materialization of silo $r$ by
sending a message $m = {\Req h r {id(l)}}$ to the host of $r$,
$h'$. Thus, the message send $h' \leftarrow m$ is added to the
resulting set of in-flight messages $M'$. The \verb|send| term itself
is reduced to the identifier of $r$'s lineage, $id(l)$.

Rule \textsc{R-Receive} moves an in-flight message $h \leftarrow m$
from $M$ to the local message queue of host $h$. Note that there may
be multiple in-flight messages with target $h$ in $M$; the message is
chosen non-deterministically in this case.

Rule \textsc{R-Respond} reduces a term $\texttt{respond}(h', \iota,
v)$ by sending a response message ${\Res \iota v}$ to $h'$.

Rule \textsc{R-Process} models the processing of a message $m$ taken
from the local message queue of a host $h$. Note that this rule is
only enabled if $h$ is {\it suspended}, waiting for a silo $\iota$ to
be materialized in local store $\sigma$. A host is suspended if its
current term has the form $E[\texttt{await}(\iota)]$ and $\iota \notin
dom(\sigma)$ (there is no mapping for $\iota$ in store $\sigma$).  The
premise $\iota \notin dom(\sigma)$ is important, since otherwise rule
\textsc{R-Local} would also be enabled. Rule \textsc{R-Process-Val} is
analogous to rule \textsc{R-Process} for the case where a host $h$ is
unable to reduce its term further.

The message processing logic is factored out into function
$\mathit{process}$ which we discuss in the following. In general,
processing a message $m$ on host $h$ in store $\sigma$ results in (a)
a term $t$ to be evaluated by $h$, (b) a set of new in-flight messages
$M'$, and (c) an updated store $\sigma'$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Message processing.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{mathpar}

\inferrule[\textsc{Proc-Res}] {
  \sigma' = [\iota \mapsto v]\sigma
} {
  process(h, {\Res \iota v}, \sigma) = (\texttt{unit}, \emptyset, \sigma')
}

\inferrule[\textsc{Proc-ReqParent}] {
  r = {\Ref l h} \quad
  l' = parent(l) \quad
  id(l') \notin dom(\sigma) \quad
  M = \{ h \leftarrow {\Req {h'} r \iota} \}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\texttt{send}({\Ref {l'} h}), M, \sigma)
}

\inferrule[\textsc{Proc-ReqMat1}] {
  r = {\Ref l h} \quad
  l = {\Mat {\iota'}} \quad \sigma(\iota') = v \quad
  M = \{ h' \leftarrow {\Res \iota v} \}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\texttt{unit}, M, \sigma)
}

\inferrule[\textsc{Proc-ReqMat2}] {
  r = {\Ref l h} \quad
  l = {\Mat {\iota'}} \quad \iota' \notin dom(\sigma) \quad
  M = \{ h \leftarrow {\Req {h'} r \iota} \}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\texttt{unit}, M, \sigma)
}

\inferrule[\textsc{Proc-ReqMap}] {
  r = {\Ref l h} \quad
  l = {\Mapped {\iota'} {l'} p} \quad
  \sigma(id(l'))  = v           \quad
  t = \texttt{respond}(h', \iota, p~v)
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \emptyset, \sigma)
}

\inferrule[\textsc{Proc-ReqFMap}] {
  r = {\Ref l h} \quad
  l = {\FMapped {\iota'} {l'} p} \quad
  \sigma(id(l')) = v \quad
  t = \texttt{respond}(h', \iota, \texttt{await}(\texttt{send}(p~v)))
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \emptyset, \sigma)
}

\end{mathpar}
\caption{Message processing.}\label{fig:process}
\end{figure}

\begin{defn}[Message processing]
  The function $process \in \mathcal{H} \times m \times S  \rightharpoonup t \times \mathcal{P}(\mathcal{H} \times m) \times S$ handles the processing of a message resulting in a term to be evaluated, a set of messages, and an updated store; here, $S = \mathcal{H} \times \mathbb{N} \rightharpoonup v$ is the type of a store. $process$ is defined in Fig.~\ref{fig:process}.
\end{defn}

The $\mathit{process}$ function must handle the two kinds of messages,
${\Req {h'} r \iota}$ and ${\Res \iota v}$. Processing a message of
the form ${\Res \iota v}$ means that a host is responding with the
value $v$ of a silo whose materialization has been requested by the
current host $h$ to complete its future $\iota$. Thus, it suffices to
create an updated store $\sigma'$ which maps $\iota$ to $v$ (rule
\textsc{Proc-Res}).

Processing a message of the form ${\Req {h'} r \iota}$ means that host
$h'$ requests the value of silo $r$ in order to complete a future with
identifier $\iota$. In the absence of caching/persisting, this
requires the receiver of the request to materialize the silo whose
value is requested. Section~\ref{sec:persist} introduces a refinement
of these rules to enable caching, thereby avoiding repeated
materializations of the same silo.

\comment{ However, it is also possible that silo $r$ is already
  materialized; in this case, the receiver of the request directly
  sends response ${\Res \iota v}$ to $h'$ (rule
  \textsc{Proc-Req}). Note that checking whether silo $r$ is
  materialized involves obtaining (a) the lineage $l$ of $r = {\Ref l
    h}$ and (b) the identifier $id(l)$ of lineage $l$. }


The requested silo $r = {\Ref l h}$ is materialized using its lineage
$l$. Rule \\\textsc{Proc-ReqParent} handles the case where $r$'s
parent $id(l')$ is not yet materialized ($l'$ is the lineage of $r$'s
parent). In this case, $\mathit{process}$ returns the term
$\texttt{send}({\Ref {l'} h})$; this causes host $h$ to request the
materialization of the parent silo ${\Ref {l'} h}$ before any other
message is processed. Note that a silo is always materialized on the
same host as its parent silo; therefore, the hosts of $r$ and its
parent are guaranteed to be the same. The original request ${\Req {h'}
  r \iota}$ is included in the new in-flight messages $M$, so that it
is eventually handled, namely when $r$'s parent is materialized.

Rules \textsc{Proc-ReqMap} and
\textsc{Proc-ReqFMap} are only enabled when the requested silo $r$ can
be materialized using its lineage $l$; in particular, $r$'s
parent must be materialized.

Rules \textsc{Proc-ReqMat1} and \textsc{Proc-ReqMat2} handle the case where $r$ does not have a
parent. In the case of \textsc{Proc-ReqMat1}, the materialization of $r$ is just the value $v$ of its materialized
lineage ${\Mat {\iota'}}$; thus, a response ${\Res \iota v}$ is
sent to host $h'$.
In the case of \textsc{Proc-ReqMat2}, lineage ${\Mat {\iota'}}$ is not yet materialized (i.e., host $h$ is still waiting for a message ${\Res {\iota'} {v'}}$); thus, the original request ${\Req {h'} r \iota}$ sent to $h$ is re-sent, to be processed again later.

Rule \textsc{Proc-ReqMap} handles the case where the lineage of $r$
begins with a $\text{Mapped}$ constructor. In this case, the
materialization of $r$ consists of the result of applying the spore
$p$ provided by the lineage to the value $v$ of the parent
silo. Evaluating the application $p~v$ requires multiple reduction
steps in general. Therefore, rule \textsc{Proc-ReqMap} returns the
term $\texttt{respond}(h', \iota, p~v)$ for evaluation by host $h$.
Thus, when $p~v$ has been reduced to a value $v'$, a response ${\Res
  \iota {v'}}$ is sent to host $h'$.

Rule \textsc{Proc-ReqFMap} is analogous to rule
\textsc{Proc-ReqMap}. The main difference is that here, $p~v$ reduces
to a {\em silo reference}. Therefore, before responding to host $h'$,
the value of silo $p~v$ is obtained by requesting its materialization
(using $\texttt{send}(p~v)$) and waiting for the completion of the
returned future using \verb|await|.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma \vdash x : T
}

\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma \vdash t : T'
} {
  \Gamma ; \Sigma \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T' \quad
  \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

\inferrule[\textsc{T-Unit}] {} {
  \Gamma ; \Sigma \vdash \unit : \texttt{Unit}
}

\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}     \quad
  \seq{x : T}, x : T ; \emptyset \vdash t : T' \quad
  \forall S \in \seq{T} , T'.~serializable(S)
} {
  \Gamma ; \Sigma \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

\inferrule[\textsc{T-AppSpore}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\} \quad
  \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

\inferrule[\textsc{T-SiloRef}] {
  \Sigma(id(l)) = T \quad
  \Sigma \vdash {\Ref l h}
} {
  \Gamma ; \Sigma \vdash {\Ref l h} : \texttt{SiloRef}[T]
}

\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{send}(t) : \texttt{Future}[T]
}

\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{await}(t) : T
}

\inferrule[\textsc{T-Ident}] {
  \Sigma(\iota) = T
} {
  \Gamma ; \Sigma \vdash \iota : \texttt{Future}[T]
}

\inferrule[\textsc{T-Respond}] {
  h \in \mathcal{H} \quad
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T] \quad
  \Gamma ; \Sigma \vdash t' : T
} {
  \Gamma ; \Sigma \vdash \texttt{respond}(h, t, t') : \texttt{Unit}
}

\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma \vdash t : \texttt{Host} \quad
  \Gamma ; \Sigma \vdash t' : T \quad serializable(T)
} {
  \Gamma ; \Sigma \vdash \texttt{populate}(t, t') : \texttt{SiloRef}[T]
}
\end{mathpar}
\caption{Type assignment.}\label{fig:type-rules}
\end{figure}

\subsection{Type Assignment}

Type assignment is based on a judgment of the form $\Gamma ; \Sigma
\vdash t : T$ which assigns term $t$ type $T$. $\Gamma$ is a standard
type environment which maps variables $x$ to types $T$; $\Sigma$ is a
store typing which maps identifiers $\iota$ to types
$T$. Figure~\ref{fig:type-rules} shows the rules for type
assignment. Rules \textsc{T-Var}, \textsc{T-Abs}, and \textsc{T-App}
are unchanged compared to a standard typed lambda
calculus~\cite{TAPL}.

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{S-Unit}] {} {
  serializable(\texttt{Unit})
}

\inferrule[\textsc{S-Host}] {} {
  serializable(\texttt{Host})
}

\inferrule[\textsc{S-SiloRef}] {} {
  serializable(\texttt{SiloRef}[T])
}

\inferrule[\textsc{S-Spore}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
}
\end{mathpar}
\caption{Serializable types.}\label{fig:ser-types}
\end{figure}

Rule \textsc{T-Spore} assigns a type to spore literals. Importantly,
the body of the spore's closure, $t$, must be well-typed in a type
environment containing only the closure parameter $x$ and the
variables $\seq{x}$ in the spore's header, as well as an empty store
typing. Furthermore, the types of captured variables as well as the
result type $T'$ must be serializable. The predicate $serializable$ is
defined in Figure~\ref{fig:ser-types}. These constraints ensure that
spore values are always independent of the environment of the creating
host. This independence is expressed by the following theorem:

\begin{thm}
\emph{(Serializable Values)}\label{lem:ser-values}
If $\Gamma ; \Sigma \vdash v : T$ and $serializable(T)$ then
$\emptyset ; \Sigma \vdash v : T$.
\end{thm}
\begin{proof}
By induction on the derivation of $\Gamma ; \Sigma \vdash v : T$. See
Appendix~\ref{app:ser-values}.
\end{proof}

Rule \textsc{T-AppSpore} is analogous to rule \textsc{T-App}. Rules
\textsc{T-Populate}, \textsc{T-Map}, and \textsc{T-FMap} are
straightforward; note that \verb|map| and \verb|flatMap| are
polymorphic in the types of the captured variables of their spore
argument types. Rules \textsc{T-Send} and \textsc{T-Await} are
entirely unsurprising. Rules \textsc{T-Ident} and \textsc{T-SiloRef}
are the only rules that use the store typing $\Sigma$. The type of an
identifier $\iota$ has the form $\texttt{Future}[T]$ where type $T$ is
looked up in the store typing. Rule \textsc{T-SiloRef} is analogous;
additionally, it requires the silo reference ${\Ref l h}$ to be
well-formed in $\Sigma$ (see below).

\subsection{Well-Formed Configurations}

Figure~\ref{fig:well-formed} shows the rules for well-formed
configurations. These rules are essential for establishing subject
reduction (see Section~\ref{sec:subject-reduction}). Rules
\textsc{WF-Store1-3} are straightforward. Rules \textsc{WF-Lin1-2}
require the types of $\iota$ and $id(l)$ given by the store typing
$\Sigma$ to be consistent with the corresponding type of spore
$p$. Both rules require parent lineage $l$ to be well-formed in
$\Sigma$. Rule \textsc{WF-Lin3} requires $\Sigma$ to be defined for
the identifier of a materialized silo. Rule \textsc{WF-Ref} extends
well-formedness of lineages to silo references. Rules \textsc{WF-Q1-3}
specify well-formedness of message queues in $\Sigma$. The remaining
rules lift well-formedness to host configurations
(\textsc{WF-HostConfig}), sets of hosts (\textsc{WF-Host1-2}), sets of
messages (\textsc{WF-Messages-Emp}, \textsc{WF-Messages}), and
configurations (\textsc{WF-Config}), respectively.

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{WF-Store1}] {} {
  \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Store2}] {
  \emptyset ; \Sigma \vdash v : T  \quad
  \Sigma \vdash \sigma
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto v]\sigma
}

\inferrule[\textsc{WF-Store3}] {
  \Sigma \vdash \sigma  \quad
  \Sigma' \supseteq \Sigma
} {
  \Sigma' \vdash \sigma
}

\inferrule[\textsc{WF-Lin1}] {
  \iota \in dom(\Sigma)
} {
  \Sigma \vdash {\Mat \iota}
}

\inferrule[\textsc{WF-Lin2}] {
  \Sigma(\iota) = T  \quad
  \Sigma(id(l)) = T' \quad
  \exists \Gamma.~\Gamma ; \Sigma \vdash p : T' \Rightarrow \texttt{SiloRef}[T]~\{\ldots\} \quad
  \Sigma \vdash l
} {
  \Sigma \vdash \text{FMapped}(\iota, l, p)
}

\inferrule[\textsc{WF-Lin3}] {
  \Sigma(\iota) = T  \quad
  \Sigma(id(l)) = T' \quad
  \exists \Gamma.~\Gamma ; \Sigma \vdash p : T' \Rightarrow T~\{\ldots\} \quad
  \Sigma \vdash l
} {
  \Sigma \vdash \text{Mapped}(\iota, l, p)
}

\inferrule[\textsc{WF-Ref}] {
  \Sigma \vdash l \quad h \in \mathcal{H}
} {
  \Sigma \vdash {\Ref l h}
}

\inferrule[\textsc{WF-Res}] {
  \Sigma(\iota) = T                \quad
  \emptyset ; \Sigma \vdash v : T
} {
  \Sigma \vdash {\Res \iota v}
}

\inferrule[\textsc{WF-Req}] {
  r = {\Ref l {h'}} \quad
  \Sigma(id(l)) = \Sigma(\iota) \quad
  \Sigma \vdash r
} {
  \Sigma \vdash {\Req h r \iota}
}

% TODO: Re-asses if \Gamma can be \emptyset?
\inferrule[\textsc{WF-HostConfig}] {
  \Sigma \vdash \sigma  \quad
  \exists \Gamma.~\Gamma ; \Sigma \vdash t : T
} {
  \Sigma \vdash (t, \sigma)^h
}

\inferrule[\textsc{WF-Host1}] {} { 
  \Sigma \vdash \emptyset
}

\inferrule[\textsc{WF-Host2}] {
  \Sigma \vdash (t, \sigma)^h  \quad
  \Sigma \vdash H
} {
  \Sigma \vdash \{ (t, \sigma)^h \} \cup H
}
% was wir ausschliessen muessen ist: \Sigma(\iota') \neq \Sigma'(\iota') fuer zwei verschiedene Hosts

\inferrule[\textsc{WF-Messages-Emp}] {} {
  \Sigma \vdash \emptyset
}

\inferrule[\textsc{WF-Messages}] {
  \Sigma \vdash m    \quad
  h \in \mathcal{H}  \quad
  \Sigma \vdash M
} {
  \Sigma \vdash \{ h \leftarrow m \} \uplus M
}

\inferrule[\textsc{WF-Config}] {
  \Sigma \vdash H \quad \Sigma \vdash M
} {
  \Sigma \vdash H~|~M
}
\end{mathpar}
\caption{Well-formedness.}\label{fig:well-formed}
\end{figure}


\subsection{Persist and Unpersist}\label{sec:persist}

As explained in Section~\ref{sec:primitives}, silos may be cached in
memory to avoid repeated materialization, which may be expensive for
large data sets. The design is inspired by the popular
Spark~\cite{Spark} data processing system. Essentially, a silo $r$ may
be {\em persisted} using the \verb|persist| primitive: the call
$\texttt{persist}(r)$ immediately returns a new silo reference $r'$
whose value, when materialized, is equal to the value of $r$.  The
lineage of $r'$ is equal to that of $r$ except for one additional
element: if $l$ is the lineage of silo $r$, then the lineage of $r'$
is of the form $l' = {\Per \iota l f}$. As for other constructors
(e.g., $\text{Mapped}$), $\iota$ is the identifier of lineage $l'$.
(As before, $\iota = (h, i)$ implies that host $h$ has called
\verb|persist|.)  The last argument is a binary operator $f \in \{
\cdot\cup\cdot, \cdot\setminus\cdot \}$ which toggles between the
behavior of \verb|persist| and \verb|unpersist|. If $f =
\cdot\cup\cdot$ then the lineage ${\Per \iota l f}$ implements the
behavior of \verb|persist|; otherwise, the behavior of
\verb|unpersist|. The extensions to syntax, lineages, and evaluation
contexts are summarized in Figure~\ref{fig:persist-syntax}.

\begin{figure}
\centering
$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                     & \mbox{{\it terms:}} \\
\gap \:\:\:\: \ldots                      & \mbox{} \\
\gap ~|~ \texttt{persist}(t)              & \mbox{persist} \\
\gap ~|~ \texttt{unpersist}(t)            & \mbox{unpersist} \\
& \\
l ::=                                    & \mbox{{\it{lineages:}}} \\
\gap \:\:\:\: \ldots                     & \mbox{} \\
\gap ~|~  \text{Persist}(\iota, l, f)    & \mbox{lineage with \texttt{persist}} \\
& \\
E ::=                             & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: \ldots              & \mbox{} \\
\gap ~|~  \texttt{persist}(E)     & \mbox{persist} \\
\gap ~|~  \texttt{unpersist}(E)   & \mbox{unpersist} \\
\ea$
\caption{Extensions to syntax, lineages, and evaluation contexts for
  \texttt{persist}/\texttt{unpersist}. $f$ is a binary operator with
  $f \in \{\cdot\cup\cdot,
  \cdot\setminus\cdot\}$.}\label{fig:persist-syntax}
\end{figure}

\subsubsection{Operational semantics}

In order to distinguish between silos that have been persisted and
those that have not, we extend stores $\sigma$ to map identifiers
$\iota$ not just to their associated value, but also to a so-called
``persist set'' $P$; if $\sigma(\iota) = (v, P)$ then $P$ contains all
hosts that have persisted silo $\iota$. Stores have thus the following
extended type:

\begin{defn}[Store]\label{def:store2}
  $\sigma \in \mathcal{H} \times \mathbb{N} \rightharpoonup v \times \mathcal{P}(\mathcal{H})$.
\end{defn}

\begin{figure}
\centering
\begin{mathpar}
\inferrule[\textsc{R-Persist}] {
  r = {\Ref l {h'}} \quad
  l' = \text{Persist}((h, i), l, \cdot \cup \cdot) \quad i~\text{fresh}
} {
  E[\texttt{persist}(r)]~|~\sigma
  \rightarrow^h
  E[{\Ref {l'} {h'}}]~|~\sigma
}

\inferrule[\textsc{R-Unpersist}] {
  r = {\Ref l {h'}} \quad
  l' = \text{Persist}((h, i), l, \cdot \setminus \cdot) \quad i~\text{fresh}
} {
  E[\texttt{unpersist}(r)]~|~\sigma
  \rightarrow^h
  E[{\Ref {l'} {h'}}]~|~\sigma
}

\inferrule[\textsc{R-Await}] {
  \sigma(\iota) = \highlight{(v, P)}
} {
  E[\texttt{await}(\iota)]~|~\sigma
  \rightarrow^h
  E[v]~|~\sigma
}
\end{mathpar}
\caption{Extension to local reduction.}\label{fig:reduction-persist}
\end{figure}

As a next step we extend the local reduction relation, as shown in
Figure~\ref{fig:reduction-persist}. First, we introduce the reduction
rules \textsc{R-Persist} and \textsc{R-Unpersist} to enable the
creation of $\text{Persist}$ lineages. Second, we adjust reduction
rule \textsc{R-Await} to use the extended store.

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{Proc-Res}] {
  \sigma' = [\iota \mapsto \highlight{(v, \emptyset)}]\sigma
} {
  process(h, {\Res \iota v}, \sigma) = (\texttt{unit}, \emptyset, \sigma')
}

\inferrule[\textsc{Proc-ReqPersist}] {
  r = {\Ref l h} \quad
  l              = {\Per {\iota'} {l'} \star}  \quad
  \iota'         = (h'', i)                    \\
  \sigma(id(l')) = (v, P)                      \quad
  P'             = P \star \{h''\}             \quad
  \sigma'        = [\iota' \mapsto (v, P')]\sigma
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\texttt{unit}, \{ h' \leftarrow {\Res \iota v} \}, \sigma')
}

\inferrule[\textsc{Proc-Req}] {
  r = {\Ref l h} \quad
  \sigma(id(l)) = (v, P) \quad
  \sigma' = {\consume {id(l)} P \sigma}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\texttt{unit}, \{ h' \leftarrow {\Res \iota v} \}, \sigma')
}

\inferrule[\textsc{Proc-ReqMap}] {
  r = {\Ref l h} \quad
  l = {\Mapped {\iota'} {l'} p} \quad
  \sigma(id(l'))  = \highlight{(v, P)} \\
  t = \texttt{respond}(h', \iota, p~v) \quad
  \highlight{\sigma' = {\consume {id(l')} P \sigma}}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \emptyset, \highlight{\sigma'})
}

\inferrule[\textsc{Proc-ReqFMap}] {
  r = {\Ref l h} \quad
  l = {\FMapped {\iota'} {l'} p} \quad
  \sigma(id(l')) = \highlight{(v, P)} \\
  t = \texttt{respond}(h', \iota, \texttt{await}(\texttt{send}(p~v))) \quad
  \highlight{\sigma' = {\consume {id(l')} P \sigma}}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \emptyset, \highlight{\sigma'})
}
\end{mathpar}
\caption{Extensions to message processing.}\label{fig:process-persist}
\end{figure}

The rules for message processing are impacted most. Intuitively, the
reason is that the fact whether a silo is (re-)materialized is
determined in the context of message
processing. Figure~\ref{fig:process-persist} shows new or extended
rules for message processing. Rule \textsc{Proc-Res} is simply
adjusted to the new store definition. Rule \textsc{Proc-ReqPersist} is
new; the rule enables processing requests ${\Req {h'} r \iota}$ in
cases where $r$ has a $\text{Persist}$ lineage and $r$'s parent is
materialized (otherwise, the above \textsc{Proc-ReqParent} rule would
be enabled).  Importantly, a silo with lineage ${\Per {\iota'} {l'}
  \star}$ has the same value as the parent silo which has identifier
$id(l')$.  Therefore, rule \textsc{Proc-ReqPersist} updates the store
to map the identifier of the persisted silo, $\iota'$, to the value of
$id(l')$ in $\sigma$. In addition, a {\em persist set} $P'$ is
computed based on (1) the persist set $P$ of the parent silo, (2) the
host $h''$ that created the $\text{Persist}$ lineage, and (3) the
operator $\star$ provided in the $\text{Persist}$ lineage. The latter
may either be set union or set difference; accordingly, the persisting
host $h''$ is either added or removed from the persist set $P$ of the
parent of the silo to-be-persisted. In case $h''$ is added to the
persist set (because host $h''$ called \verb|persist| rather than
\verb|unpersist|), it means that the persist set $P'$ is non-empty. As
a result, the mapping for $\iota'$ remains resident in the store,
avoiding re-materialization, as the following rules show.

Rule \textsc{Proc-Req} is also new. The rule is enabled when the
requested silo $r$ has already been materialized, i.e., $\sigma(id(l))
= (v, P)$. In this case, a response ${\Res \iota v}$ can directly be
sent back to the requesting host $h'$. Importantly, the rule also
checks whether the silo has been persisted, by examining its persist
set $P$ in store $\sigma$.  Using the $\mathit{consume}$ function, the
mapping for identifier $id(l)$ is {\em removed} from the updated store
$\sigma'$ if the persist set $P$ is empty. An empty persist set
indicates that the corresponding silo has not been
persisted. Concretely, the $\mathit{consume}$ function is defined as
follows:

\begin{defn}[Consume silo]\label{def:consume}
Consume silo referenced by $\iota$ with persist set $P$ in store $\sigma$ \\
$consume(\iota, P, \sigma) := \left\{\ba{ll}
    \sigma - \iota & \text{if } P = \emptyset \\
    \sigma         & \text{otherwise} \\
  \ea\right.$
\end{defn}

Rules \textsc{Proc-ReqMap} and \textsc{Proc-ReqFMap} are extended to
consume parent silos in case they have not been persisted.


\comment{
Definition~\ref{def:id} is extended to handle the following additional
case: $id(Persist(\iota, \_, \_)) =
\iota$. Definition~\ref{def:parent} is extended analogously. To
distinguish between persisted and regular silos when accessing their
data, we will utilize the following $\mathit{consume}$ function:}


\begin{figure}
\centering
\begin{mathpar}
\inferrule[\textsc{T-Persist}] {
  \Gamma ; \Sigma \vdash t : \SR{T}
} {
  \Gamma ; \Sigma \vdash \texttt{persist}(t) : \SR{T}
}

\inferrule[\textsc{T-Unpersist}] {
  \Gamma ; \Sigma \vdash t : \SR{T}
} {
  \Gamma ; \Sigma \vdash \texttt{unpersist}(t) : \SR{T}
}

\inferrule[\textsc{WF-Store2}] {
  \emptyset ; \Sigma \vdash v : T  \quad
  \Sigma \vdash \sigma
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto \highlight{(v, P)}]\sigma
}

\inferrule[\textsc{WF-Lin4}] {
  \Sigma(\iota) = T  \quad
  \Sigma(id(l)) = T  \quad
  \Sigma \vdash l
} {
  \Sigma \vdash {\Per \iota l {\star}}
}
\end{mathpar}
\caption{Extension to type assignment and well-formedness.}\label{fig:type-rules-persist}
\end{figure}

Figure~\ref{fig:type-rules-persist} shows the required extensions to
type assignment and well-formedness. The type rules \textsc{T-Persist}
and \textsc{T-Unpersist} are straightforward. Rule \textsc{WF-Store2}
is simply adjusted to the extended store definition. Rule
\textsc{WF-Lin4} defines well-formedness for $\text{Persist}$
lineages: the store typings for $\iota$ and $id(l)$ must be equal and
parent lineage $l$ must be well-formed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Subject reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Correctness Properties}\label{sec:correctness}

\subsection{Subject Reduction}\label{sec:subject-reduction}

This section establishes a subject reduction theorem for the presented
core language. The complete proof is provided in the appendix; here,
we restrict ourselves to summarizing the main results.

\begin{lem}
\emph{(Substitution)}\label{th:subst}
If $\Gamma , x : T' ; \Sigma \vdash t : T$ and $\Gamma ; \Sigma \vdash v : T'$ then $\Gamma ; \Sigma \vdash [x \mapsto v]t : T$.
\end{lem}
\begin{proof}
By induction on the derivation of $\Gamma , x : T' ; \Sigma \vdash t : T$.
\end{proof}

\begin{lem}
\emph{(Queue Concatenation)}\label{lem:queue-concat}
If $\Sigma \vdash Q$ and $\Sigma \vdash Q'$ then $\Sigma \vdash Q ::: Q'$.
\end{lem}
\begin{proof}
By induction on the length of $Q$. See Appendix~\ref{app:queue-concat}.
\end{proof}


\begin{thm}
\emph{(Subject Reduction)}\label{th:subject-reduction}

\begin{enumerate}

\item If $\Gamma ; \Sigma \vdash t : T$, $\Sigma \vdash \sigma$, and $t~|~\sigma \rightarrow^h t'~|~\sigma'$ then $\Gamma ; \Sigma' \vdash t' : T$, and $\Sigma' \vdash \sigma'$ for some $\Sigma' \supseteq \Sigma$.

\item If $\Sigma \vdash H~|~M$ and $H~|~M \twoheadrightarrow H'~|~M'$ then $\Sigma' \vdash H'~|~M'$ for some $\Sigma' \supseteq \Sigma$.

\end{enumerate}

\end{thm}
\begin{proof}
  Part 1: by induction on the derivation of $t~|~\sigma \rightarrow^h
  t'~|~\sigma'$. Part 2: by induction on the derivation of $H
  \twoheadrightarrow H'$. See Appendix~\ref{app:subject-reduction} for
  the complete proof.
\end{proof}


\subsection{Progress}\label{sec:progress}

This section formulates progress properties. The main
Theorem~\ref{thm:finite-mat} states that materialization requests are
satisfied after a finite number of reduction steps in so-called
``responsive configurations.''

In the following we assume a {\em fair scheduling} property which
ensures that in a well-formed configuration $H~|~M$, each message $h
\leftarrow m \in M$ is eventually received by host $h$. Fair
scheduling is also assumed in other models of distributed computing
like actors~\cite{Actors,Talcott}. Formally, fair scheduling is
defined as follows:

\begin{defn}[Fair Scheduling]\label{def:fair-scheduling}
  Let $\Sigma \vdash H~|~M$ and $h \leftarrow m \in M$. Then $H~|~M
  \twoheadrightarrow^* H'~|~M'$ such that $(t, \sigma, Q \cdot m)^h \in
  H'$ after a finite number of reduction steps.
\end{defn}

Although our focus is the establishment of desirable progress
properties for distributed reduction, it is necessary to consider the
following {\em strong normalization} property of single-host
reductions. For this, we consider the reduction relation $\leadsto$
defined as the subset of the reduction relation $\twoheadrightarrow$
excluding reduction rules \textsc{R-Receive}, \textsc{R-Process}, and
\textsc{R-Process-Val}.

\begin{lem}[Single-Host Strong Normalization]\label{lem:strong-normal}
  Let $\Sigma \vdash H~|~M$ where $H = \\ \{ (t, \sigma, Q)^h \} \cup
  H'$. Then $H~|~M \leadsto^* \{ (t', \sigma', Q)^h \} \cup H'~|~M'$
  after a finite number of reduction steps and either $t'$ is a value
  or $t' = E[\texttt{await}(\iota)]$.
\end{lem}

Note that in the above reduction, message queue $Q$ does not
change. Furthermore, only a single host $h$ is reduced. Conversely,
the set of in-flight messages may change, e.g., by applying rule
\textsc{R-Send}. A proof of Lemma~\ref{lem:strong-normal} is outside
the scope of this paper. However, our core language is, fundamentally,
not more expressive than the simply typed lambda calculus, for which
strong normalization holds.

The final prerequisite of our main progress theorem is a
responsiveness property, defined as follows.

\begin{defn}[Responsive Configuration]\label{def:resp-config}
  A configuration $\Sigma \vdash H~|~M$ is responsive {\em iff}

  $H = \{ (t, \sigma, Q \cdot m)^h \} \cup H' \Longrightarrow H~|~M \twoheadrightarrow^* \{ (t', \sigma', m \cdot Q')^h \} \cup H'~|~M'$ after a finite number of reduction steps.
\end{defn}

The following lemma ensures that the above responsiveness property is
preserved by reduction.

\begin{lem}[Responsiveness]\label{lem:resp}
  Let $\Sigma \vdash H~|~M$ be a responsive configuration.

  If $H~|~M \twoheadrightarrow H'~|~M'$ then $\Sigma' \vdash H'~|~M'$
  is a responsive configuration for some $\Sigma' \supseteq \Sigma$.
\end{lem}
\begin{proof}[Proof Sketch]
  By induction on the derivation of $H~|~M \twoheadrightarrow H'~|~M'$
  using Lemma~\ref{lem:strong-normal} and the definition of function
  $\mathit{process}$ (see
  Figures~\ref{fig:process}~and~\ref{fig:process-persist}).
\end{proof}

We are now ready to introduce the main progress theorem which states
that responsive configurations have the following property: when
sending a request ${\Req {h'} r \iota}$ to a host $h$, a corresponding
response ${\Res \iota v}$ is sent to host $h'$ after a finite number
of reduction steps. Formally:

\begin{thm}[Finite Materialization]\label{thm:finite-mat}
  If $\Sigma \vdash H~|~M$ is responsive, $m = {\Req {h'} r \iota}$, $r = {\Ref {l'} h}$,
  and $\Sigma \vdash m \cdot \epsilon$ then
  $H~|~(M \cup \{ h \leftarrow m \}) \twoheadrightarrow^* H'~|~(M' \cup \{ h' \leftarrow {\Res \iota v} \})$
  after a finite number of reduction steps.
\end{thm}
\begin{proof}[Proof Sketch]
  By structural induction on the shape of $r$.
  
  Fair scheduling ensures that $m$ is received in $h$'s queue after a
  finite number of reduction steps which preserve responsiveness by
  Lemma~\ref{lem:resp}. By Definition~\ref{def:resp-config} and
  Lemma~\ref{lem:strong-normal}, after another finite number of
  reduction steps, the host configuration of $h$ has the form $(t,
  \sigma, m \cdot Q)^h$ where either $t$ is a value or $t =
  E[\texttt{await}(\iota'')]$.

  \begin{itemize}
    \item Case $r = {\Ref {\Mat {\iota'}} h}$. The result follows from
      \textsc{R-Process}, \textsc{R-Process-Val}, and
      \textsc{Proc-ReqMat}.

    \item Case $r = {\Ref {\Mapped {\iota'} l p} h}$. Then either
      \begin{enumerate}
        \item $\sigma(id(l)) = v$. By \textsc{R-Process},
          \textsc{R-Process-Val}, and \textsc{Proc-ReqMap}, host $h$
          continues with the evaluation of $\texttt{respond}(h',
          \iota, p~v)$. By Lemma~\ref{lem:strong-normal} this results
          in sending a message $h' \leftarrow {\Res \iota {v'}}$ after a
          finite number of reduction steps.

        \item $id(l) \notin dom(\sigma)$. By \textsc{R-Process},
          \textsc{R-Process-Val}, and \textsc{Proc-ReqParent}, the
          messages $m$ and ${\Req h {\Ref l h} {id(l)}}$ are sent. By
          the induction hypothesis, a message $m' = {\Res {id(l)}
            {v'}}$ is sent to $h$ after a finite number of reduction
          steps. By Definition~\ref{def:fair-scheduling}, $m'$ is
          appended to $h$'s queue after a finite number of reduction
          steps. By Definition~\ref{def:resp-config}, $m'$ appears at
          the front of $h$'s queue after another finite number of
          reduction steps. By Lemma~\ref{lem:strong-normal} rule
          \textsc{R-Process} or \textsc{R-Process-Val} may be applied
          after another finite number of reduction steps, followed by
          an application of \textsc{R-ProcRes}. At this point, the
          original message $m$ is ensured to be processed according to
          the previous case after a finite number of steps.
      \end{enumerate}

    \item Case $r = {\Ref {\FMapped {\iota'} l p} h}$ is analogous to
      the previous case.
  \end{itemize}
\end{proof}


\section{Fault Handling}\label{sec:formal-fault-handling}

We now extend the presented formal model with a {\em fault handling}
mechanism based on lineage. Informally, our approach (a) enables hosts
to detect and respond to faults of other hosts using fault-handling
callbacks, and (b) recovers silos on faulty hosts by materializing
their lineages on healthy, fall-back hosts. As we are going to show, a
surprising result of our fault-handling extension is its simplicity
thanks to the power and flexibility of the lineages that are
constructed during reduction.

The first extension of our formal model consists of sets of {\em
  fault-handling callbacks} $F$ which are added to host
configurations. An extended host configuration has the form $(t,
\sigma, Q, F)^h$ where components $t$, $\sigma$, $Q$, and $h$ are
unchanged. A fault-handling callback $cb \in F$ has the form $cb = h''
\rightarrow (m, h')$. Informally, callback $cb$ expresses the fact
that when host $h''$ fails, message $m$ should be sent to host
$h'$. Thus, $h'$ takes the role of a {\em fall-back host}. The message
$m$ to be sent is typically a request ${\Req h r \iota}$ which could
not be handled in case host $h''$ fails.

A fault is modeled as a host $h$ that non-deterministically disappears
from the set of hosts $H$ in a global configuration $H~|~M$. We only
assume a simple form of fault detection: all other, healthy hosts $h'
\in H$ are notified of the disappearance of the faulty host $h$; no
other information about $h$ may be used to recover from its
failure. As a result, our formalization can model real distributed
systems which use off-the-shelf fault detectors such as
\cite{Hayashibara04}, which is also implemented in Akka~\cite{Akka},
among others.

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{R-Fault}] {
  M' = \bigcup_{c \in H} \{ h'' \leftarrow m ~|~ c = (t', \sigma', Q', F')^{h'} \land h \rightarrow (m, h'') \in F' \}
} {
  \{ (t, \sigma, Q, F)^h \} \cup H ~|~ M
  \twoheadrightarrow
  H ~|~ M \cup M'
}

\inferrule[\textsc{R-Send}] {
  r = {\Ref l {h''}} \quad
  m = {\Req h r {id(l)} } \quad
  M' = M \cup \{ h'' \leftarrow m \} \\
  \highlight{F' = F \cup \{ h'' \rightarrow ({\Req h {\Ref l {h'}} {id(l)} }, h') \}}
} {
  \{ (E[\texttt{send}(r, \highlight{h'})], \sigma, Q, \highlight{F})^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[id(l)], \sigma, Q, \highlight{F'})^h \} \cup H ~|~ M'
}
\end{mathpar}
\caption{Extensions to distributed reduction.}\label{fig:faults-reduction}
\end{figure}

The distributed reduction rules are extended as shown in
Figure~\ref{fig:faults-reduction}. Rule \textsc{R-Fault}
non-deterministically chooses a faulty host $h$ and removes it from
the set of hosts $H$ in the resulting configuration $H ~|~ M \cup
M'$. However, all other, healthy hosts get a chance to respond to the
failure of host $h$. For each host configuration $(t', \sigma', Q',
F')^{h'} \in H$, callbacks $cb \in F'$ handling faults of host $h$
(namely, those of the form $h \rightarrow (m, h'')$) are scheduled for
execution. A callback $h \rightarrow (m, h'')$ declares that message
$m$ should be sent to host $h''$ in case host $h$ fails. Thus, for
each callback of the above form, a message $h'' \leftarrow m$ is added
to the resulting set of in-flight messages $M \cup M'$.

The extended rule \textsc{R-Send} shows how this callback mechanism is
used to recover silos from faulty hosts (extensions compared to rule
\textsc{R-Send} in Section~\ref{sec:opsem} are highlighted). First,
calls to \verb|send| are extended with an additional host
argument. This host is used as a fall-back for materialization in case
the original host $h''$ of silo reference $r = {\Ref l {h''}}$
fails. To enable the recovery, the callback $h'' \rightarrow ({\Req h
  {\Ref l {h'}} {id(l)} }, h')$ is added to the resulting set $F'$ of
fault handlers. This means that in case host $h''$ fails, host $h$
requests materialization of silo reference ${\Ref l {h'}}$ to complete
its future $id(l)$. Note that the materialized silo has the same
lineage $l$ as the original silo reference $r$. The only difference is
that silo reference ${\Ref l {h'}}$ is materialized on host $h'$
instead of host $h''$. However, since both silo references have the
same lineage, the value which is the result of the materialization
will be the same.

\paragraph{Remark.} The fault-handling callback registered by rule \textsc{R-Send} is enabled
even after the originally requested silo $r$ has been materialized and
its value has been transmitted to other hosts. As a result, it is
possible that the value of the requested silo is computed
unnecessarily. However, this does not compromise correctness, since
the values of the recovered silo and the original silo are equal.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% OLD
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{figure}[t!]
%  \centering
%
%  $\ba[t]{l@{\hspace{2mm}}l}
%t ::=     x                                 & \mbox{variable}
%\\
%\gap ~|~  (x: T) \Rightarrow t              & \mbox{abstraction}
%\\
%\gap ~|~  t~t                               & \mbox{application}
%\\
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t  & \mbox{let binding}
%\\
%\gap ~|~  \{ \seq{l = t} \}                 & \mbox{record construction}
%\\
%\gap ~|~  t.l                               & \mbox{selection}
%\\
%\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}  & \mbox{spore}
%\\
%\gap ~|~  \texttt{map}(r, t[, t])           & \mbox{map}
%\\
%\gap ~|~  \texttt{flatMap}(r, t[, t])       & \mbox{flatMap}
%\\
%\gap ~|~  \texttt{send}(r)                  & \mbox{send}
%\\
%\gap ~|~  \texttt{await}(\iota)             & \mbox{await future}
%\\
%\gap ~|~  r                                 & \mbox{SiloRef}
%\\
%\gap ~|~  \iota                             & \mbox{future}
%\\
% & \\
%v ::=     (x: T) \Rightarrow t              & \mbox{abstraction}
%\\
%\gap ~|~  \{ \seq{l = v} \}                 & \mbox{record value}
%\\
%\gap ~|~  p                                 & \mbox{spore value}
%\\
%\gap ~|~  r                                 & \mbox{SiloRef}
%\\
%\gap ~|~  \iota                             & \mbox{future}
%\\
% & \\
%p ::=     \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}  & \mbox{spore value}
%\\
% & \\
%T ::=     T \Rightarrow T                   & \mbox{function type} \\
%\gap ~|~  \{ \seq{l : T} \}                 & \mbox{record type}   \\
%\gap ~|~  \mathcal{S}                       & \mbox{}
%\\
%\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type}
%\\
%\gap ~|~  T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}   & \mbox{abstract spore type}
%\\
%\ea$
%
%  % \vspace{1mm}
%  \caption{Core language syntax.}
%  \label{fig:syntax}
%  % \vspace{1mm}
%\end{figure}
%
%We formalize our programming model in the context of a standard, typed lambda
%calculus with records. Figure~\ref{fig:syntax} shows the syntax of our core
%language. Terms are standard except for the \texttt{spore}, \texttt{map},
%\texttt{flatMap}, \texttt{send}, and \texttt{await} terms. A \texttt{spore}
%term creates a new spore. It contains a list of variable definitions (the spore
%header) and the spore's closure. A term $\texttt{await}(\iota)$ blocks
%execution until the future $\iota$ has been completed asynchronously. The
%\texttt{map}, \texttt{flatMap}, and \texttt{send} primitives have been
%discussed earlier.
%
%\subsection{Operational semantics}
%\label{sec:opsem}
%
%\begin{figure}[ht!]
%  \centering
%
%  $\ba[t]{l@{\hspace{2mm}}l}
%h \in Hosts &
%\\
%i \in \mathbb{N} &
%\\
% & \\
%\iota  ::=  (h, i)                               & \mbox{location}
%\\
% & \\
%r ::=     \text{Mat}(\iota) & \mbox{materialized}
%\\
%\gap ~|~  \text{Mapped}(\iota, h, r, p, opt_f)   & \mbox{lineage with \texttt{map}}
%\\
%\gap ~|~  \text{FMapped}(\iota, h, r, p, opt_f)  & \mbox{lineage with \texttt{flatMap}}
%\\
% & \\
%E      ::=  \epsilon & \mbox{message queue}
%\\
%\gap ~|~    \text{Res}(\iota, v) \texttt{::} E      & \mbox{response}
%\\
%\gap ~|~    \text{Req}(h, r, \iota) \texttt{::} E   & \mbox{request}
%\\
%\gap ~|~    \text{ReqF}(h, r, \iota) \texttt{::} E  & \mbox{request (fault)}
%\\
%  \ea$
%
%  \vspace{1mm}
%  \caption{Elements of the operational model.}
%  \label{fig:elems-opsem}
%  \vspace{1mm}
%\end{figure}
%
%In the following we give a small-step operational semantics of the primitives
%of our language. The semantics is clearly stratified into a deterministic layer
%and a non-deterministic (concurrent) layer. Importantly, this means our
%programming model can benefit from existing reasoning techniques for sequential
%programs. Program transformations that are correct for sequential programs are
%also correct for distributed programs. Our programming model shares this
%property with some existing approaches such as~\cite{ConcurrentHaskell}.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{R-Map}]
%{ host(r) = h' \quad i~\text{fresh} \\
%  r' = \text{Mapped}((h, i), h', r, p, \text{None})
%}
%{ (R[\texttt{map}(r, p)], E, S)^h \longrightarrow (R[r'], E, S)^h }
%
%\inferrule[\textsc{R-FMap}]
%{ host(r) = h' \quad i~\text{fresh} \\
%  r' = \text{FMapped}((h, i), h', r, p, \text{None})
%}
%{ (R[\texttt{flatMap}(r, p)], E, S)^h \longrightarrow (R[r'], E, S)^h }
%
%\inferrule[\textsc{R-Await}]
%{ S(\iota) = \text{Some}(v)
%}
%{ (R[\texttt{await}(\iota)], E, S)^h \longrightarrow (R[v], E, S)^h }
%
%\inferrule[\textsc{R-Res}]
%{ E = \text{Res}(\iota, v) \texttt{::} E' \quad S' = S + (\iota \mapsto v)
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E', S')^h }
%
%\inferrule[\textsc{R-ReqLocal}]
%{ E = \text{Req}(h', r, \iota'') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' \neq \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
%  loc(r') = \iota' \quad S(\iota') = \text{None} \\
%  E'' = \text{Req}(h, r', \iota') \texttt{::} E
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \rightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%  % \vspace{-3mm}
%  \caption{Deterministic reduction.}
%  \label{fig:opsem-determ}
%  % \vspace{-3mm}
%\end{figure*}
%
%\paragraph{Notation and conventions.}
%
%We write $S' = S + (\iota \mapsto v)$ to express the fact that $S'$ maps
%$\iota$ to $v$ and otherwise agrees with $S$. We write $S(\iota) =
%\text{Some}(v)$ to express the fact that $S$ maps $\iota$ to $v$. We write
%$S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$. Reduction
%is defined using reduction contexts~\cite{TAPL}. We omit the definition of
%reduction contexts, since they are completely standard.
%
%\paragraph{Configurations.}
%
%The reduction rules of the deterministic layer define transitions of \emph{host
%configurations} $(t, E, S)^h$ of host $h$ where $t$ is a term, $E$ is a message
%queue, and $S$ is a silo store. The reduction rules of the non-deterministic
%layer define transitions of sets $H$ of host configurations. The reduced host
%configurations are chosen non-deterministically in order to express concurrency
%between hosts.
%
%\paragraph{Fault handling.}
%
%In the interest of clarity we present the reduction rules in two steps. In the
%first step we explain simplified rules without fault handling semantics
%(Sections~\ref{sec:det-layer} and~\ref{sec:nondet-layer}). In the second step
%we explain how these simplified rules have to be refined in order to support
%the fault handling principles of our model (Section~\ref{sec:faults-opsem}).
%
%\subsubsection{Decentralized identification}
%
%A important property of our programming model is the fact that silos are
%uniquely identified using \emph{decentralized identifiers}. A decentralized
%identifier $\iota$ has two components: (a) the identifier of the host $h$ that
%created $\iota$, and (b) a name $i$ created fresh on $h$ (e.g., an integer
%value): $\iota = (h, i)$. Decentralized identifiers are important, since they
%reconcile two conflicting properties central to our model. The first property
%is building computation DAGs locally, without remote communication. This is
%possible using decentralized identifiers, since each host can generate new
%identifiers independently of other remote hosts. The second property is
%allowing SiloRefs to be freely copied between remote hosts. This is possible,
%since decentralized identifiers uniquely identify silos without the need for
%subsequent updates of their information; decentralized identifiers are
%immutable. This latter property is essential to enable computation DAGs that
%are \emph{immutable upon construction}. In our programming model, computation
%DAGs are created using the standard monadic operations of SiloRefs. In
%particular, the \texttt{flatMap} operation (monadic bind) in general requires
%that its argument spore captures SiloRefs that are subsequently copied to a
%remote host. Hence it is essential that SiloRefs and the decentralized
%identifiers they contain be freely copyable between remote hosts.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{R-Send}]
%{ host(r) = h' \quad h' \neq h \quad i~\text{fresh} \\
%  \iota = (h, i) \quad m = \text{Req}(h, r, \iota)
%}
%{ \{ (R[\texttt{send}(r)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\iota], E, S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req1}]
%{ E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mat}(\iota) \\
%  S(\iota) = \text{Some}(v) \quad m = \text{Res}(\iota', v)
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S)^h, (t, E'' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req2}]
%{ E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' = \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
%  S(\iota_s) = \text{Some}(v) \quad p(v) = v' \quad S' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota', v')
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S'')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S')^h, (t, E'' \cdot m, S'')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req3}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
%  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{None} \quad host(r') = h' \quad m = \text{Req}(h, r', \iota') \quad E''' = \text{Req}(h'', r', \iota'') \texttt{::} E''
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req4}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
%  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{Some}(v') \quad S'' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota'', v')
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h''} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E'', S'')^h, (t, E' \cdot m, S')^{h''} \} \cup H
%}
%
%\end{mathpar}
%  % \vspace{-3mm}
%  \caption{Nondeterministic reduction.}
%  \label{fig:opsem-nondeterm}
%  % \vspace{-3mm}
%\end{figure*}
%
%\subsubsection{Deterministic layer}
%\label{sec:det-layer}
%
%We first consider the reduction rules of the deterministic layer shown in
%Figure~\ref{fig:opsem-determ}. The reduction rules for \texttt{map}
%(\textsc{R-Map}) and \texttt{flatMap} (\textsc{R-FMap}) do not involve
%communication with other hosts. In each case, a new SiloRef $r'$ is created
%that is derived from SiloRef $r$. The execution of the actual operation
%(\texttt{map} or \texttt{flatMap}, respectively) is deferred, and an object
%representing this derivation is returned. In both cases, the new SiloRef $r'$
%refers to a silo created on host $h'$ by applying the spore value $p$ to the
%value of silo $r$. The first component of the Mapped and FMapped objects, $(h,
%i)$, is a fresh \emph{location} created by host $h$ to uniquely identify the
%result silo.
%
%Most reduction rules are enabled when the current redex is an \texttt{await}
%term. The reduction of a term $\texttt{await}(\iota)$ only continues when store
%$S$ maps location $\iota$ to value $v$. In all other cases, the current host
%removes the next message from its message queue $E$. As shown in
%Figure~\ref{fig:elems-opsem} there are two types of messages: requests (Req)
%and responses (Res). A response $\text{Res}(\iota, v)$ tells its receiver that
%the silo at location $\iota$ has value $v$. A request $\text{Req}(h, r, \iota)$
%is sent on behalf of host $h$ to request the value of silo $r$ at location
%$\iota$. The reception of a response $\text{Res}(\iota, v)$ is handled by
%adding a mapping $(\iota \mapsto v)$ to the store (rule \textsc{R-Res}). The
%reception of a request $\text{Req}(h', r, \iota'')$ is handled locally if
%materialization of the requested silo $r$ is deferred and the parent silo $r'$
%in $r$'s lineage has not been materialized either. In this case, the host sends
%a request to materialize $r'$ to itself.
%
%
%
%\subsubsection{Nondeterministic layer}
%\label{sec:nondet-layer}
%
%All reduction rules in the nondeterministic layer, shown in
%Figure~\ref{fig:opsem-nondeterm}, involve communication between two hosts.
%
%Reducing a term $\texttt{send}(r)$ appends a request $\text{Req}(h, r, \iota)$
%to the message queue of host $h'$ of the requested silo $r$. In this case, host
%$h$ creates a unique location $\iota = (h, i)$ to identify the silo
%subsequently. Rules \textsc{R-Req1}, \textsc{R-Req2}, and \textsc{R-Req3}
%define the handling of request messages that cannot be handled locally. If the
%request can be serviced immediately (\textsc{R-Req1}), a response with the
%value $v$ of the requested silo $r$ is appended to the message queue of the
%requesting host $h'$. Rules \textsc{R-Req2} and \textsc{R-Reg3} handle cases
%where the requested silo is not already available in materialized form.
%
%% Failures may be detected whenever a message is sent to a non-local host. Note that this does not mean that message sends must be synchronous. Instead, our implementation interprets a failure to establish a network connection with a remote host as a failure of the remote host and thus a failure of all silos that it hosts.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{RF-Send}]
%{ host(r) = h' \quad h' \neq h \quad \text{failed}(h') \\
%  \quad i~\text{fresh} \quad \iota = (h, i) \quad S'' = S + (\iota \mapsto \bot)
%}
%{ \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \rightarrow \{ (R[\iota], E, S'')^h \} \cup H
%}
%
%\inferrule[\textsc{RF-Req4}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
%  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
%}
%
%\inferrule[\textsc{RF-Req5}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
%  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
%  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\inferrule[\textsc{RF-ReqF}]
%{ E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%  \vspace{-3mm}
%  \caption{Fault handling.}
%  \label{fig:opsem-faults}
%  \vspace{-3mm}
%\end{figure*}
%
%% \vspace{-2.25mm}
%\subsection{Fault handling}
%\label{sec:faults-opsem}
%% \vspace{-1mm}
%The key principles of the fault handling mechanism are:
%% \vspace{-1mm}
%\begin{itemize}
%\item Whenever a message is sent to a non-local host $h$, it is checked whether
%  $h$ is alive; if it is not, any silos located on $h$ are declared to have
%  failed.
%\item Whenever the value of a silo $r$ cannot be obtained due to another failed
%  silo, $r$ is declared to have failed.
%\item Whenever the failure of a silo $r$ is detected, the nearest predecessor
%  $r'$ in $r$'s lineage that is not located on the same host is determined. If
%  $r'$ has a fault handler $f$ registered, the execution of $f$ is requested.
%  Otherwise, $r'$ is declared to have failed.
%\end{itemize}
%
%% A host either (a) discovers itself that a remote silo has failed (e.g., because it could not establish a network connection to the remote host), or (b) is notified that a remote silo has failed by a healthy host involved in its materialization.
%
%These principles are embodied in the reduction as follows. First, we use the
%predicate $\text{failed}(h)$ as a way to check whether it is possible to
%communicate with host $h$ (e.g., an implementation could check whether it is
%possible to establish a socket connection). Second, failures of hosts are
%handled whenever communication is attempted: whenever a host $h$ intends to
%send a message to a host $h'$ where $h' \neq h$, it is checked whether
%$\text{failed}(h')$. If it is the case that $\text{failed}(h')$, either the
%corresponding location (silo or future) is declared as failed (and fault
%handling deferred), or a suitable fault handler is located and a recovery step
%is attempted. In the following we explain the extended reduction rules shown in
%Figure~\ref{fig:opsem-faults}.
%
%In rule \textsc{RF-Send}, the host of the requested silo $r$ is detected to
%have failed. However, the parent silos of $r$ are all located on the same
%(failed) host. Thus, in this case silo $r$ is simply declared as failed, and
%fault handling is delegated to other parts of the computation DAG that require
%the value of $r$ (if any). Since \texttt{send} is essentially a ``sink'' of a
%DAG, no suitable fault handler can be located at this point.
%
%This is different in rule \textsc{RF-Req4}. Here, host $h$ processes a message
%requesting silo $r$ which is the result of a \texttt{flatMap} call.
%Materializing $r$ requires obtaining the value of silo $r'$, the result of
%applying spore $p$ to the value $v$ of the materialized parent $r''$.
%Importantly, if the host of $r'$ is failed, it means the computation of the DAG
%defined by spore $p$ did not result in a silo on an available host.
%Consequently, if the \texttt{flatMap} call deriving $r$ specified a fault
%handler $p_f$, $p_f$ is applied to $v$ in order to recover from the failure.
%If the host of the resulting silo $r_f$ is not failed, the original request for
%$r$ is ``modified'' to request $r_f$ instead. This is done by removing message
%$\text{Req}(h'', r, \iota'')$ from the message queue and prepending message
%$\text{Req}(h'', r_f, \iota'')$. Moreover, host $h$ sends a message to itself,
%requesting the value of silo $r_f$.
%
%Rule \textsc{RF-Req5} shows fault recovery in the case where the lineage of a
%requested silo does not specify a fault handler itself. In this case, host $h$
%creates two fresh locations $\iota_p, \iota_a$. $\iota_p$ is supposed to be
%eventually mapped to the result value of executing the fault handler of parent
%silo $r''$. Host $h$ requests this value from itself using a special message
%$\text{ReqF}(h, r'', \iota_p)$. Finally, the original request for silo $r$ in
%message queue $E$ is replaced with a request for silo $r_a$. The silo $r_a$ is
%created analogous to $r$, but using silo $\text{Mat}(\iota_p)$ as parent
%(eventually, location $\iota_p$ is mapped to the result of applying the
%parent's fault handler). As demonstrated by rule \textsc{RF-ReqF}, ReqF
%messages used to request the application of the fault handler are handled in a
%way that is completely analogous to the way regular Req messages are handled,
%except that fault handlers $p_f$ are applied as opposed to regular spores $p$.
