%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                  & \mbox{{\it{terms:}}} \\
\gap \:\:\:\:  x                                                       & \mbox{variable} \\
\gap ~|~  (x: T) \Rightarrow t                                         & \mbox{abstraction} \\
\gap ~|~  t~t                                                          & \mbox{application} \\
\gap ~|~  \{ \seq{l = t} \}                                            & \mbox{record construction} \\
\gap ~|~  t.l                                                          & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(t)                                            & \mbox{spawn host} \\
\gap ~|~  \texttt{populate}(t, t)                                      & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t)                                           & \mbox{map} \\
\gap ~|~  \texttt{flatMap}(t, t)                                       & \mbox{flatMap} \\
\gap ~|~  \texttt{persist}(t)                                          & \mbox{persist} \\
\gap ~|~  \texttt{send}(t)                                             & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                            & \mbox{await future} \\   % await :: Fut a -> a
\gap ~|~  \iota                                                        & \mbox{location} \\
\gap ~|~  r                                                            & \mbox{silo reference} \\
                                                                       & \\
v ::=                                                                  & \mbox{{\it{values:}}} \\
\gap \:\:\:\: (x: T) \Rightarrow t                                     & \mbox{abstraction value} \\
\gap ~|~  \{ \seq{l = v} \}                                            & \mbox{record value} \\
\gap ~|~  p                                                            & \mbox{spore value} \\
\gap ~|~  \iota                                                        & \mbox{location} \\
\gap ~|~  r                                                            & \mbox{silo reference} \\
                                                                       & \\
p ::= \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}      & \\
& \\
T ::=                                                                  & \mbox{{\it{types:}}} \\
\gap \:\:\:\: T \Rightarrow T                                          & \mbox{abstraction type} \\
\gap ~|~  \{ \seq{l : T} \}                                            & \mbox{record type} \\
\gap ~|~  \mathcal{S}                                                  & \mbox{} \\
\gap ~|~  \texttt{Host}                                                & \mbox{host type} \\
\gap ~|~  \texttt{SiloRef}[T]                                          & \mbox{silo reference type} \\
\gap ~|~  \texttt{Future}[T]                                           & \mbox{future type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\} & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}                  & \mbox{abstract spore type}
\ea$
\caption{Abstract syntax of core language.}\label{fig:syntax}
\end{figure}

We formalize our programming model in the context of a standard, typed
lambda calculus with records. Figure~\ref{fig:syntax} shows the
abstract syntax of our core language. Terms are standard except for
the \verb|spore|, \verb|spawn|, \verb|populate|, \verb|map|,
\verb|flatMap|, \verb|persist|, \verb|send|, and \verb|await| terms. A
\verb|spore| term creates a new spore. It contains a list of variable
definitions (the spore header) and the spore's
closure. \note{summarize spawn and populate} A term
$\texttt{await}(t)$ blocks execution until the future $t$ has been
completed asynchronously. The \verb|map|, \verb|flatMap|, and
\verb|send| primitives have been discussed earlier.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Elements of the operational model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\centering

$\ba[t]{l@{\hspace{2mm}}l}
r ::=                                                  & \mbox{{\it{silo reference values:}}} \\
\gap \:\:\:\: \text{Mat}(\omega)                       & \mbox{materialized}                  \\
\gap ~|~  \text{Mapped}(\omega, r, p)                  & \mbox{lineage with \texttt{map}}     \\
\gap ~|~  \text{FMapped}(\omega, r, p)                 & \mbox{lineage with \texttt{flatMap}} \\
\gap ~|~  \text{Persist}(\omega, r, f)                 & \mbox{lineage with \texttt{persist}} \\
                                                       & \\
\omega  ::= (h,i) \quad \text{where}~i \in \mathbb{N}  & \mbox{decentralized identifier}      \\
                                                       & \\
Q      ::=                                             & \mbox{{\it{message queue values:}}}  \\
\gap \:\:\:\: \epsilon                                 & \mbox{empty queue}       \\
\gap ~|~    {\Res \omega v P} :: Q                     & \mbox{response (silo)}   \\
\gap ~|~    {\Req h r \omega} :: Q                     & \mbox{request (silo)}    \\
\gap ~|~    {\ReqF \iota \omega} :: Q                  & \mbox{request (future)}  \\
\ea$

\caption{Elements of the operational model.}\label{fig:elems-opsem}
\end{figure}


\note{describe operational model}

\begin{defn}[Host]
  The function application $host(r)$ obtains the host of silo $r$;
  $host$ is defined as follows:

  $host(r) := \left\{\begin{array}{ll}
      h         & \text{if } r = Mat((h, i)) \\
      host(r')  & \text{if } r = Mapped(\_, r', \_) \\
      host(r')  & \text{if } r = FMapped(\_, r', \_) \\
      host(r')  & \text{if } r = Persist(\_, r', \_)
    \end{array}\right.$
\end{defn}

Analogous to~\cite{TAPL}, Figure~\ref{fig:eval-ctx} defines the notion
of an evaluation context. We write $E[t]$ for the term obtained by
replacing the hole in evaluation context $E$ with term $t$. Evaluation
contexts capture the notion of the ``next subterm to be evaluated.''

\begin{figure}
\centering
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(E)                                                                               & \mbox{spawn} \\
\gap ~|~  \texttt{populate}(E, t)                                                                         & \mbox{populate (host)} \\
\gap ~|~  \texttt{populate}(v, E)                                                                         & \mbox{populate (spore)} \\
\gap ~|~  \texttt{map}(E, t)                                                                              & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E)                                                                              & \mbox{map (fun)} \\
\gap ~|~  \texttt{flatMap}(E, t)                                                                          & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E)                                                                          & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{persist}(E)                                                                             & \mbox{persist} \\
\gap ~|~  \texttt{send}(E)                                                                                & \mbox{send} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\ea$
\caption{Evaluation context.}\label{fig:eval-ctx}
\end{figure}


\begin{defn}[Silo reference identifier]
    $id(r) := \left\{\ba{ll}
    \omega  & \text{if } r = Mat(\omega) \\
    \omega  & \text{if } r = Mapped(\omega, r', \_) \\
    \omega  & \text{if } r = FMapped(\omega, r', \_) \\
    \omega  & \text{if } r = Persist(\omega, r', \_)
    \ea\right.$
\end{defn}

\begin{defn}[Silo reference parent]
    $parent(r) := \left\{\ba{ll}
    \None     & \text{if } r = Mat(\_) \\
    \Some{r'} & \text{if } r = Mapped(\_, r', \_) \\
    \Some{r'} & \text{if } r = FMapped(\_, r', \_) \\
    \Some{r'} & \text{if } r = Persist(\_, r', \_)
    \ea\right.$
\end{defn}

\begin{defn}[Consume silo]
Consume silo $\omega$ with persist set $P$ in silo store $S$ \\
  $consume(\omega, P, S) := \left\{\ba{ll}
  S - \omega & \text{if } P = \emptyset \\
  S          & \text{otherwise}
  \ea\right.$
\end{defn}

In the following we give a small-step operational semantics of the
primitives of our language. The semantics is clearly stratified into a
deterministic layer and a non-deterministic (concurrent)
layer. Importantly, this means our programming model can benefit from
existing reasoning techniques for sequential programs. Program
transformations that are correct for sequential programs are also
correct for distributed programs. Our programming model shares this
property with some existing approaches such
as~\cite{ConcurrentHaskell}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Lambda reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\centering

\begin{mathpar}
\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v']~|~\mu
  \rightarrow^h
  E[[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-ProjRcd}] {} {
  E[\{\seq{l_i = v_i^{i \in 1..n}}\}.l_j]~|~\mu
  \rightarrow^h
  E[v_j]~|~\mu
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v']~|~\mu
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-Await}] {
  \mu(\iota) = \text{Some}(v)
} {
  E[\texttt{await}(\iota)]~|~\mu
  \rightarrow^h
  E[v]~|~\mu
}

\inferrule[\textsc{R-Map}] {
  r' = \text{Mapped}((h, i), r, p) \quad
  i~\text{fresh}
} {
  E[\texttt{map}(r, p)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\inferrule[\textsc{R-FMap}] {
  r' = \text{FMapped}((h, i), r, p) \quad
  i~\text{fresh}
} {
  E[\texttt{flatMap}(r, p)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\inferrule[\textsc{R-Persist}] {
  r' = \text{Persist}((h, i), r, \cdot \cup \cdot) \quad
  i~\text{fresh}
} {
  E[\texttt{persist}(r)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\inferrule[\textsc{R-Unpersist}] {
  r' = \text{Persist}((h, i), r, \cdot \setminus \cdot) \quad
  i~\text{fresh}
} {
  E[\texttt{unpersist}(r)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\end{mathpar}
\caption{Sequential reduction.}\label{fig:seq-reduction}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-Seq}] { 
  E[t]~|~\mu \rightarrow^h E[t']~|~\mu'
} {
  (E[t], \mu, Q, S)^h
  \longrightarrow
  (E[t'], \mu', Q, S)^h
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\inferrule[\textsc{R-Send1Local}] {
  host(r) = h                               \quad
  S(id(r)) = (\Val{v}, P)                   \\
  \iota~\text{fresh}                       \quad
  \mu' = [\iota \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{send}(r)], \mu, Q, S)^h
  \longrightarrow
  (E[\iota], \mu', Q, S)^h
}

\inferrule[\textsc{R-Send2Local}] {
  host(r)    = h                         \quad
  id(r) \notin dom(S)                    \\
  \iota~\text{fresh}                    \quad
  \mu' = [\iota \mapsto \text{None}]\mu
} {
  (E[\texttt{send}(r)], \mu, Q, S)^h
  \longrightarrow
  (E[\iota], \mu', Q \cdot {\Req h r {id(r)}} \cdot {\ReqF {\iota} {id(r)}}, S)^h
}

\inferrule[\textsc{R-ReqF1}] {
  Q         = {\ReqF \iota \omega} :: Q' \quad
  S(\omega) = (\Val{v}, P)               \\
  S'        = {\consume \omega P S}      \quad
  \mu'      = [\iota \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu', Q', S')^h
}

\inferrule[\textsc{R-ReqF2}] {
  Q           = {\ReqF \iota \omega} :: Q'    \quad
  \omega \notin dom(S)
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu, Q' \cdot {\ReqF \iota \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (future).}
\end{figure}

% Note: design approach is to *not* replace Fwds in the silo store, since
% it would require copying data. Instead, we leverage the flexibility of
% Req messages to correctly forward requests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Important that Res message contains correct P, since R-Res
% updates silo store.
% Goal: theorem which states that persist sets are "correct".
% We don't lose hosts from persist sets.

\begin{figure}[ht!]
\centering

\begin{mathpar}

\inferrule[\textsc{R-Res}] {
  Q  = {\Res \omega v P} :: Q'          \\
  S' = [\omega \mapsto (\Val{v}, P)]S
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q', S')^h
}

\inferrule[\textsc{R-Req1Local}] {
  Q         = {\Req h r \omega} :: Q'        \quad %
  S(id(r))  = (\Fwd{r'}, P)                  \quad %
  S(id(r')) = (\Val{v}, P')                  \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v P}, S)^h
}

\inferrule[\textsc{R-Req2Local}] {
  Q         = {\Req h r \omega} :: Q'              \quad %
  S(id(r))  = (\Fwd{r'}, P)                        \quad %
  id(r') \notin dom(S)                             \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} \omega}, S)^h
}

\inferrule[\textsc{R-ReqMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'               \quad %
  r          = \text{Mapped}(\omega', r', p)            \quad %
  S(id(r'))  = (\Val{v}, P)                             \\
  v'         = p(v)                                          \quad %
  S'         = [\omega' \mapsto (\Val{v'}, \emptyset)]S      \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} r \omega}, S'')^h
}

\inferrule[\textsc{R-ReqFMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'      \quad %
  r          = \text{FMapped}(\omega', r', p)  \quad %
  S(id(r'))  = (\Val{v}, P)                    \\
  r''        = p(v)                                        \quad %
  S'         = [\omega' \mapsto (\Fwd{r''}, \emptyset)]S   \quad
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} {r''} \omega}, S'')^h
}

\inferrule[\textsc{R-ReqPersistLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'                      \quad %
  r          = {\Per {\omega'} {r'} \star}                  \quad %
  \omega'    = (h'', i)                                      \quad %
  S(id(r'))  = (\Val{v}, P)                               \\
  P'         = P \star \{h''\}                               \quad %
  S'         = [\omega' \mapsto (\Val{v}, P')]S            \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q,  S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v {P'}}, S'')^h
}

\inferrule[\textsc{R-ReqParentLocal}] {
  Q               = {\Req {h'} r \omega} :: Q'  \quad %
  \text{Some}(r') = parent(r)                  \quad %
  id(r') \notin dom(S)                          \\
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (silo).}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Non-deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% (t, Q, S)^h_c -> <crash>
% H' = { h' | h \in H \land h' = crashed(h_c, h) }
% --------------------------------------------------
%    { (t, Q, S)^h_c } \cup H -->> H'
%
%
% update silo store to reflect crash of h_c
% S' = { id -> (v, C') | id -> (v, C) \in S \land C' = C[h_c -> 0] }
% ---------------------------------------------------------------------
%    crashed(h_c, (t, Q, S)^h) = (t, Q, S')^h
%
%
%   S(id) =  Some(v)       |  None
%
%   S(id) = (Some(v), cnt) | (None, cnt)
%
%   S(id) = (Some(v), [h -> 3, h' -> 2]) | (None, ...)
%
%   S(id) = (Some(v), C)   | (None, C)


\begin{figure}[ht!]
\begin{mathpar}
\inferrule[\textsc{R-Determ}] {
  (t, \mu, Q, S)^h \rightarrow (t', \mu', Q', S')^h
} { 
  \{ (t, \mu, Q, S)^h \} \cup H
  \twoheadrightarrow
  \{ (t', \mu', Q', S')^h \} \cup H
}

\inferrule[\textsc{R-Spawn}] { 
  h'~\text{fresh}    \quad
  \iota~\text{fresh} \quad
  \mu' = [\iota \mapsto h']\mu
} {
  \{ (E[\texttt{spawn}(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})], \mu, Q, S)^h \} \cup H
  \\ \twoheadrightarrow
  \{ (E[\iota], \mu', Q, S)^h, ((\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~\{\}, \epsilon, \epsilon, \epsilon)^{h'} \} \cup H
}

% TODO send spore instead of a value `v`
\inferrule[\textsc{R-Populate}] { 
  \mu(\iota) = h'                                         \quad
  S''        = [\omega \mapsto ({\Val v}, \emptyset)]S'   \quad
  \omega     = (h', i)                                    \quad
  i~\text{fresh}
} {
  \{ (E[\texttt{populate}(\iota, v)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\text{Mat}(\omega)], \mu, Q, S)^h, (t', \mu', Q', S'')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req1}] {
  Q        = {\Req {h'} r \omega} :: Q''  \quad
  S(id(r)) = (\Val{v}, P)                 \quad
  m        = {\Res \omega v P}
} {
  \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

% Rules that send Req:
% R-Send: true (append)
% (R-Req2Map: true (prepend))
% R-Req2Fwd: true (prepend)
% 
% if a rule sends Req(h, r) to h', is it true that host(r) == h'?
% XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\inferrule[\textsc{R-Req2}] {
  Q         = {\Req {h'} r \omega} :: Q''           \quad %
  S(id(r))  = (\Fwd{r'}, P)             \\ %
  S(id(r')) = (\Val{v}, P')             \quad %
  m         = {\Res \omega v P}
} {
  \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

% 1. Angenommen Host h hat einen \Fwd{r'}, dann wissen wir nicht, 
%    auf welchem Host r' liegt. Das war der eigentliche Grund, Fwd
%    einzufuehren, weil dann ein flatMap keine Daten transferieren muss.
%    D.h. wir wollen zulassen, dass eine Referenz in einem Fwd auf
%    einem beliebigen Host liegen kann.
% Jetzt kann es sein, dass ich auf Host h ein r = r0.flatMap(p) mache.
% diese Referenz r kann ich an einen anderen Host h' geben.
% Jetzt macht Host h' ein r.send(). D.h., h' schickt einen Req(h', r) an h.
% Jetzt sagt Host h: S(id(r)) = Fwd(r'), und r' kann auch auf Host h' sein
% (da Host von r' beliebig wie oben erwaehnt).
% Und in diesem Fall gilt, dass host(r') = h' ist, und daher Host h
% einen Req(h', r' r) an h'' = h' sendet. Das hat zur Folge, das Host h'
% jetzt einen Req(h', r', r) bearbeiten muss. Daher muessen auch die lokalen
% Regeln mit zwei unterschiedlichen Referenzen umgehen koennen, weil
% r definitiv ungleich r' ist.
\inferrule[\textsc{R-Req3}] {
  Q         = {\Req {h''} r \omega} :: Q''           \quad %
  S(id(r))  = (\Fwd{r'}, P)                          \\ %
  id(r') \notin dom(S)                               \quad %
  h'        = host(r')                               \quad %
  m         = {\Req {h''} {r'} \omega}
} {
  \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Send}] {
  host(r) = h'                          \quad
  h' \neq h                             \quad
  m = {\Req h r {id(r)}}                \quad
  \iota~\text{fresh}                    \quad
  \mu'' = [\iota \mapsto \text{None}]\mu
} {
  \{ (E[\texttt{send}(r)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\iota], \mu'', Q, S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

\end{mathpar}
\caption{Non-deterministic reduction.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{S-Record}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(\{ \seq{l : T} \})
}

\inferrule[\textsc{S-Spore}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
}

\inferrule[\textsc{S-SiloRef}] {} {
  serializable(\texttt{SiloRef}[T])
}

\end{mathpar}
\caption{Serializable types.}
\end{figure}


\begin{figure}[ht!]
\begin{mathpar}
% variable
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma ; \Delta \vdash x : T
}

\inferrule[\textsc{T-Loc}] {
  \Sigma(\iota) : T
} {
  \Gamma ; \Sigma ; \Delta \vdash \iota : T
}

% abstraction
\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma ; \Delta \vdash t : T'
} {
  \Gamma ; \Sigma ; \Delta \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

% application
\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma ; \Delta \vdash t : T \Rightarrow T' \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : T
} { 
  \Gamma ; \Sigma ; \Delta \vdash (t~t') : T'
}

% record
\inferrule[\textsc{T-Record}] {
  \Gamma ; \Sigma ; \Delta \vdash \seq{t} : \seq{T}
} {
  \Gamma ; \Sigma ; \Delta \vdash \{ \seq{l = t} \} : \{ \seq{l : T} \}
}

% selection
\inferrule[\textsc{T-Select}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \{ \seq{l : T} \}
} {
  \Gamma ; \Sigma ; \Delta \vdash t.l_i : T_i
}

% spore
\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma ; \Delta \vdash \seq{t} : \seq{T}  \quad
  \seq{x : T}, x : T ; \emptyset ; \Delta \vdash t : T' \quad
  \forall T_i \in \seq{T}.~serializable(T_i)
} { 
  \Gamma ; \Sigma ; \Delta \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

\inferrule[\textsc{T-AppSpore}] {
  \Gamma ; \Sigma ; \Delta \vdash t : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\} \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : T
} { 
  \Gamma ; \Sigma ; \Delta \vdash (t~t') : T'
}

% spawn
\inferrule[\textsc{T-Spawn}] {
  \Gamma ; \Sigma ; \Delta \vdash t : (\{\} \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{spawn}(t) : \texttt{Host}
}

% populate
% TODO make async (Future[SiloRef[T]]); cf. R-Populate
\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{Host} \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : T            \quad
  serializable(T)
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{populate}(t, t') : \texttt{SiloRef}[T]
}

% map
\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

% flatMap
\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

% persist
\inferrule[\textsc{T-Persist}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{persist}(t) : \texttt{SiloRef}[T]
}

% send
\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{send}(t) : \texttt{Future}[T]
}

\inferrule[\textsc{T-SiloRef}] {
  \Delta(id(r)) = T \quad
  \Delta \vdash r
} {
  \Gamma ; \Sigma ; \Delta \vdash r : \texttt{SiloRef}[T]
}

% await
\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{await}(t) : T
}

\end{mathpar}
\caption{Type assignment.}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Subject reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{WF-Store1}] {} {
  \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Store2}] {
  \Sigma \vdash \mu
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto v]\mu
}

\inferrule[\textsc{WF-Ref1}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma ; \Delta \vdash p : T' \Rightarrow T~\{\ldots\} \quad
  \Delta \vdash r
} {
  \Delta \vdash \text{Mapped}(\omega, r, p)
}

\inferrule[\textsc{WF-Ref2}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma ; \Delta \vdash p : T' \Rightarrow \texttt{SiloRef}[T]~\{\ldots\} \quad
  \Delta \vdash r
} {
  \Delta \vdash \text{FMapped}(\omega, r, p)
}

\inferrule[\textsc{WF-Ref3}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T   \quad
  \Delta \vdash r
} {
  \Delta \vdash {\Per \omega r {\star}}
}

\inferrule[\textsc{WF-Ref4}] {
  \omega \in dom(\Delta)
} {
  \Delta \vdash {\text{Mat}(\omega)}
}

\inferrule[\textsc{WF-SiloStore1}] {} {
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-SiloStore2}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset ; \Delta \vdash v : T  \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto ({\Val v}, P)]S
}

\inferrule[\textsc{WF-SiloStore3}] {
  \Delta(id(r)) = \Delta(\omega)      \quad
  \Delta \vdash r                     \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto ({\Fwd r}, P)]S
}

\inferrule[\textsc{WF-Q1}] {} {
  \Delta ; \Sigma \vdash \epsilon
}

\inferrule[\textsc{WF-Q2}] {
  \Delta(\omega) = T                  \quad
  \Sigma(\iota)  = \texttt{Future}[T] \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\ReqF \iota \omega} :: Q
}

\inferrule[\textsc{WF-Q3}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset ; \Delta \vdash v : T  \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Res \omega v P} :: Q
}

\inferrule[\textsc{WF-Q4}] {
  \Delta(id(r)) = \Delta(\omega) \quad
  \Delta \vdash r \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Req h r \omega} :: Q
}

\inferrule[\textsc{WF-HostConfig}] {
  \Sigma \vdash \mu              \quad
  \Delta \vdash S                \quad
  \Delta ; \Sigma \vdash Q       \quad
  \Gamma ; \Sigma ; \Delta \vdash t : T
} {
  \Delta ; \Sigma \vdash (t, \mu, Q, S)^h
}

\inferrule[\textsc{WF-Host1}] {} { 
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-Host2}] {
  \exists \Sigma.~\Delta ; \Sigma \vdash (t, \mu, Q, S)^h  \quad
  \Delta \vdash H
} {
  \Delta \vdash \{ (t, \mu, Q, S)^h \} \cup H
}

\end{mathpar}
\caption{Well-formedness.}
\end{figure}

\begin{thm}
\emph{(Substitution Lemma)}\label{th:subst}
If $\Gamma , x : T' ; \Sigma ; \Delta \vdash t : T$ and $\Gamma ; \Sigma ; \Delta \vdash v : T'$ then $\Gamma ; \Sigma ; \Delta \vdash [x \mapsto v]t : T$.
\end{thm}
\begin{proof}
By induction on the derivation of $\Gamma , x : T' ; \Sigma ; \Delta \vdash t : T$.
\end{proof}

\begin{thm}
\emph{(Queue Concat)}\label{lem:queue-concat}
If $\Delta ; \Sigma \vdash Q$ and $\Delta ; \Sigma \vdash Q'$ then $\Delta ; \Sigma \vdash Q ::: Q'$.
\end{thm}
\begin{proof}
By induction on the length of $Q$. The case where $Q = \epsilon$ is trivial.

Case $Q = m :: Q''$.
\begin{enumerate}
\item[A1.] By WF-Q1-4, $\Delta ; \Sigma \vdash Q''$.
\item[A2.] By the IH, $\Delta ; \Sigma \vdash Q'' ::: Q'$.
\end{enumerate}

\begin{itemize}
\item Case $m = {\ReqF \iota \omega}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(\omega) = T$
  \item $\Sigma(\iota) = \texttt{Future}[T]$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 2.
\item By A2., 1.a-b), and WF-Q2, $\Delta ; \Sigma \vdash m :: Q'' ::: Q'$.
\end{enumerate}

\item Case $m = {\Res \omega v P}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q3
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(\omega) = T$
  \item $\emptyset ; \emptyset \vdash v : T$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 2.
\item By A2., 1.a-b), and WF-Q3, $\Delta ; \Sigma \vdash m :: Q'' ::: Q'$.
\end{enumerate}

\item Case $m = {\Req h r \omega}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta ; \Sigma \vdash Q''$
  \item $\Delta \vdash r$
  \end{enumerate}
% 2.
\item By A2., 1.a,c), and WF-Q4, $\Delta ; \Sigma \vdash m :: Q'' ::: Q'$.
\end{enumerate}
\end{itemize}
\end{proof}

\begin{thm}
\emph{(Queue Ordering)}\label{lem:queue-ordering}
If $\Delta ; \Sigma \vdash m :: Q$ then $\Delta ; \Sigma \vdash Q \cdot m$.
\end{thm}
\begin{proof}
By the assumption and WF-Q1-4, $\Delta ; \Sigma \vdash m :: \epsilon$ and $\Delta ; \Sigma \vdash Q$. By Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash Q ::: (m :: \epsilon)$.
\end{proof}

\begin{thm}
\emph{(Serializable Values)}\label{lem:ser-values}
If $\Gamma ; \Sigma ; \Delta \vdash v : T$ and $serializable(T)$ then $\emptyset ; \emptyset ; \Delta \vdash v : T$.
\end{thm}
\begin{proof}
By induction on a derivation of $\Gamma ; \Sigma ; \Delta \vdash v : T$ with a case analysis on the last applied rule.

\begin{itemize}
\item Case T-SiloRef follows trivially.

\item Case T-Record.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma ; \Delta \vdash v : T$
  \item $serializable(T)$
  \end{enumerate}
% 2.
\item By T-Record
  \begin{enumerate}[label=(\alph*)]
  \item $v = \{\seq{l = v}\}$
  \item $T = \{\seq{l : T}\}$
  \item $\Gamma ; \Sigma ; \Delta \vdash \seq{v} : \seq{T}$
  \end{enumerate}
% 3.
\item By 2.b) and S-Record, $\forall T_i \in \seq{T}.~serializable(T_i)$.
% 4.
\item By 2.c), 3., and the IH, $\emptyset ; \emptyset ; \Delta \vdash \seq{v} : \seq{T}$.
% 5.
\item By 4. and T-Record, $\emptyset ; \emptyset ; \Delta \vdash \{\seq{l = v}\} : \{\seq{l : T}\}$.
\end{enumerate}

\item Case T-Spore is analogous to case T-Record.
\end{itemize}
\end{proof}

\begin{thm}
\emph{(Subject Reduction)}\label{th:pres}

\begin{enumerate}

\item If $\Gamma ; \Sigma ; \Delta \vdash t : T$, $\Sigma \vdash \mu$, and $t~|~\mu \rightarrow^h t'~|~\mu'$ then $\Gamma ; \Sigma' ; \Delta' \vdash t' : T$, and $\Sigma' \vdash \mu'$ for some $\Sigma' \supseteq \Sigma$ and $\Delta' \supseteq \Delta$.

\item If $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$ and $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$ then $\Delta' ; \Sigma' \vdash (t', \mu', Q', S')^h$ for some $\Delta' \supseteq \Delta$ and $\Sigma' \supseteq \Sigma$.

\item If $\Delta \vdash H$ and $H \twoheadrightarrow H'$ then $\Delta' \vdash H'$ for some $\Delta' \supseteq \Delta$.

\end{enumerate}

\end{thm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% OLD
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{figure}[t!]
%  \centering
%
%  $\ba[t]{l@{\hspace{2mm}}l}
%t ::=     x                                 & \mbox{variable}
%\\
%\gap ~|~  (x: T) \Rightarrow t              & \mbox{abstraction}
%\\
%\gap ~|~  t~t                               & \mbox{application}
%\\
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t  & \mbox{let binding}
%\\
%\gap ~|~  \{ \seq{l = t} \}                 & \mbox{record construction}
%\\
%\gap ~|~  t.l                               & \mbox{selection}
%\\
%\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}  & \mbox{spore}
%\\
%\gap ~|~  \texttt{map}(r, t[, t])           & \mbox{map}
%\\
%\gap ~|~  \texttt{flatMap}(r, t[, t])       & \mbox{flatMap}
%\\
%\gap ~|~  \texttt{send}(r)                  & \mbox{send}
%\\
%\gap ~|~  \texttt{await}(\iota)             & \mbox{await future}
%\\
%\gap ~|~  r                                 & \mbox{SiloRef}
%\\
%\gap ~|~  \iota                             & \mbox{future}
%\\
% & \\
%v ::=     (x: T) \Rightarrow t              & \mbox{abstraction}
%\\
%\gap ~|~  \{ \seq{l = v} \}                 & \mbox{record value}
%\\
%\gap ~|~  p                                 & \mbox{spore value}
%\\
%\gap ~|~  r                                 & \mbox{SiloRef}
%\\
%\gap ~|~  \iota                             & \mbox{future}
%\\
% & \\
%p ::=     \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}  & \mbox{spore value}
%\\
% & \\
%T ::=     T \Rightarrow T                   & \mbox{function type} \\
%\gap ~|~  \{ \seq{l : T} \}                 & \mbox{record type}   \\
%\gap ~|~  \mathcal{S}                       & \mbox{}
%\\
%\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type}
%\\
%\gap ~|~  T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}   & \mbox{abstract spore type}
%\\
%\ea$
%
%  % \vspace{1mm}
%  \caption{Core language syntax.}
%  \label{fig:syntax}
%  % \vspace{1mm}
%\end{figure}
%
%We formalize our programming model in the context of a standard, typed lambda
%calculus with records. Figure~\ref{fig:syntax} shows the syntax of our core
%language. Terms are standard except for the \texttt{spore}, \texttt{map},
%\texttt{flatMap}, \texttt{send}, and \texttt{await} terms. A \texttt{spore}
%term creates a new spore. It contains a list of variable definitions (the spore
%header) and the spore's closure. A term $\texttt{await}(\iota)$ blocks
%execution until the future $\iota$ has been completed asynchronously. The
%\texttt{map}, \texttt{flatMap}, and \texttt{send} primitives have been
%discussed earlier.
%
%\subsection{Operational semantics}
%\label{sec:opsem}
%
%\begin{figure}[ht!]
%  \centering
%
%  $\ba[t]{l@{\hspace{2mm}}l}
%h \in Hosts &
%\\
%i \in \mathbb{N} &
%\\
% & \\
%\iota  ::=  (h, i)                               & \mbox{location}
%\\
% & \\
%r ::=     \text{Mat}(\iota) & \mbox{materialized}
%\\
%\gap ~|~  \text{Mapped}(\iota, h, r, p, opt_f)   & \mbox{lineage with \texttt{map}}
%\\
%\gap ~|~  \text{FMapped}(\iota, h, r, p, opt_f)  & \mbox{lineage with \texttt{flatMap}}
%\\
% & \\
%E      ::=  \epsilon & \mbox{message queue}
%\\
%\gap ~|~    \text{Res}(\iota, v) \texttt{::} E      & \mbox{response}
%\\
%\gap ~|~    \text{Req}(h, r, \iota) \texttt{::} E   & \mbox{request}
%\\
%\gap ~|~    \text{ReqF}(h, r, \iota) \texttt{::} E  & \mbox{request (fault)}
%\\
%  \ea$
%
%  \vspace{1mm}
%  \caption{Elements of the operational model.}
%  \label{fig:elems-opsem}
%  \vspace{1mm}
%\end{figure}
%
%In the following we give a small-step operational semantics of the primitives
%of our language. The semantics is clearly stratified into a deterministic layer
%and a non-deterministic (concurrent) layer. Importantly, this means our
%programming model can benefit from existing reasoning techniques for sequential
%programs. Program transformations that are correct for sequential programs are
%also correct for distributed programs. Our programming model shares this
%property with some existing approaches such as~\cite{ConcurrentHaskell}.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{R-Map}]
%{ host(r) = h' \quad i~\text{fresh} \\
%  r' = \text{Mapped}((h, i), h', r, p, \text{None})
%}
%{ (R[\texttt{map}(r, p)], E, S)^h \longrightarrow (R[r'], E, S)^h }
%
%\inferrule[\textsc{R-FMap}]
%{ host(r) = h' \quad i~\text{fresh} \\
%  r' = \text{FMapped}((h, i), h', r, p, \text{None})
%}
%{ (R[\texttt{flatMap}(r, p)], E, S)^h \longrightarrow (R[r'], E, S)^h }
%
%\inferrule[\textsc{R-Await}]
%{ S(\iota) = \text{Some}(v)
%}
%{ (R[\texttt{await}(\iota)], E, S)^h \longrightarrow (R[v], E, S)^h }
%
%\inferrule[\textsc{R-Res}]
%{ E = \text{Res}(\iota, v) \texttt{::} E' \quad S' = S + (\iota \mapsto v)
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E', S')^h }
%
%\inferrule[\textsc{R-ReqLocal}]
%{ E = \text{Req}(h', r, \iota'') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' \neq \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
%  loc(r') = \iota' \quad S(\iota') = \text{None} \\
%  E'' = \text{Req}(h, r', \iota') \texttt{::} E
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \rightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%  % \vspace{-3mm}
%  \caption{Deterministic reduction.}
%  \label{fig:opsem-determ}
%  % \vspace{-3mm}
%\end{figure*}
%
%\paragraph{Notation and conventions.}
%
%We write $S' = S + (\iota \mapsto v)$ to express the fact that $S'$ maps
%$\iota$ to $v$ and otherwise agrees with $S$. We write $S(\iota) =
%\text{Some}(v)$ to express the fact that $S$ maps $\iota$ to $v$. We write
%$S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$. Reduction
%is defined using reduction contexts~\cite{TAPL}. We omit the definition of
%reduction contexts, since they are completely standard.
%
%\paragraph{Configurations.}
%
%The reduction rules of the deterministic layer define transitions of \emph{host
%configurations} $(t, E, S)^h$ of host $h$ where $t$ is a term, $E$ is a message
%queue, and $S$ is a silo store. The reduction rules of the non-deterministic
%layer define transitions of sets $H$ of host configurations. The reduced host
%configurations are chosen non-deterministically in order to express concurrency
%between hosts.
%
%\paragraph{Fault handling.}
%
%In the interest of clarity we present the reduction rules in two steps. In the
%first step we explain simplified rules without fault handling semantics
%(Sections~\ref{sec:det-layer} and~\ref{sec:nondet-layer}). In the second step
%we explain how these simplified rules have to be refined in order to support
%the fault handling principles of our model (Section~\ref{sec:faults-opsem}).
%
%\subsubsection{Decentralized identification}
%
%A important property of our programming model is the fact that silos are
%uniquely identified using \emph{decentralized identifiers}. A decentralized
%identifier $\iota$ has two components: (a) the identifier of the host $h$ that
%created $\iota$, and (b) a name $i$ created fresh on $h$ (e.g., an integer
%value): $\iota = (h, i)$. Decentralized identifiers are important, since they
%reconcile two conflicting properties central to our model. The first property
%is building computation DAGs locally, without remote communication. This is
%possible using decentralized identifiers, since each host can generate new
%identifiers independently of other remote hosts. The second property is
%allowing SiloRefs to be freely copied between remote hosts. This is possible,
%since decentralized identifiers uniquely identify silos without the need for
%subsequent updates of their information; decentralized identifiers are
%immutable. This latter property is essential to enable computation DAGs that
%are \emph{immutable upon construction}. In our programming model, computation
%DAGs are created using the standard monadic operations of SiloRefs. In
%particular, the \texttt{flatMap} operation (monadic bind) in general requires
%that its argument spore captures SiloRefs that are subsequently copied to a
%remote host. Hence it is essential that SiloRefs and the decentralized
%identifiers they contain be freely copyable between remote hosts.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{R-Send}]
%{ host(r) = h' \quad h' \neq h \quad i~\text{fresh} \\
%  \iota = (h, i) \quad m = \text{Req}(h, r, \iota)
%}
%{ \{ (R[\texttt{send}(r)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\iota], E, S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req1}]
%{ E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mat}(\iota) \\
%  S(\iota) = \text{Some}(v) \quad m = \text{Res}(\iota', v)
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S)^h, (t, E'' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req2}]
%{ E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' = \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
%  S(\iota_s) = \text{Some}(v) \quad p(v) = v' \quad S' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota', v')
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S'')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S')^h, (t, E'' \cdot m, S'')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req3}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
%  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{None} \quad host(r') = h' \quad m = \text{Req}(h, r', \iota') \quad E''' = \text{Req}(h'', r', \iota'') \texttt{::} E''
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req4}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
%  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{Some}(v') \quad S'' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota'', v')
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h''} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E'', S'')^h, (t, E' \cdot m, S')^{h''} \} \cup H
%}
%
%\end{mathpar}
%  % \vspace{-3mm}
%  \caption{Nondeterministic reduction.}
%  \label{fig:opsem-nondeterm}
%  % \vspace{-3mm}
%\end{figure*}
%
%\subsubsection{Deterministic layer}
%\label{sec:det-layer}
%
%We first consider the reduction rules of the deterministic layer shown in
%Figure~\ref{fig:opsem-determ}. The reduction rules for \texttt{map}
%(\textsc{R-Map}) and \texttt{flatMap} (\textsc{R-FMap}) do not involve
%communication with other hosts. In each case, a new SiloRef $r'$ is created
%that is derived from SiloRef $r$. The execution of the actual operation
%(\texttt{map} or \texttt{flatMap}, respectively) is deferred, and an object
%representing this derivation is returned. In both cases, the new SiloRef $r'$
%refers to a silo created on host $h'$ by applying the spore value $p$ to the
%value of silo $r$. The first component of the Mapped and FMapped objects, $(h,
%i)$, is a fresh \emph{location} created by host $h$ to uniquely identify the
%result silo.
%
%Most reduction rules are enabled when the current redex is an \texttt{await}
%term. The reduction of a term $\texttt{await}(\iota)$ only continues when store
%$S$ maps location $\iota$ to value $v$. In all other cases, the current host
%removes the next message from its message queue $E$. As shown in
%Figure~\ref{fig:elems-opsem} there are two types of messages: requests (Req)
%and responses (Res). A response $\text{Res}(\iota, v)$ tells its receiver that
%the silo at location $\iota$ has value $v$. A request $\text{Req}(h, r, \iota)$
%is sent on behalf of host $h$ to request the value of silo $r$ at location
%$\iota$. The reception of a response $\text{Res}(\iota, v)$ is handled by
%adding a mapping $(\iota \mapsto v)$ to the store (rule \textsc{R-Res}). The
%reception of a request $\text{Req}(h', r, \iota'')$ is handled locally if
%materialization of the requested silo $r$ is deferred and the parent silo $r'$
%in $r$'s lineage has not been materialized either. In this case, the host sends
%a request to materialize $r'$ to itself.
%
%
%
%\subsubsection{Nondeterministic layer}
%\label{sec:nondet-layer}
%
%All reduction rules in the nondeterministic layer, shown in
%Figure~\ref{fig:opsem-nondeterm}, involve communication between two hosts.
%
%Reducing a term $\texttt{send}(r)$ appends a request $\text{Req}(h, r, \iota)$
%to the message queue of host $h'$ of the requested silo $r$. In this case, host
%$h$ creates a unique location $\iota = (h, i)$ to identify the silo
%subsequently. Rules \textsc{R-Req1}, \textsc{R-Req2}, and \textsc{R-Req3}
%define the handling of request messages that cannot be handled locally. If the
%request can be serviced immediately (\textsc{R-Req1}), a response with the
%value $v$ of the requested silo $r$ is appended to the message queue of the
%requesting host $h'$. Rules \textsc{R-Req2} and \textsc{R-Reg3} handle cases
%where the requested silo is not already available in materialized form.
%
%% Failures may be detected whenever a message is sent to a non-local host. Note that this does not mean that message sends must be synchronous. Instead, our implementation interprets a failure to establish a network connection with a remote host as a failure of the remote host and thus a failure of all silos that it hosts.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{RF-Send}]
%{ host(r) = h' \quad h' \neq h \quad \text{failed}(h') \\
%  \quad i~\text{fresh} \quad \iota = (h, i) \quad S'' = S + (\iota \mapsto \bot)
%}
%{ \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \rightarrow \{ (R[\iota], E, S'')^h \} \cup H
%}
%
%\inferrule[\textsc{RF-Req4}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
%  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
%}
%
%\inferrule[\textsc{RF-Req5}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
%  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
%  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\inferrule[\textsc{RF-ReqF}]
%{ E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%  \vspace{-3mm}
%  \caption{Fault handling.}
%  \label{fig:opsem-faults}
%  \vspace{-3mm}
%\end{figure*}
%
%% \vspace{-2.25mm}
%\subsection{Fault handling}
%\label{sec:faults-opsem}
%% \vspace{-1mm}
%The key principles of the fault handling mechanism are:
%% \vspace{-1mm}
%\begin{itemize}
%\item Whenever a message is sent to a non-local host $h$, it is checked whether
%  $h$ is alive; if it is not, any silos located on $h$ are declared to have
%  failed.
%\item Whenever the value of a silo $r$ cannot be obtained due to another failed
%  silo, $r$ is declared to have failed.
%\item Whenever the failure of a silo $r$ is detected, the nearest predecessor
%  $r'$ in $r$'s lineage that is not located on the same host is determined. If
%  $r'$ has a fault handler $f$ registered, the execution of $f$ is requested.
%  Otherwise, $r'$ is declared to have failed.
%\end{itemize}
%
%% A host either (a) discovers itself that a remote silo has failed (e.g., because it could not establish a network connection to the remote host), or (b) is notified that a remote silo has failed by a healthy host involved in its materialization.
%
%These principles are embodied in the reduction as follows. First, we use the
%predicate $\text{failed}(h)$ as a way to check whether it is possible to
%communicate with host $h$ (e.g., an implementation could check whether it is
%possible to establish a socket connection). Second, failures of hosts are
%handled whenever communication is attempted: whenever a host $h$ intends to
%send a message to a host $h'$ where $h' \neq h$, it is checked whether
%$\text{failed}(h')$. If it is the case that $\text{failed}(h')$, either the
%corresponding location (silo or future) is declared as failed (and fault
%handling deferred), or a suitable fault handler is located and a recovery step
%is attempted. In the following we explain the extended reduction rules shown in
%Figure~\ref{fig:opsem-faults}.
%
%In rule \textsc{RF-Send}, the host of the requested silo $r$ is detected to
%have failed. However, the parent silos of $r$ are all located on the same
%(failed) host. Thus, in this case silo $r$ is simply declared as failed, and
%fault handling is delegated to other parts of the computation DAG that require
%the value of $r$ (if any). Since \texttt{send} is essentially a ``sink'' of a
%DAG, no suitable fault handler can be located at this point.
%
%This is different in rule \textsc{RF-Req4}. Here, host $h$ processes a message
%requesting silo $r$ which is the result of a \texttt{flatMap} call.
%Materializing $r$ requires obtaining the value of silo $r'$, the result of
%applying spore $p$ to the value $v$ of the materialized parent $r''$.
%Importantly, if the host of $r'$ is failed, it means the computation of the DAG
%defined by spore $p$ did not result in a silo on an available host.
%Consequently, if the \texttt{flatMap} call deriving $r$ specified a fault
%handler $p_f$, $p_f$ is applied to $v$ in order to recover from the failure.
%If the host of the resulting silo $r_f$ is not failed, the original request for
%$r$ is ``modified'' to request $r_f$ instead. This is done by removing message
%$\text{Req}(h'', r, \iota'')$ from the message queue and prepending message
%$\text{Req}(h'', r_f, \iota'')$. Moreover, host $h$ sends a message to itself,
%requesting the value of silo $r_f$.
%
%Rule \textsc{RF-Req5} shows fault recovery in the case where the lineage of a
%requested silo does not specify a fault handler itself. In this case, host $h$
%creates two fresh locations $\iota_p, \iota_a$. $\iota_p$ is supposed to be
%eventually mapped to the result value of executing the fault handler of parent
%silo $r''$. Host $h$ requests this value from itself using a special message
%$\text{ReqF}(h, r'', \iota_p)$. Finally, the original request for silo $r$ in
%message queue $E$ is replaced with a request for silo $r_a$. The silo $r_a$ is
%created analogous to $r$, but using silo $\text{Mat}(\iota_p)$ as parent
%(eventually, location $\iota_p$ is mapped to the result of applying the
%parent's fault handler). As demonstrated by rule \textsc{RF-ReqF}, ReqF
%messages used to request the application of the fault handler are handled in a
%way that is completely analogous to the way regular Req messages are handled,
%except that fault handlers $p_f$ are applied as opposed to regular spores $p$.
