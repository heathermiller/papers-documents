%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                  & \mbox{{\it{terms:}}} \\
\gap \:\:\:\:  x                                                       & \mbox{variable} \\
\gap ~|~  (x: T) \Rightarrow t                                         & \mbox{abstraction} \\
\gap ~|~  t~t                                                          & \mbox{application} \\
\gap ~|~  \{ \seq{l = t} \}                                            & \mbox{record construction} \\
\gap ~|~  t.l                                                          & \mbox{selection} \\
\gap ~|~  \unit                                                        & \mbox{unit} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{populate}(t)                                         & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t)                                           & \mbox{map} \\
\gap ~|~  \texttt{flatMap}(t, t)                                       & \mbox{flatMap} \\
\gap ~|~  \texttt{send}(t, t)                                          & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                            & \mbox{await future} \\   % await :: Fut a -> a
\gap ~|~  \texttt{assign}(t, t)                                        & \mbox{assignment} \\
\gap ~|~  \iota                                                        & \mbox{decentralized identifier} \\
\gap ~|~  r                                                            & \mbox{silo reference} \\
\gap ~|~  h                                                            & \mbox{host} \\
                                                                       & \\
v ::=                                                                  & \mbox{{\it{values:}}} \\
\gap \:\:\:\: (x: T) \Rightarrow t                                     & \mbox{abstraction value} \\
\gap ~|~  \{ \seq{l = v} \}                                            & \mbox{record value} \\
\gap ~|~  \unit                                                        & \mbox{unit} \\
\gap ~|~  p                                                            & \mbox{spore value} \\
\gap ~|~  \iota                                                        & \mbox{decentralized identifier} \\
\gap ~|~  r                                                            & \mbox{silo reference} \\
\gap ~|~  h                                                            & \mbox{host} \\
                                                                       & \\
p ::= \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}      & \\
& \\
l ::=                                                  & \mbox{{\it{lineage}}}                \\
\gap \:\:\:\: \text{Mat}(\iota)                        & \mbox{materialized}                  \\
\gap ~|~  \text{Mapped}(\iota, l, p)                   & \mbox{lineage with \texttt{map}}     \\
\gap ~|~  \text{FMapped}(\iota, l, p)                  & \mbox{lineage with \texttt{flatMap}} \\
                                                       & \\
r ::= {\Ref l h} \quad \text{where}~h \in \mathcal{H}  & \mbox{silo reference} \\
                                                       & \\
\iota  ::= (h,i) \quad \text{where}~h \in \mathcal{H}~\text{and}~i \in \mathbb{N}   & \mbox{decentralized identifier} \\
& \\
T ::=                                                                  & \mbox{{\it{types:}}} \\
\gap \:\:\:\: T \Rightarrow T                                          & \mbox{abstraction type} \\
\gap ~|~  \{ \seq{l : T} \}                                            & \mbox{record type} \\
\gap ~|~  \texttt{Unit}                                                & \mbox{unit type} \\
\gap ~|~  \mathcal{S}                                                  & \mbox{} \\
\gap ~|~  \texttt{Future}[T]                                           & \mbox{future type} \\
\gap ~|~  \texttt{SiloRef}[T]                                          & \mbox{silo reference type} \\
\gap ~|~  \texttt{Host}                                                & \mbox{host type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}               & \mbox{abstract spore type} \\
\ea$
\caption{Abstract syntax of core language.}\label{fig:syntax}
\end{figure}

We formalize our programming model in the context of a typed lambda
calculus with records. Figure~\ref{fig:syntax} shows the abstract
syntax of our core language. Besides standard terms, the language
includes terms related to (a) spores, (b) silos, and (c) futures. The
\verb|spore| term creates a new spore. It contains a list of variable
definitions, the spore header, and a closure which may only refer to
its parameter and variables in the spore header. The \verb|populate|
term initializes a new silo on a given host. The \verb|map| and
\verb|flatMap| terms create lineages of silo transformations
represented as silo references.  The \verb|send| term forces the
materialization of the silo corresponding to its first argument silo
reference; the second argument silo reference indicates which silo
should be completed with the materialization result. This flexibility
is needed for implementing \verb|flatMap| (see below); in user
programs, the two arguments passed to \verb|send| are always the
same. The \verb|send| expression returns a future which is
asynchronously completed with the silo's value. The \verb|await| term
waits for the completion of its argument future and returns the
future's value. Decentralized identifiers $\iota$ are used to refer to
futures and to identify silos via their lineages (each element in a
lineage carries a decentralized identifier).

Values in our language are as expected: besides abstractions and
record values they include spore values, decentralized identifiers,
and silo references. Decentralized identifiers and silo references are
not part of the ``surface syntax'' of our language; they are only
introduced by evaluation (see Section~\ref{sec:opsem}). Silo reference
values have the form ${\Ref l h}$ where $l$ is a lineage and $h$ is a
host. Lineages are values of a simple datatype with constructors {\em
  Mat}, {\em Mapped}, and {\em FMapped}. The constructors include all
information required for {\em materializing} a silo with the result of
applying the described transformations. We defer a detailed
explanation of the transformations described by a lineage to the
following Section~\ref{sec:opsem}.

In addition to standard function and record types, the language has
types for spores, futures, silo references, and hosts. A spore type $T
\Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}$ includes the
types $\seq{T}$ of the variables declared in the header of the spore.

\subsection{Operational Semantics}\label{sec:opsem}

In the following we present a small-step operational semantics of the
introduced core language. The semantics is clearly stratified into a
local (sequential) layer and a distributed (concurrent)
layer. Importantly, this means our programming model can benefit from
existing reasoning techniques for sequential programs. Program
transformations that are correct for sequential programs are also
correct for distributed programs. Our programming model shares this
property with some existing approaches~\cite{ConcurrentHaskell}.

\begin{figure}
\centering
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{populate}(E)                                                                            & \mbox{populate} \\
\gap ~|~  \texttt{map}(E, t)                                                                              & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E)                                                                              & \mbox{map (fun)} \\
\gap ~|~  \texttt{flatMap}(E, t)                                                                          & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E)                                                                          & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{send}(E, t)                                                                             & \mbox{send (fst)} \\
\gap ~|~  \texttt{send}(v, E)                                                                             & \mbox{send (snd)} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\gap ~|~  \texttt{assign}(E, t)                                                                           & \mbox{assign (fst)} \\
\gap ~|~  \texttt{assign}(v, E)                                                                           & \mbox{assign (snd)} \\
\ea$
\caption{Evaluation contexts.}\label{fig:eval-ctx}
\end{figure}

The semantics is based on two reduction relations for (a) local
reduction of terms and (b) distributed, non-deterministic reduction of
sets of hosts.  The reduction relations use the definition of
evaluation contexts shown in Figure~\ref{fig:eval-ctx}. Evaluation
contexts capture the notion of the ``next subterm to be evaluated.''
Following a standard approach~\cite{TAPL}, we write $E[t]$ for the
term obtained by replacing the hole in evaluation context $E$ with
term $t$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Local (sequential) reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\centering
\begin{mathpar}

\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v]~|~\sigma
  \rightarrow^h
  E[[x \mapsto v]t]~|~\sigma
}

\inferrule[\textsc{R-ProjRcd}] {} {
  E[\{\seq{l_i = v_i^{i \in 1..n}}\}.l_j]~|~\sigma
  \rightarrow^h
  E[v_j]~|~\sigma
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v]~|~\sigma
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v]t]~|~\sigma
}

\inferrule[\textsc{R-Await}] {
  \sigma(\iota) = v
} {
  E[\texttt{await}(\iota)]~|~\sigma
  \rightarrow^h
  E[v]~|~\sigma
}

\inferrule[\textsc{R-Assign}] {
  \sigma' = [\iota \mapsto v]\sigma
} {
  E[\texttt{assign}(\iota, v)]~|~\sigma
  \rightarrow^h
  E[\texttt{unit}]~|~\sigma'
}

\inferrule[\textsc{R-Populate}] {
  l = {\Mat {(h, i)}} \quad i~\text{fresh}
} {
  E[\texttt{populate}(h')]~|~\sigma
  \rightarrow^h
  E[{\Ref l {h'}}]~|~\sigma
}

\inferrule[\textsc{R-Map}] {
  r = {\Ref l {h'}} \quad l' = {\Mapped {(h, i)} l p} \quad i~\text{fresh}
} {
  E[\texttt{map}(r, p)]~|~\sigma
  \rightarrow^h
  E[{\Ref {l'} {h'}}]~|~\sigma
}

\inferrule[\textsc{R-FMap}] {
  r = {\Ref l {h'}} \quad l' = {\FMapped {(h, i)} l p} \quad i~\text{fresh}
} {
  E[\texttt{flatMap}(r, p)]~|~\sigma
  \rightarrow^h
  E[{\Ref {l'} {h'}}]~|~\sigma
}

\end{mathpar}
\caption{Local reduction.}\label{fig:seq-reduction}
\end{figure}

Figure~\ref{fig:seq-reduction} shows the rules for sequential
reduction. The sequential reduction relation has the form
$E[t]~|~\sigma \rightarrow^h E[t']~|~\sigma'$ with stores $\sigma$ and
$\sigma'$. Stores are required for the dynamic allocation of silos. A
store $\sigma$ is a partial function mapping decentralized identifiers
$\iota$ to values $v$.  The annotation with host $h$ is used for
creating decentralized identifiers $\iota = (h, i)$ for lineages.
Rules \textsc{R-AppAbs} and \textsc{R-ProjRcd} are completely
standard.  Analogous to rule \textsc{R-AppAbs}, rule
\textsc{R-AppSpore} describes the application of a spore value to an
argument value. Rule \textsc{R-Await} reduces $\texttt{await}(\iota)$
to $v$ if future $\iota$ is already completed with $v$ in $\sigma$.

Rules \textsc{R-Populate}, \textsc{R-Map}, and \textsc{R-FMap}
describe the creation of lineages.  Rules \textsc{R-Map} and
\textsc{R-FMap} create lineages using the constructors {\em Mapped}
and {\em FMapped}, respectively. The new lineage has a fresh
identifier $(h, i)$ which uniquely identifies the corresponding
(logical) silo. In each case, the spore value $p$ is stored in the new
lineage; this enables a materialization of the silo identified by $(h,
i)$ using parent lineage $l$ and spore $p$.

\comment{
Rules \textsc{R-Persist} and
\textsc{R-Unpersist} create silo reference values using the {\em
  Persist} constructor. {\em Persist} contains a function enabling
host $h$ to persist ($\cdot \cup \cdot$) or unpersist ($\cdot
\setminus \cdot$) silo $r$, respectively.}

\begin{figure}
\centering
$\ba[t]{l@{\hspace{2mm}}l}
m      ::= & \mbox{{\it{messages:}}} \\
\gap \:\:\:\: {\Req h r \iota}      & \mbox{request} \\
\gap ~|~      {\Res \iota v}        & \mbox{response} \\
 & \\
Q      ::=                          & \mbox{{\it{message queues:}}} \\
\gap \:\:\:\: \epsilon  & \mbox{empty queue} \\
\gap ~|~    m \cdot Q      & \mbox{non-empty queue} \\
\ea$
\caption{Message queues.}\label{fig:queues}
\end{figure}

\comment{
The deterministic reduction relation has the form $(E[t], \mu, Q, S)^h
\longrightarrow (E[t'], \mu', Q', S')^h$ where $Q$ is a {\em message
  queue} and $S$ is a {\em silo store}. Figure~\ref{fig:queues} shows
the definition of message queues. A message queue $Q$ may contain
three kinds of messages. A message of the form ${\Req h r \omega}$
requests the value of silo $r$ to be sent to host $h$ for
materialization of identifier $\omega$. A message of the form ${\Res
  \omega v P}$ represents the corresponding response, containing the
identifier $\omega$ to be materialized, value $v$, and persist set $P$
(the set of hosts which have persisted the silo identified by
$\omega$). A message of the form ${\ReqF \iota \omega}$ requests
future $\iota$ to be completed with the value of silo $\omega$.  A
{\em silo store} $S$ is a partial function mapping identifiers
$\omega$ to values of the form $(\Val{v}, P)$ or $(\Fwd{r}, P)$ where
$P$ is a set of hosts which have persisted the silo (the persist set).
The former represents a materialized silo with value $v$. The latter
represents a {\em proxy} forwarding to the silo specified by lineage
$r$.}

The distributed reduction rules use helper functions $host$, $id$, and
$parent$, which are defined as follows:

\begin{defn}[Host]
  The host of a silo reference.

  $host({\Ref l h}) := h$
\end{defn}

\begin{defn}[Lineage identifier]
  The identifier of a lineage.

  $id(l) := \left\{\ba{ll}
    \iota  & \text{if } l = Mat(\iota) \\
    \iota  & \text{if } l = Mapped(\iota, \_, \_) \\
    \iota  & \text{if } l = FMapped(\iota, \_, \_)
  \ea\right.$
\end{defn}

\begin{defn}[Silo reference parent]
  The parent of a silo reference.

  $parent(r) := \left\{\ba{ll}
    \None     & \text{if } r = Mat(\_) \\
    \Some{r'} & \text{if } r = Mapped(\_, r', \_) \\
    \Some{r'} & \text{if } r = FMapped(\_, r', \_) \\
    \Some{r'} & \text{if } r = Persist(\_, r', \_)
  \ea\right.$
\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Distributed reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{R-Local}] {
  t~|~\sigma \rightarrow^h t'~|~\sigma'
} {
  \{ (t, \sigma, Q)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (t', \sigma', Q)^h \} \cup H ~|~ M
}

\inferrule[\textsc{R-Send}] {
  r  = {\Ref l {h'}}      \quad
  r' = {\Ref {l'} {h''}}  \quad
  m  = {\Req h r {id(l')}} \quad
  M' = M \cup \{ h' \leftarrow m \}
} {
  \{ (E[\texttt{send}(r, r')], \sigma, Q)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[id(l)], \sigma, Q)^h \} \cup H ~|~ M'
}

\inferrule[\textsc{R-Receive}] {
  M = M' \cup \{ h \leftarrow m \}
} {
  \{ (t, \sigma, Q)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (t, \sigma, Q \cdot m)^h \} \cup H ~|~ M'
}

\inferrule[\textsc{R-Process}] {
  process(h, m, \sigma) = (t, M')
} {
  \{ (E[\texttt{await}(\iota)], \sigma, m \cdot Q)^h \} \cup H ~|~ M
  \twoheadrightarrow
  \{ (E[t~;~\texttt{await}(\iota)], \sigma, Q)^h \} \cup H ~|~ M \cup M'
}

\end{mathpar}
\caption{Distributed reduction.}\label{fig:dist-rules}
\end{figure}

\note{rewrite}

Figure~\ref{fig:dist-rules} shows the non-deterministic reduction
rules. The non-deterministic reduction relation has the form $H
\twoheadrightarrow H'$ where $H$ and $H'$ are sets of hosts of the
form $(t, \mu, Q, S)^h$. Rule \textsc{R-Schedule} reduces a host
chosen non-deterministically from the set of hosts. Rule
\textsc{R-Spawn} creates a new host whose initial term is given by the
application of the provided spore to the unit value $\{\}$. The new
host has an empty store, an empty queue, and an empty silo store.
Rule \textsc{R-Populate} materializes a silo with a fresh identifier
$\omega$ on host $h'$ using value $v$. Rules \textsc{R-Req1-3} and
\textsc{R-Send} are analogous to the corresponding deterministic
reduction rules. The main difference is that messages are exchanged
between different hosts in the case of non-deterministic reduction.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Message processing.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{mathpar}

\inferrule[\textsc{Proc-Req}] {
  r = {\Ref l h} \quad
  \sigma(id(l)) = v \quad
  M = \{ h' \leftarrow {\Res \iota v} \}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\epsilon, M)
}

\inferrule[\textsc{Proc-ReqMat}] {
  r = {\Ref l h} \quad
  l = {\Mat {\iota'}} \quad
  t = \texttt{assign}(\iota', \texttt{unit})
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \{ h \leftarrow {\Req {h'} r \iota} \})
}

\inferrule[\textsc{Proc-ReqMap}] {
  r = {\Ref l h} \quad
  l = {\Mapped {\iota'} {l'} p} \quad
  \sigma(id(l'))  = v           \quad
  t = \texttt{assign}(\iota', p~v)
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \{ h \leftarrow {\Req {h'} r \iota} \})
}

\inferrule[\textsc{Proc-ReqFMap}] {
  r = {\Ref l h} \quad
  l = {\FMapped {\iota'} {l'} p} \quad
  \sigma(id(l')) = v \quad
  t = \texttt{send}(p~v, r)
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (t, \{ h \leftarrow {\Req {h'} r \iota} \})
}

\inferrule[\textsc{Proc-ReqParent}] {
  r = {\Ref l h} \quad
  l' = parent(l) \quad
  id(l') \notin dom(\sigma) \\
  M = \{ h \leftarrow {\Req h {\Ref {l'} h} {id(l')}}, h \leftarrow {\Req {h'} r \iota} \}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\epsilon, M)
}

\inferrule[\textsc{Proc-Res}] {
  t = \texttt{assign}(\iota, v)
} {
  process(h, {\Res \iota v}, \sigma) = (t, \emptyset)
}

\end{mathpar}
\caption{Message processing.}\label{fig:process}
\end{figure}

\begin{defn}[Message processing]
  The function $process \in \mathcal{H} \times m \times S  \rightharpoonup t \times \mathcal{P}(\mathcal{H} \times m)$ handles the processing of a message resulting in a term to be evaluated and a set of sent messages; here, $S = \mathcal{H} \times \mathbb{N} \rightharpoonup v$ is the type of a store. $process$ is defined in Fig.~\ref{fig:process}.
\end{defn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma \vdash x : T
}

\inferrule[\textsc{T-Ident}] {
  \Sigma(\iota) = T
} {
  \Gamma ; \Sigma \vdash \iota : \texttt{Future}[T]
}

\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma \vdash t : T'
} {
  \Gamma ; \Sigma \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T' \quad
  \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

\inferrule[\textsc{T-Record}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}
} {
  \Gamma ; \Sigma \vdash \{ \seq{l = t} \} : \{ \seq{l : T} \}
}

\inferrule[\textsc{T-Select}] {
  \Gamma ; \Sigma \vdash t : \{ \seq{l : T} \}
} {
  \Gamma ; \Sigma \vdash t.l_i : T_i
}

\inferrule[\textsc{T-Unit}] {
} {
  \Gamma ; \Sigma \vdash \unit : \texttt{Unit}
}

\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}     \quad
  \seq{x : T}, x : T ; \emptyset \vdash t : T' \quad
  \forall S \in \seq{T} , T'.~serializable(S)
} {
  \Gamma ; \Sigma \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

\inferrule[\textsc{T-AppSpore}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\} \quad
  \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma \vdash t : \texttt{Host}
} {
  \Gamma ; \Sigma \vdash \texttt{populate}(t) : \texttt{SiloRef}[\texttt{Unit}]
}

\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{send}(t, t') : \texttt{Future}[T]
}

\inferrule[\textsc{T-SiloRef}] {
  \Sigma(id(l)) = T \quad
  \Sigma \vdash {\Ref l h}
} {
  \Gamma ; \Sigma \vdash {\Ref l h} : \texttt{SiloRef}[T]
}

\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{await}(t) : T
}

\inferrule[\textsc{T-Assign}] {
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T] \quad
  \Gamma ; \Sigma \vdash t' : T
} {
  \Gamma ; \Sigma \vdash \texttt{assign}(t, t') : \texttt{Unit}
}
\end{mathpar}
\caption{Type assignment.}\label{fig:type-rules}
\end{figure}

\subsection{Type Assignment}

Type assignment is based on a judgment of the form $\Gamma ; \Sigma ;
\Delta \vdash t : T$ which assigns term $t$ type $T$. $\Gamma$ is a
standard type environment; $\Sigma$ is a standard store typing;
$\Delta$ is a {\em silo store typing} which is new. $\Delta$ maps
identifiers $\omega$ to types, thereby providing a typing for silo
stores $S$. Figure~\ref{fig:type-rules} shows the rules for type
assignment. Rules \textsc{T-Var}, \textsc{T-Loc}, \textsc{T-Abs},
\textsc{T-App}, \textsc{T-Record}, and \textsc{T-Select} are unchanged
compared to a standard typed lambda calculus with records~\cite{TAPL}.

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{S-Record}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(\{ \seq{l : T} \})
}

\inferrule[\textsc{S-Spore}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
}

\inferrule[\textsc{S-SiloRef}] {} {
  serializable(\texttt{SiloRef}[T])
}
\end{mathpar}
\caption{Serializable types.}\label{fig:ser-types}
\end{figure}

Rule \textsc{T-Spore} assigns a type to spore literals. Importantly,
the body of the spore's closure, $t$, must be well-typed in a type
environment containing only the closure parameter $x$ and the
variables $\seq{x}$ in the spore's header, as well as an empty store
typing. Furthermore, the types of captured variables must be
serializable. The predicate $serializable$ is defined in
Figure~\ref{fig:ser-types}. These constraints ensure that spore values
are always independent of the environment and store of the creating
host. This independence is expressed by the following theorem:

\begin{thm}
\emph{(Serializable Values)}\label{lem:ser-values}
If $\Gamma ; \Sigma ; \Delta \vdash v : T$ and $serializable(T)$ then
$\emptyset ; \emptyset ; \Delta \vdash v : T$.
\end{thm}
\begin{proof}
By induction on the derivation of $\Gamma ; \Sigma ; \Delta \vdash v :
T$. See Appendix~\ref{app:ser-values}.
\end{proof}

Rule \textsc{T-AppSpore} is analogous to rule \textsc{T-App}. Rule
\textsc{T-Spawn} requires argument $t$ to be a spore with domain type
unit; the result has type $\texttt{Host}$.  Rule \textsc{T-Populate}
leverages the $serializable$ predicate to ensure the value of the silo
to be populated is independent of its source context. Rules
\textsc{T-Map}, \textsc{T-FMap}, and \textsc{T-Persist} are
straightforward; note that \verb|map| and \verb|flatMap| are
polymorphic in the types of the captured variables of their spore
argument types. Rules \textsc{T-Send} and \textsc{T-Await} are
entirely unsurprising. Rule \textsc{T-SiloRef} is the only rule that
uses the silo store typing $\Delta$. Analogous to rule \textsc{T-Loc},
the type of silo $id(r)$ is looked up in $\Delta$. Furthermore,
\textsc{T-SiloRef} requires $r$ to be well-formed in $\Delta$, written
$\Delta \vdash r$ (see below).

\subsection{Well-Formed Configurations}

Figure~\ref{fig:well-formed} shows the rules for well-formed
configurations. These rules are essential for establishing subject
reduction (see Section~\ref{sec:subject-reduction}). Rules
\textsc{WF-Store1} and \textsc{WF-Store2} are standard.  Rules
\textsc{WF-Ref1-2} require the types given by the silo store typing
$\Delta$ to be consistent with the corresponding type of spore
$p$. Rule \textsc{WF-Ref3} requires the type of silo $\omega$ to be
equal to the type of its parent silo $id(r)$ in silo store typing
$\Delta$. Rule \textsc{WF-Ref4} requires $\Delta$ to be defined for
the identifier of a materialized silo. Finally, rules
\textsc{WF-Ref1-3} require parent silo references to be well-formed.
Rules \textsc{WF-SiloStore1-3} require a well-formed silo store to be
consistent with silo store typing $\Delta$. Rules \textsc{WF-Q1-4}
specify well-formedness of message queues in $\Delta$ and $\Sigma$.
Rules \textsc{WF-HostConfig}, \textsc{WF-Host1}, and \textsc{WF-Host2}
combine the previous rules in the expected way.

\begin{figure}
\begin{mathpar}
\inferrule[\textsc{WF-Store1}] {} {
  \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Store2}] {
  \Sigma \vdash \mu
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto v]\mu
}

\inferrule[\textsc{WF-Ref1}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma ; \Delta \vdash p : T' \Rightarrow T~\{\ldots\} \quad
  \Delta \vdash r
} {
  \Delta \vdash \text{Mapped}(\omega, r, p)
}

\inferrule[\textsc{WF-Ref2}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma ; \Delta \vdash p : T' \Rightarrow \texttt{SiloRef}[T]~\{\ldots\} \quad
  \Delta \vdash r
} {
  \Delta \vdash \text{FMapped}(\omega, r, p)
}

\inferrule[\textsc{WF-Ref3}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T   \quad
  \Delta \vdash r
} {
  \Delta \vdash {\Per \omega r {\star}}
}

\inferrule[\textsc{WF-Ref4}] {
  \omega \in dom(\Delta)
} {
  \Delta \vdash {\text{Mat}(\omega)}
}

\inferrule[\textsc{WF-SiloStore1}] {} {
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-SiloStore2}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset ; \Delta \vdash v : T  \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto ({\Val v}, P)]S
}

\inferrule[\textsc{WF-SiloStore3}] {
  \Delta(id(r)) = \Delta(\omega)      \quad
  \Delta \vdash r                     \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto ({\Fwd r}, P)]S
}

\inferrule[\textsc{WF-Q1}] {} {
  \Delta ; \Sigma \vdash \epsilon
}

\inferrule[\textsc{WF-Q2}] {
  \Delta(\omega) = T                  \quad
  \Sigma(\iota)  = \texttt{Future}[T] \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\ReqF \iota \omega} :: Q
}

\inferrule[\textsc{WF-Q3}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset ; \Delta \vdash v : T  \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Res \omega v P} :: Q
}

\inferrule[\textsc{WF-Q4}] {
  \Delta(id(r)) = \Delta(\omega) \quad
  \Delta \vdash r \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Req h r \omega} :: Q
}

\inferrule[\textsc{WF-HostConfig}] {
  \Sigma \vdash \mu              \quad
  \Delta \vdash S                \quad
  \Delta ; \Sigma \vdash Q       \quad
  \Gamma ; \Sigma ; \Delta \vdash t : T
} {
  \Delta ; \Sigma \vdash (t, \mu, Q, S)^h
}

\inferrule[\textsc{WF-Host1}] {} { 
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-Host2}] {
  \exists \Sigma.~\Delta ; \Sigma \vdash (t, \mu, Q, S)^h  \quad
  \Delta \vdash H
} {
  \Delta \vdash \{ (t, \mu, Q, S)^h \} \cup H
}
\end{mathpar}
\caption{Well-formedness.}\label{fig:well-formed}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Subject reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Subject Reduction}\label{sec:subject-reduction}

This section establishes a subject reduction theorem for the presented
core language. The complete proof is provided in the appendix; here,
we restrict ourselves to summarizing the main results.

\begin{lemma}
\emph{(Substitution)}\label{lem:subst}
If $\Gamma , x : T' ; \Sigma ; \Delta \vdash t : T$ and $\Gamma ; \Sigma ; \Delta \vdash v : T'$ then $\Gamma ; \Sigma ; \Delta \vdash [x \mapsto v]t : T$.
\end{lemma}
\begin{proof}
By induction on the derivation of $\Gamma , x : T' ; \Sigma ; \Delta \vdash t : T$.
\end{proof}

\begin{lemma}
\emph{(Queue Concatenation)}\label{lem:queue-concat}
If $\Delta ; \Sigma \vdash Q$ and $\Delta ; \Sigma \vdash Q'$ then $\Delta ; \Sigma \vdash Q ::: Q'$.
\end{lemma}
\begin{proof}
By induction on the length of $Q$. See Appendix~\ref{app:queue-concat}.
\end{proof}


\begin{thm}
\emph{(Subject Reduction)}\label{th:subject-reduction}

\begin{enumerate}

\item If $\Gamma ; \Sigma ; \Delta \vdash t : T$, $\Sigma \vdash \mu$, and $t~|~\mu \rightarrow^h t'~|~\mu'$ then $\Gamma ; \Sigma' ; \Delta' \vdash t' : T$, and $\Sigma' \vdash \mu'$ for some $\Sigma' \supseteq \Sigma$ and $\Delta' \supseteq \Delta$.

\item If $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$ and $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$ then $\Delta' ; \Sigma' \vdash (t', \mu', Q', S')^h$ for some $\Delta' \supseteq \Delta$ and $\Sigma' \supseteq \Sigma$.

\item If $\Delta \vdash H$ and $H \twoheadrightarrow H'$ then $\Delta' \vdash H'$ for some $\Delta' \supseteq \Delta$.

\end{enumerate}

\end{thm}
\begin{proof}
  Part 1: by induction on the derivation of $t~|~\mu \rightarrow^h
  t'~|~\mu'$. Part 2: by induction on the derivation of $(t, \mu, Q,
  S)^h \longrightarrow (t', \mu', Q', S')^h$. Part 3: by induction on
  the derivation of $H \twoheadrightarrow H'$. See
  Appendix~\ref{app:subject-reduction} for the complete proof.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% OLD
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{figure}[t!]
%  \centering
%
%  $\ba[t]{l@{\hspace{2mm}}l}
%t ::=     x                                 & \mbox{variable}
%\\
%\gap ~|~  (x: T) \Rightarrow t              & \mbox{abstraction}
%\\
%\gap ~|~  t~t                               & \mbox{application}
%\\
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t  & \mbox{let binding}
%\\
%\gap ~|~  \{ \seq{l = t} \}                 & \mbox{record construction}
%\\
%\gap ~|~  t.l                               & \mbox{selection}
%\\
%\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}  & \mbox{spore}
%\\
%\gap ~|~  \texttt{map}(r, t[, t])           & \mbox{map}
%\\
%\gap ~|~  \texttt{flatMap}(r, t[, t])       & \mbox{flatMap}
%\\
%\gap ~|~  \texttt{send}(r)                  & \mbox{send}
%\\
%\gap ~|~  \texttt{await}(\iota)             & \mbox{await future}
%\\
%\gap ~|~  r                                 & \mbox{SiloRef}
%\\
%\gap ~|~  \iota                             & \mbox{future}
%\\
% & \\
%v ::=     (x: T) \Rightarrow t              & \mbox{abstraction}
%\\
%\gap ~|~  \{ \seq{l = v} \}                 & \mbox{record value}
%\\
%\gap ~|~  p                                 & \mbox{spore value}
%\\
%\gap ~|~  r                                 & \mbox{SiloRef}
%\\
%\gap ~|~  \iota                             & \mbox{future}
%\\
% & \\
%p ::=     \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}  & \mbox{spore value}
%\\
% & \\
%T ::=     T \Rightarrow T                   & \mbox{function type} \\
%\gap ~|~  \{ \seq{l : T} \}                 & \mbox{record type}   \\
%\gap ~|~  \mathcal{S}                       & \mbox{}
%\\
%\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type}
%\\
%\gap ~|~  T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}   & \mbox{abstract spore type}
%\\
%\ea$
%
%  % \vspace{1mm}
%  \caption{Core language syntax.}
%  \label{fig:syntax}
%  % \vspace{1mm}
%\end{figure}
%
%We formalize our programming model in the context of a standard, typed lambda
%calculus with records. Figure~\ref{fig:syntax} shows the syntax of our core
%language. Terms are standard except for the \texttt{spore}, \texttt{map},
%\texttt{flatMap}, \texttt{send}, and \texttt{await} terms. A \texttt{spore}
%term creates a new spore. It contains a list of variable definitions (the spore
%header) and the spore's closure. A term $\texttt{await}(\iota)$ blocks
%execution until the future $\iota$ has been completed asynchronously. The
%\texttt{map}, \texttt{flatMap}, and \texttt{send} primitives have been
%discussed earlier.
%
%\subsection{Operational semantics}
%\label{sec:opsem}
%
%\begin{figure}[ht!]
%  \centering
%
%  $\ba[t]{l@{\hspace{2mm}}l}
%h \in Hosts &
%\\
%i \in \mathbb{N} &
%\\
% & \\
%\iota  ::=  (h, i)                               & \mbox{location}
%\\
% & \\
%r ::=     \text{Mat}(\iota) & \mbox{materialized}
%\\
%\gap ~|~  \text{Mapped}(\iota, h, r, p, opt_f)   & \mbox{lineage with \texttt{map}}
%\\
%\gap ~|~  \text{FMapped}(\iota, h, r, p, opt_f)  & \mbox{lineage with \texttt{flatMap}}
%\\
% & \\
%E      ::=  \epsilon & \mbox{message queue}
%\\
%\gap ~|~    \text{Res}(\iota, v) \texttt{::} E      & \mbox{response}
%\\
%\gap ~|~    \text{Req}(h, r, \iota) \texttt{::} E   & \mbox{request}
%\\
%\gap ~|~    \text{ReqF}(h, r, \iota) \texttt{::} E  & \mbox{request (fault)}
%\\
%  \ea$
%
%  \vspace{1mm}
%  \caption{Elements of the operational model.}
%  \label{fig:elems-opsem}
%  \vspace{1mm}
%\end{figure}
%
%In the following we give a small-step operational semantics of the primitives
%of our language. The semantics is clearly stratified into a deterministic layer
%and a non-deterministic (concurrent) layer. Importantly, this means our
%programming model can benefit from existing reasoning techniques for sequential
%programs. Program transformations that are correct for sequential programs are
%also correct for distributed programs. Our programming model shares this
%property with some existing approaches such as~\cite{ConcurrentHaskell}.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{R-Map}]
%{ host(r) = h' \quad i~\text{fresh} \\
%  r' = \text{Mapped}((h, i), h', r, p, \text{None})
%}
%{ (R[\texttt{map}(r, p)], E, S)^h \longrightarrow (R[r'], E, S)^h }
%
%\inferrule[\textsc{R-FMap}]
%{ host(r) = h' \quad i~\text{fresh} \\
%  r' = \text{FMapped}((h, i), h', r, p, \text{None})
%}
%{ (R[\texttt{flatMap}(r, p)], E, S)^h \longrightarrow (R[r'], E, S)^h }
%
%\inferrule[\textsc{R-Await}]
%{ S(\iota) = \text{Some}(v)
%}
%{ (R[\texttt{await}(\iota)], E, S)^h \longrightarrow (R[v], E, S)^h }
%
%\inferrule[\textsc{R-Res}]
%{ E = \text{Res}(\iota, v) \texttt{::} E' \quad S' = S + (\iota \mapsto v)
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E', S')^h }
%
%\inferrule[\textsc{R-ReqLocal}]
%{ E = \text{Req}(h', r, \iota'') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' \neq \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
%  loc(r') = \iota' \quad S(\iota') = \text{None} \\
%  E'' = \text{Req}(h, r', \iota') \texttt{::} E
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \rightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%  % \vspace{-3mm}
%  \caption{Deterministic reduction.}
%  \label{fig:opsem-determ}
%  % \vspace{-3mm}
%\end{figure*}
%
%\paragraph{Notation and conventions.}
%
%We write $S' = S + (\iota \mapsto v)$ to express the fact that $S'$ maps
%$\iota$ to $v$ and otherwise agrees with $S$. We write $S(\iota) =
%\text{Some}(v)$ to express the fact that $S$ maps $\iota$ to $v$. We write
%$S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$. Reduction
%is defined using reduction contexts~\cite{TAPL}. We omit the definition of
%reduction contexts, since they are completely standard.
%
%\paragraph{Configurations.}
%
%The reduction rules of the deterministic layer define transitions of \emph{host
%configurations} $(t, E, S)^h$ of host $h$ where $t$ is a term, $E$ is a message
%queue, and $S$ is a silo store. The reduction rules of the non-deterministic
%layer define transitions of sets $H$ of host configurations. The reduced host
%configurations are chosen non-deterministically in order to express concurrency
%between hosts.
%
%\paragraph{Fault handling.}
%
%In the interest of clarity we present the reduction rules in two steps. In the
%first step we explain simplified rules without fault handling semantics
%(Sections~\ref{sec:det-layer} and~\ref{sec:nondet-layer}). In the second step
%we explain how these simplified rules have to be refined in order to support
%the fault handling principles of our model (Section~\ref{sec:faults-opsem}).
%
%\subsubsection{Decentralized identification}
%
%A important property of our programming model is the fact that silos are
%uniquely identified using \emph{decentralized identifiers}. A decentralized
%identifier $\iota$ has two components: (a) the identifier of the host $h$ that
%created $\iota$, and (b) a name $i$ created fresh on $h$ (e.g., an integer
%value): $\iota = (h, i)$. Decentralized identifiers are important, since they
%reconcile two conflicting properties central to our model. The first property
%is building computation DAGs locally, without remote communication. This is
%possible using decentralized identifiers, since each host can generate new
%identifiers independently of other remote hosts. The second property is
%allowing SiloRefs to be freely copied between remote hosts. This is possible,
%since decentralized identifiers uniquely identify silos without the need for
%subsequent updates of their information; decentralized identifiers are
%immutable. This latter property is essential to enable computation DAGs that
%are \emph{immutable upon construction}. In our programming model, computation
%DAGs are created using the standard monadic operations of SiloRefs. In
%particular, the \texttt{flatMap} operation (monadic bind) in general requires
%that its argument spore captures SiloRefs that are subsequently copied to a
%remote host. Hence it is essential that SiloRefs and the decentralized
%identifiers they contain be freely copyable between remote hosts.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{R-Send}]
%{ host(r) = h' \quad h' \neq h \quad i~\text{fresh} \\
%  \iota = (h, i) \quad m = \text{Req}(h, r, \iota)
%}
%{ \{ (R[\texttt{send}(r)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\iota], E, S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req1}]
%{ E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mat}(\iota) \\
%  S(\iota) = \text{Some}(v) \quad m = \text{Res}(\iota', v)
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S)^h, (t, E'' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req2}]
%{ E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' = \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
%  S(\iota_s) = \text{Some}(v) \quad p(v) = v' \quad S' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota', v')
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S'')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S')^h, (t, E'' \cdot m, S'')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req3}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
%  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{None} \quad host(r') = h' \quad m = \text{Req}(h, r', \iota') \quad E''' = \text{Req}(h'', r', \iota'') \texttt{::} E''
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
%}
%
%\inferrule[\textsc{R-Req4}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
%  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{Some}(v') \quad S'' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota'', v')
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h''} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E'', S'')^h, (t, E' \cdot m, S')^{h''} \} \cup H
%}
%
%\end{mathpar}
%  % \vspace{-3mm}
%  \caption{Nondeterministic reduction.}
%  \label{fig:opsem-nondeterm}
%  % \vspace{-3mm}
%\end{figure*}
%
%\subsubsection{Deterministic layer}
%\label{sec:det-layer}
%
%We first consider the reduction rules of the deterministic layer shown in
%Figure~\ref{fig:opsem-determ}. The reduction rules for \texttt{map}
%(\textsc{R-Map}) and \texttt{flatMap} (\textsc{R-FMap}) do not involve
%communication with other hosts. In each case, a new SiloRef $r'$ is created
%that is derived from SiloRef $r$. The execution of the actual operation
%(\texttt{map} or \texttt{flatMap}, respectively) is deferred, and an object
%representing this derivation is returned. In both cases, the new SiloRef $r'$
%refers to a silo created on host $h'$ by applying the spore value $p$ to the
%value of silo $r$. The first component of the Mapped and FMapped objects, $(h,
%i)$, is a fresh \emph{location} created by host $h$ to uniquely identify the
%result silo.
%
%Most reduction rules are enabled when the current redex is an \texttt{await}
%term. The reduction of a term $\texttt{await}(\iota)$ only continues when store
%$S$ maps location $\iota$ to value $v$. In all other cases, the current host
%removes the next message from its message queue $E$. As shown in
%Figure~\ref{fig:elems-opsem} there are two types of messages: requests (Req)
%and responses (Res). A response $\text{Res}(\iota, v)$ tells its receiver that
%the silo at location $\iota$ has value $v$. A request $\text{Req}(h, r, \iota)$
%is sent on behalf of host $h$ to request the value of silo $r$ at location
%$\iota$. The reception of a response $\text{Res}(\iota, v)$ is handled by
%adding a mapping $(\iota \mapsto v)$ to the store (rule \textsc{R-Res}). The
%reception of a request $\text{Req}(h', r, \iota'')$ is handled locally if
%materialization of the requested silo $r$ is deferred and the parent silo $r'$
%in $r$'s lineage has not been materialized either. In this case, the host sends
%a request to materialize $r'$ to itself.
%
%
%
%\subsubsection{Nondeterministic layer}
%\label{sec:nondet-layer}
%
%All reduction rules in the nondeterministic layer, shown in
%Figure~\ref{fig:opsem-nondeterm}, involve communication between two hosts.
%
%Reducing a term $\texttt{send}(r)$ appends a request $\text{Req}(h, r, \iota)$
%to the message queue of host $h'$ of the requested silo $r$. In this case, host
%$h$ creates a unique location $\iota = (h, i)$ to identify the silo
%subsequently. Rules \textsc{R-Req1}, \textsc{R-Req2}, and \textsc{R-Req3}
%define the handling of request messages that cannot be handled locally. If the
%request can be serviced immediately (\textsc{R-Req1}), a response with the
%value $v$ of the requested silo $r$ is appended to the message queue of the
%requesting host $h'$. Rules \textsc{R-Req2} and \textsc{R-Reg3} handle cases
%where the requested silo is not already available in materialized form.
%
%% Failures may be detected whenever a message is sent to a non-local host. Note that this does not mean that message sends must be synchronous. Instead, our implementation interprets a failure to establish a network connection with a remote host as a failure of the remote host and thus a failure of all silos that it hosts.
%
%\begin{figure*}[t!]
%  \centering
%% \vspace{-7mm}
%\begin{mathpar}
%
%\inferrule[\textsc{RF-Send}]
%{ host(r) = h' \quad h' \neq h \quad \text{failed}(h') \\
%  \quad i~\text{fresh} \quad \iota = (h, i) \quad S'' = S + (\iota \mapsto \bot)
%}
%{ \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \rightarrow \{ (R[\iota], E, S'')^h \} \cup H
%}
%
%\inferrule[\textsc{RF-Req4}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
%  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
%}
%{ \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
%}
%
%\inferrule[\textsc{RF-Req5}]
%{ E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
%  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
%  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\inferrule[\textsc{RF-ReqF}]
%{ E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
%}
%{ (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%  \vspace{-3mm}
%  \caption{Fault handling.}
%  \label{fig:opsem-faults}
%  \vspace{-3mm}
%\end{figure*}
%
%% \vspace{-2.25mm}
%\subsection{Fault handling}
%\label{sec:faults-opsem}
%% \vspace{-1mm}
%The key principles of the fault handling mechanism are:
%% \vspace{-1mm}
%\begin{itemize}
%\item Whenever a message is sent to a non-local host $h$, it is checked whether
%  $h$ is alive; if it is not, any silos located on $h$ are declared to have
%  failed.
%\item Whenever the value of a silo $r$ cannot be obtained due to another failed
%  silo, $r$ is declared to have failed.
%\item Whenever the failure of a silo $r$ is detected, the nearest predecessor
%  $r'$ in $r$'s lineage that is not located on the same host is determined. If
%  $r'$ has a fault handler $f$ registered, the execution of $f$ is requested.
%  Otherwise, $r'$ is declared to have failed.
%\end{itemize}
%
%% A host either (a) discovers itself that a remote silo has failed (e.g., because it could not establish a network connection to the remote host), or (b) is notified that a remote silo has failed by a healthy host involved in its materialization.
%
%These principles are embodied in the reduction as follows. First, we use the
%predicate $\text{failed}(h)$ as a way to check whether it is possible to
%communicate with host $h$ (e.g., an implementation could check whether it is
%possible to establish a socket connection). Second, failures of hosts are
%handled whenever communication is attempted: whenever a host $h$ intends to
%send a message to a host $h'$ where $h' \neq h$, it is checked whether
%$\text{failed}(h')$. If it is the case that $\text{failed}(h')$, either the
%corresponding location (silo or future) is declared as failed (and fault
%handling deferred), or a suitable fault handler is located and a recovery step
%is attempted. In the following we explain the extended reduction rules shown in
%Figure~\ref{fig:opsem-faults}.
%
%In rule \textsc{RF-Send}, the host of the requested silo $r$ is detected to
%have failed. However, the parent silos of $r$ are all located on the same
%(failed) host. Thus, in this case silo $r$ is simply declared as failed, and
%fault handling is delegated to other parts of the computation DAG that require
%the value of $r$ (if any). Since \texttt{send} is essentially a ``sink'' of a
%DAG, no suitable fault handler can be located at this point.
%
%This is different in rule \textsc{RF-Req4}. Here, host $h$ processes a message
%requesting silo $r$ which is the result of a \texttt{flatMap} call.
%Materializing $r$ requires obtaining the value of silo $r'$, the result of
%applying spore $p$ to the value $v$ of the materialized parent $r''$.
%Importantly, if the host of $r'$ is failed, it means the computation of the DAG
%defined by spore $p$ did not result in a silo on an available host.
%Consequently, if the \texttt{flatMap} call deriving $r$ specified a fault
%handler $p_f$, $p_f$ is applied to $v$ in order to recover from the failure.
%If the host of the resulting silo $r_f$ is not failed, the original request for
%$r$ is ``modified'' to request $r_f$ instead. This is done by removing message
%$\text{Req}(h'', r, \iota'')$ from the message queue and prepending message
%$\text{Req}(h'', r_f, \iota'')$. Moreover, host $h$ sends a message to itself,
%requesting the value of silo $r_f$.
%
%Rule \textsc{RF-Req5} shows fault recovery in the case where the lineage of a
%requested silo does not specify a fault handler itself. In this case, host $h$
%creates two fresh locations $\iota_p, \iota_a$. $\iota_p$ is supposed to be
%eventually mapped to the result value of executing the fault handler of parent
%silo $r''$. Host $h$ requests this value from itself using a special message
%$\text{ReqF}(h, r'', \iota_p)$. Finally, the original request for silo $r$ in
%message queue $E$ is replaced with a request for silo $r_a$. The silo $r_a$ is
%created analogous to $r$, but using silo $\text{Mat}(\iota_p)$ as parent
%(eventually, location $\iota_p$ is mapped to the result of applying the
%parent's fault handler). As demonstrated by rule \textsc{RF-ReqF}, ReqF
%messages used to request the application of the fault handler are handled in a
%way that is completely analogous to the way regular Req messages are handled,
%except that fault handlers $p_f$ are applied as opposed to regular spores $p$.
