This section formulates progress properties. The main
Theorem~\ref{thm:finite-mat} states that materialization requests are
satisfied after a finite number of reduction steps in so-called
``responsive configurations.''

In the following we assume a {\em fair scheduling} property which
ensures that in a well-formed configuration $H~|~M$, each message $h
\leftarrow m \in M$ is eventually received by host $h$. Fair
scheduling is also assumed in other models of distributed computing
like actors~\cite{Actors,Talcott}. Formally, fair scheduling is
defined as follows:

\begin{defn}[Fair Scheduling]\label{def:fair-scheduling}
  Let $\Sigma \vdash H_0~|~M_0$ and $h \leftarrow m \in M_0$ where
  $\Sigma \vdash m$.

  Then $\exists n > 0$ such that $H_0~|~M_0 \twoheadrightarrow^*
  \ldots \twoheadrightarrow^* H_n~|~M_n \twoheadrightarrow H'~|~M'$
  where \\$\forall i \in \{ 0, \ldots, n-1 \}.~H_i~|~M_i
  \twoheadrightarrow^* H_{i+1}~|~M_{i+1}$ after a finite number of
  reduction steps, \\$\forall i \in \{ 1, \ldots, n
  \}.~\mathit{Blocked}(h, H_i)$, and $H_n~|~M_n \twoheadrightarrow
  H'~|~M'$ by rule \textsc{R-Process} or \textsc{R-Process-Val} such
  that $M_n = \hat{M} \uplus \{ h \leftarrow m \}$, $(t, \sigma)^h \in
  H_n$, $process(h, m, \sigma) = (t', M'', \sigma')$, and $M' =
  \hat{M} \uplus M''$.
\end{defn}

The predicate $\mathit{Blocked}(h, H)$ expresses the fact that host
$h$ cannot be reduced further using local reduction; i.e., host $h$ is
``blocked'' and is therefore able to process incoming
messages. Formally, $\mathit{Blocked}$ is defined as follows:

\begin{defn}[Blocked Host]\label{def:blocked-host}
  A host $h$ is {\em blocked} in a set of hosts $H$, written
  $\mathit{Blocked}(h, H)$, {\em iff} $(t, \sigma)^h \in H$ such that
  $t = E[\texttt{await}(\iota)]$ or $t = E[v]$.
\end{defn}

Although our focus is the establishment of desirable progress
properties for distributed reduction, it is necessary to consider the
following {\em strong normalization} property of single-host
reductions. For this, we consider the reduction relation $\leadsto$
defined as the subset of the reduction relation $\twoheadrightarrow$
excluding reduction rules \textsc{R-Process} and
\textsc{R-Process-Val}.

\begin{lem}[Single-Host Strong Normalization]\label{lem:strong-normal}
  Let $\Sigma \vdash H~|~M$ where $H = \{ (t, \sigma)^h \} \cup
  H'$. Then $H~|~M \leadsto^* \{ (t', \sigma')^h \} \cup H'~|~M'$
  after a finite number of reduction steps and either $t'$ is a value
  or $t' = E[\texttt{await}(\iota)]$.
\end{lem}

Note that in the above reduction, only a single host $h$ is
reduced. Furthermore, the set of in-flight messages may change, e.g.,
by applying rule \textsc{R-Send}. A proof of
Lemma~\ref{lem:strong-normal} is outside the scope of this
paper. However, our core language is, fundamentally, not more
expressive than the simply typed lambda calculus, for which strong
normalization holds.

As a prerequisite for the establishment of our main progress theorem,
we introduce a small amount of bookkeeping into the reduction
relations. The aim is to keep track of silo references created during
reduction. Importantly, this additional bookkeeping information does
not introduce any change in the semantic behavior--the information can
be erased without affecting the run-time semantics in any way.

The augmented local reduction relation has the form $E[t]~|~\sigma
\rightarrow^h E[t']~|~\sigma'~|~R$ where $R$ is either the empty set
or a singleton set containing the created silo reference. Rule
\textsc{R-Apply} is the only rule resulting in a non-empty set of
created references:

\begin{mathpar}
\inferrule[\textsc{R-Apply}] {
  r = {\Ref l {h'}} \quad
  l' = {\FMapped {(h, i)} l p} \quad i~\text{fresh} \quad
  r' = {\Ref {l'} {h'}}
} {
  E[\texttt{apply}(r, p)]~|~\sigma
  \rightarrow^h
  E[r']~|~\sigma~|~\{ r' \}
}
\end{mathpar}

The augmented distributed reduction relation has the form $H~|~M~|~R
\twoheadrightarrow H'~|~M'~|~R'$ where $R$ is the set of references
already existing before performing the reduction step and $R'$ is the
set of references existing after performing the reduction step. Rules
\textsc{R-Local} and \textsc{R-Populate} are the only rules resulting
in a set of references $R'$ where $R' \neq R$ is possible:

\begin{mathpar}
\inferrule[\textsc{R-Local}] {
  t~|~\sigma \rightarrow^h t'~|~\sigma'~|~R'
} {
  \{ (t, \sigma)^h \} \cup H ~|~ M ~|~ R
  \twoheadrightarrow
  \{ (t', \sigma')^h \} \cup H ~|~ M ~|~ R \cup R'
}

\inferrule[\textsc{R-Populate}] {
  \iota = (h, i) \quad i~\text{fresh} \quad
  l = {\Mat \iota} \quad M' = M \uplus \{ h' \leftarrow {\Res \iota v} \} \quad
  r' = {\Ref l {h'}}
} {
  \{ (E[\texttt{populate}(h', v)], \sigma)^h \} \cup H ~|~ M ~|~ R
  \twoheadrightarrow
  \{ (E[r'], \sigma)^h \} \cup H ~|~ M' ~|~ R \cup \{ r' \}
}
\end{mathpar}

Finally, the extension of well-formed configurations is
straightforward:
\begin{mathpar}
\inferrule[\textsc{WF-Config}] {
  \Sigma \vdash H \quad \Sigma \vdash M \quad \Sigma \vdash R
} {
  \Sigma \vdash H~|~M~|~R
}

\inferrule[\textsc{WF-Refs}] {
  \Sigma \vdash r \quad \Sigma \vdash R
} {
  \Sigma \vdash \{ r \} \cup R
}
\end{mathpar}

Using the augmented reduction rules we introduce a responsiveness
property, {\em responsive configurations}. Informally, in a responsive
configuration requesting (the materialization of) any previously
created silo reference results in a corresponding response after a
finite number of reduction steps. The property is defined as follows:

\begin{defn}[Responsive Configuration]\label{def:resp-config}
  A configuration $\Sigma \vdash H~|~M~|~R$ is responsive, written
  $\mathit{Responsive}(H, M, R)$, {\em iff}

  $\forall r = {\Ref l h} \in R.~(m = {\Req {h'} r \iota} \land \Sigma \vdash m) \Longrightarrow H ~|~ M \uplus \{h \leftarrow m\} ~|~ R \twoheadrightarrow^* H' ~|~ M' \uplus \{h' \leftarrow {\Res \iota v}\} ~|~ R'$ after a finite number of reduction steps.
\end{defn}

The following lemma ensures that the ability to materialize a silo
after a finite number of reduction steps is preserved under reduction.

\begin{lem}[Responsiveness]\label{lem:resp}
  Let $\Sigma \vdash H~|~M~|~R \cup \hat{R}$ and
  $\mathit{Responsive}(H, M, \hat{R})$.

  If $H~|~M~|~R \cup \hat{R} \twoheadrightarrow H'~|~M'~|~R' \cup
  \hat{R}$ then $\mathit{Responsive}(H', M', \hat{R})$.
\end{lem}
\begin{proof}[Proof Sketch]
  By induction on the derivation of $H~|~M~|~R \cup \hat{R}
  \twoheadrightarrow H'~|~M'~|~R' \cup \hat{R}$ with case analysis of
  the last applied rule, using Def.~\ref{def:fair-scheduling} and
  Lemma~\ref{lem:strong-normal}.
\end{proof}

We are now ready to introduce the main progress
theorem. Theorem~\ref{thm:finite-mat} states that finite
materialization of silos is a universal property of our core language.

\begin{thm}[Finite Materialization]\label{thm:finite-mat}
  Let $\Sigma \vdash H~|~M~|~R$ such that $\mathit{Responsive}(H, M,
  R)$.

  If $H~|~M~|~R \twoheadrightarrow H'~|~M'~|~R'$ then
  $\mathit{Responsive}(H', M', R')$.
\end{thm}
\begin{proof}
  See Appendix~\ref{app:finite-mat}.
\end{proof}
