---
layout: page
title: Scala Pickling <i>[Design Document]</i>
---

<!-- # Scala Pickling _[Design Document]_ -->

**Heather Miller**

There has never been a Scala-specific solution to serialization which can
support certain aspects of Scala's type system, nor which can generate
serialization-related boilerplate at compile-time. Even the fastest Java
serialization frameworks must generate all pickler-related code at runtime,
which in preliminary benchmarks amounts to a factor 10 slow-down over a naive
but fully-static pickler combinator-based approach.

    [info] Running JavaSerializationListBench 5
    JavaSerializationListBench$ 303 139 110 124 100
    Bytes: 1000297
    Avg: 155.2

    [info] Running KryoVectorBench 5
    KryoVectorBench$  192 139 57  49  44
    Bytes: 514098 (51% the size of Java serialized representation)
    Avg: 96.2

    [info] Running PicklerListBench 5
    PicklerListBench$ 43  5 6 7 9
    Bytes: 400004 (40% the size of Java serialized representation)
    Avg: 14

    [info] Running PicklerUnsafeListBench 5
    PicklerUnsafeListBench$ 23  14  3   3   3
    Bytes: 400004 (40% the size of Java serialized representation)
    Avg: 9.2

The goal of this project is a new framework for pickling (or serialization).
The idea is to automatically generate pickler combinators at compile-time.

The main contribution would be to extend existing approaches to pickler
combinators with support for object-oriented mechanisms, such as subclassing.

**Guiding principles:**

Scala Pickling should be:

- more typesafe than Java serialization.
- faster than Java serialization.
- more extensible than Java serialization.
- but should not be more complicated to think about than Java serialization.

**Short-term goal:** submission to
[OOPSLA 2013](http://splashcon.org/2013/cfp/due-march-28-2013)
(March 28th). See the  [OOPSLA contributions sketch](oopsla-contributions.html)
for a rough idea of the plan for the
paper's potential contributions.

**Medium-term goal:** SIP and inclusion in Scala 2.11.

**Status:** Design reasonably well worked out. Early stages of prototypical implementation.

## Overview

The project is made up of many components, which will all be covered in more
detail in their corresponding sections below:

- the overall design and architecture
- the intermediate representation of to-be-pickled and to-be-unpickled objects
- precisely what transformations take place and under what conditions
- swappable backends, for generating different pickle formats

## Usage

Ideally, a user would use the Scala Pickling framework as follows,

    class Person(name: String, age: Int)

    val p: Person = new Person("Bob", 61)
    val bytes = p.pickle

That is, the assumption is that you would be able to directly call a `pickle`
method on an object where `pickle` might not be defined. In this case, most of
the time, the framework should be able to generate all relevant pickler
combinators for your arbitrary object at compile-time.

Furthermore, the user should also be able to select pickle formats. By
default, a _Scala Binary_ format would be used, but it's planned to add
support for JSON and Protobuf as well. A user would select an alternate pickle
format as follows:

    import scala.pickling.JSONFormat

    class Person(name: String, age: Int)

    val p: Person = new Person("Bob", 61)
    val bytes = p.pickle

That is, alternate pickling formats would be represented as implicit values
which simply need to be in scope. Thus, extensibility for alternate back-ends
should be quite easy.

## Design

### Front-end

The compile-time generation of picklers is provided by a simple implicit
conversion and an implicit macro. A rough sketch is as follows:

1. Implicit search triggered by a `pickle` (or, conversely, `unpickle`) call on an arbitrary object.
2. Implicit class, or implicit conversion kicks in which provides the a dummy `pickle` method which takes an implicit `Pickler` as a parameter.
3. `Pickler` generated by an implicit macro.

To elaborate step-by-step: (as all of the expansions can get a bit confusing).

If we were to use an implicit class, `PickleOps`,

    implicit class PickleOps[T](x: T) {
      def pickle(implicit pickler: Pickler[T]) = pickler.pickle(x)
    }

our "dummy method" pimped onto our arbitrary object would be the `pickle`
method of `PickleOps`. The dummy method can then delegate all of its work to
the `Pickler` parameter. Calling the above `pickle` method of class
`PickleOps` requires an implicit argument of type `Pickler[T]`. This `Pickler`
contains the logic for actually picking the object `x` (the constructor
argument of `PickleOps`). The `Pickler` object can be generated at compile
time using an implicit macro as follows.

First, we need to have the following defs in scope:

    implicit def genPickler[T]: Pickler[T] = macro genPicklerImpl
    def genPicklerImpl[...](...): Expr[Pickler[T]]

That is, we arrange things so that this (second) round of implicit search will
find the implicit def `genPickler` when searching for the implicit
`Pickler[T]`.

Thus, a call to `pickle` would be expanded to

    PickleOps(p).pickle(genPickler)

which expands to

    genPickler.pickle(p)

which, in turn, is expanded by the macro implementation.

**Please note** that several scenarios aren't fully-supported with this
approach so far. In particular, private fields, separate compilation  in
particular with private fields, or constructor arguments cannot be supported
using this initial approach alone. In a later section, Macro/Compiler-related
Implementation requirements, an extension is outlined which would enable
support for these cases.

### Compiler Transformations

Following the above chain of interactions, our macro must generate a
`Pickler[T]` parameterized on the type for which we desire a pickler.
`Pickler` can be thought of as simply:

    trait Pickler[T] {
      def pickle(obj: T): Pickle = ...
      def unpickle(p: Pickle): T = ...
    }

Where `Pickle` represents the resulting pickle format (its internal value type
could be a `String` as in the case of JSON, or `Array[Byte]` in the case of
the Scala Binary format, for example). This is covered in more detail in the
corresponding section: Back-end, Selecting Different Pickle Formats.

Given a small motivating example:

    class Person { var name: String = _ ; var age: Int = _ }
    class Employee extends Person { var position: String = _ }

Say we want to generate a `Pickler[Employee]`. The idea is to generate its
`pickle` and `unpickle` methods as follows:

1. For each field declared in class `Employee`, we obtain a `Pickler` for the field's type, in this case `Pickler[String]`.
2. For each super class, we obtain a `Pickler`, in this case `Pickler[Person]`. Note that this invokes the macro recursively.

Ideally, each `Pickler` generated would be inserted into a map somewhere for
later re-use, i.e. as an optimization. (Although exactly _where_/_how_ is a
very good question-- to be discussed).

Note, however, that if we had the following scenario, the above steps would
not be enough:

    def send(p: Person): Unit = sendOverWire(p.pickle) // this would result in a Pickler[Person]

    val e = new Employee
    send(e)

Because of this, we need to have an additional dispatch step. Basically,

Problem:

- separate compilation
- macro expansion using all subclasses, then a new subclass is defined

### Intermediate Representation

### Back-end, Selecting Different Pickle Formats

## Macro/Compiler-related Implementation Requirements

Ideally, all code that would require any sort of transformation would transformed using macros alone. However, it is not possible to

## Runtime Fallback

## Remaining Points/Issues

- Recursive types: we could have a map for each invocation of the macro, to handle this case.
- Special cases: we can special-case stuff like `Traversable`s to make them more efficient
- Macro can issue an error message if someone tries to pickle an abstract class or a trait that does not have an `apply` method in the companion object-- i.e. if there's no way to instantiate it
