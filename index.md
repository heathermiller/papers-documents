---
layout: page
title: Scala Pickling <i>[Design Document]</i>
---

<!-- # Scala Pickling _[Design Document]_ -->

**Heather Miller**

There has never been a Scala-specific solution to serialization which can
support certain aspects of Scala's type system, nor which can generate
serialization-related boilerplate at compile-time. Even the fastest Java
serialization frameworks must generate all pickler-related code at runtime,
which in preliminary benchmarks amounts to a factor 10 slow-down over a naive
but fully-static pickler combinator-based approach.

    [info] Running JavaSerializationListBench 5
    JavaSerializationListBench$ 303 139 110 124 100
    Bytes: 1000297
    Avg: 155.2

    [info] Running KryoVectorBench 5
    KryoVectorBench$  192 139 57  49  44
    Bytes: 514098 (51% the size of Java serialized representation)
    Avg: 96.2

    [info] Running PicklerListBench 5
    PicklerListBench$ 43  5 6 7 9
    Bytes: 400004 (40% the size of Java serialized representation)
    Avg: 14

    [info] Running PicklerUnsafeListBench 5
    PicklerUnsafeListBench$ 23  14  3   3   3
    Bytes: 400004 (40% the size of Java serialized representation)
    Avg: 9.2

The goal of this project is a new framework for pickling (or serialization).
The idea is to automatically generate pickler combinators at compile-time.

The main contribution would be to extend existing approaches to pickler
combinators with support for object-oriented mechanisms, such as subclassing.

**Guiding principles:**

Scala Pickling should be:

- more typesafe than Java serialization.
- faster than Java serialization.
- more extensible than Java serialization.
- but should not be more complicated to think about than Java serialization.

**Short-term goal:** submission to
[OOPSLA 2013](http://splashcon.org/2013/cfp/due-march-28-2013)
(March 28th). See the  [OOPSLA contributions sketch](oopsla-contributions.html)
for a rough idea of the plan for the
paper's potential contributions.

**Medium-term goal:** SIP and inclusion in Scala 2.11.

**Status:** Much of the design worked out (though, still some rough edges).
Early stages of prototypical implementation.

## Overview

The project is made up of many components, which will all be covered in more
detail in their corresponding sections below:

- the overall design and architecture
- the intermediate representation of to-be-pickled and to-be-unpickled objects
- precisely what transformations take place and under what conditions
- swappable backends, for generating different pickle formats

## Usage

Ideally, a user would use the Scala Pickling framework as follows,

    class Person(name: String, age: Int)

    val p: Person = new Person("Bob", 61)
    val bytes = p.pickle

That is, the assumption is that you would be able to directly call a `pickle`
method on an object where `pickle` might not be defined. In this case, most of
the time, the framework should be able to generate all relevant pickler
combinators for your arbitrary object at compile-time.

Furthermore, the user should also be able to select pickle formats. By
default, a _Scala Binary_ format would be used, but it's planned to add
support for JSON and Protobuf as well. A user would select an alternate pickle
format as follows:

    import scala.pickling.JSONFormat

    class Person(name: String, age: Int)

    val p: Person = new Person("Bob", 61)
    val bytes = p.pickle

That is, alternate pickling formats would be represented as implicit values
which simply need to be in scope. Thus, extensibility for alternate back-ends
should be quite easy.

## Design

### Front-end

The compile-time generation of picklers is provided by a simple implicit
conversion and an implicit macro. A rough sketch is as follows:

1. Implicit search triggered by a `pickle` (or, conversely, `unpickle`) call on an arbitrary object.
2. Implicit class, or implicit conversion kicks in which provides the a dummy `pickle` method which takes an implicit `Pickler` as a parameter.
3. `Pickler` generated by an implicit macro.

To elaborate step-by-step: (as all of the expansions can get a bit confusing).

If we were to use an implicit class, `PickleOps`,

    implicit class PickleOps[T](x: T) {
      def pickle(implicit pickler: Pickler[T]) = pickler.pickle(x)
    }

our "dummy method" pimped onto our arbitrary object would be the `pickle`
method of `PickleOps`. The dummy method can then delegate all of its work to
the `Pickler` parameter. Calling the above `pickle` method of class
`PickleOps` requires an implicit argument of type `Pickler[T]`. This `Pickler`
contains the logic for actually picking the object `x` (the constructor
argument of `PickleOps`). The `Pickler` object can be generated at compile
time using an implicit macro as follows.

First, we need to have the following defs in scope:

    implicit def genPickler[T]: Pickler[T] = macro genPicklerImpl
    def genPicklerImpl[...](...): Expr[Pickler[T]]

That is, we arrange things so that this (second) round of implicit search will
find the implicit def `genPickler` when searching for the implicit
`Pickler[T]`.

Thus, a call to `pickle` would be expanded to

    PickleOps(p).pickle(genPickler)

which expands to

    genPickler.pickle(p)

which, in turn, is expanded by the macro implementation.

**Please note** that several scenarios aren't fully-supported with this
approach so far. In particular, private fields, separate compilation  in
particular with private fields, or constructor arguments cannot be supported
using this initial approach alone. In a later section, Macro/Compiler-related
Implementation requirements, an extension is outlined which would enable
support for these cases.

### Compiler Transformations

Following the above chain of interactions, our macro must generate a
`Pickler[T]` parameterized on the type for which we desire a pickler.
`Pickler` can be thought of as simply:

    trait Pickler[T] {
      def pickle(obj: T): Pickle = ...
      def unpickle(p: Pickle): T = ...
    }

Where `Pickle` represents the resulting pickle format (its internal value type
could be a `String` as in the case of JSON, or `Array[Byte]` in the case of
the Scala Binary format, for example). This is covered in more detail in the
corresponding section: _Back-end, Selecting Different Pickle Formats_.

Given a small motivating example:

    class Person { var name: String = _ ; var age: Int = _ }
    class Employee extends Person { var position: String = _ }

Say we want to generate a `Pickler[Employee]`. The idea is to generate its
`pickle` and `unpickle` methods as follows:

1. For each field declared in class `Employee`, we obtain a `Pickler` for the field's type, in this case `Pickler[String]`.
2. For each super class, we obtain a `Pickler`, in this case `Pickler[Person]`. Note that this invokes the macro recursively.

Ideally, each `Pickler` generated would be inserted into a map somewhere for
later re-use, i.e. as an optimization. (Although exactly _where_ / _how_ is a
very good question-- to be discussed).

#### Issues with this approach

There is one major issue, however. In the following scenario, the above steps would
not be enough to guarantee the proper type upon unpickling:

    def send(p: Person): Unit = sendOverWire(p.pickle) // this would result in a Pickler[Person] being generated

    val e = new Employee
    send(e)

The problem here, is that if we were to use the same approach to generate an
unpickler, we'd unfortunately only have an unpickler for `Person`, and not for
its subclass, `Employee`.

Naively, one would hope to solve this problem by adding a third step to the
list above: For each _subclass_, obtain a `Pickler` as well.

Though, to the best of my knowledge, this is not possible to do reliably,
especially  in the presence of separate compilation. That is, it's not
possible to know all possible subclasses without depending on the type system
in some capacity, _e.g._ the requirement of a marker trait for root classes
to-be-pickled in the hierarchy. This, of course, would unravel many of our
earlier design guidelines; we want to be less verbose, and easier to extend
than Java serialization.

#### Possible Solution

One idea (though quite involved) could be to add a dynamic dispatch step which
allows us to take the dynamic type of the object to be pickled into account.
Though, the challenge here is to support this as best as we can in the face of
separate compilation.

The approach would be to support two cases:

1. In the case where separate compilation is required, we would require that
library authors extend a `Pickleable` trait (implemented as a type macro) for
base classes of types that might be pickled by client code.

2. In the case where separate compilation is not an issue, we can use an
implicit macro to generate the dynamic dispatch code automatically.

These two cases can be accommodated in the following design.

This means, first that the object to be pickled must somehow be viewable as
something that has a method for dispatching to the right pickler. So, we
introduce a (structural) type for this, `HasPicklerDispatch` which should have
a method `dispatchTo`:

    type HasPicklerDispatch { def dispatchTo: Pickler[_] }

**Note** that structural types might not be the best choice, using them can be a
bit slow at runtime when it comes to dispatching to subtypes. A small
extension to type macros, however, might allow us to use a regular trait
instead.

Next, we would have to change our implicit class defined in the earlier section,
_Front-end_ so that `PickleOps`'s type parameter has the view bound
`HasPicklerDispatch`:

    implicit class PickleOps[T <% HasPicklerDispatch](x: T) {
      def pickle: Pickle = x.dispatchTo.pickle(x)
    }

Doing this would make it possible to generate the correct pickler for an
object we wish to pickle, `x`, even if the dynamic type of `x` is a subtype of
`T`. Instead of basing the decision only on the static type of `x`, we first
dynamically dispatch to the `Pickler` by calling the method `dispatchTo` on
`x`.

The cases 1 and 2 mentioned above determine how the `dispatchTo` method is
made available. In the first case, the `Pickleable` type macro would be
responsible for generating the `dispatchTo` method-- thus all subclasses also
would indirectly extend the `Pickleable` trait, which should in turn generate
the pickler for these subclasses (right now, this might require a small
extension of type macros-- we might need a trigger to re-expand them in
subclasses, but this is to be further explored). In the second case, we would
use an implicit macro to convert an object to an instance of
`HasPicklerDispatch`.

Where the idea is to generate the `dispatchTo` method
using a type macro.



Calling `dispatchTo` in

is that we could achieve something similar to what the dynamic dispatch step that
implicits in collections achieve-- .

To obtain the right pickler for an object we wish to pickle, `p`, instead of basing the decision only on the static type of `p`, we first dynamically dispatch to the pickler container by calling a method on `p`. This method can be

Small change to type macros might be able to solve this. This would work perfectly well if
Maybe we could use structural types to solve this?

**This issue is one which I have banged my head against, and for which, I can't find a satisfying solution. Any pointers here would be very welcome**

### Intermediate Representation

### Back-end, Selecting Different Pickle Formats

## Macro/Compiler-related Implementation Requirements

Ideally, all code that would require any sort of transformation would transformed using macros alone. However, it is not possible to

## Runtime Fallback

## Remaining Points/Issues

- Recursive types: we could have a map for each invocation of the macro, to handle this case.
- Special cases: we can special-case stuff like `Traversable`s to make them more efficient
- Macro can issue an error message if someone tries to pickle an abstract class or a trait that does not have an `apply` method in the companion object-- i.e. if there's no way to instantiate it
