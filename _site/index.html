<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <title>Scala Pickling <i>[Design Document]</i></title>

    
    <meta name="author" content="">

    <link rel="stylesheet" href="css/styles.css">
    <link rel="stylesheet" href="css/pygment_trac.css">

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header class="main">
        <hgroup>
          <h1><a href="/"></a></h1>
          <h2>Design of the Scala pickler framework</h2>
        </hgroup>
        <ul class="buttons">
          <li><a href="http://github.com/heathermiller/pickling-design-doc" rel="me">Document Source <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section class="main">
        <h1>Scala Pickling <i>[Design Document]</i></h1>

<p><strong>Heather Miller</strong></p>

<p>There has never been a Scala-specific solution to serialization which can supports certain aspects of Scala&#8217;s type system, nor which can generate serialization-related boilerplate at compile-time. Even the fastest Java serialization frameworks must generate all pickler-related code at runtime, which in preliminary benchmarks amounts to a factor 10 slow-down over a naive but fully-static pickler combinator-based approach.</p>

<pre><code>[info] Running JavaSerializationListBench 5
JavaSerializationListBench$ 303 139 110 124 100
Bytes: 1000297
Avg: 155.2

[info] Running KryoVectorBench 5
KryoVectorBench$  192 139 57  49  44
Bytes: 514098 (51% the size of Java serialized representation)
Avg: 96.2

[info] Running PicklerListBench 5
PicklerListBench$ 43  5 6 7 9
Bytes: 400004 (40% the size of Java serialized representation)
Avg: 70

[info] Running PicklerUnsafeListBench 5
PicklerUnsafeListBench$ 23  14  3   3   3
Bytes: 400004 (40% the size of Java serialized representation)
Avg: 9.2</code></pre>

<p>The goal of this project is a new framework for pickling (or serialization). The idea is to automatically generate pickler combinators.</p>

<p>The main contribution would be to extend existing approaches to pickler combinators with support for OO mechanisms, such as subclassing. An ideal plan for the design is below. The hope is that we can work together on the code generation parts of this.</p>

<p><strong>Guiding principles:</strong></p>

<ul>
<li>Should be more typesafe than Java serialization.</li>

<li>Should be faster than Java serialization.</li>

<li>Should be more extensible than Java serialization.</li>

<li>Should not be more complicated to think about than Java serialization.</li>
</ul>

<p><strong>Short-term goal:</strong> submission to OOPSLA 2013.</p>

<p><strong>Medium-term goal:</strong> SIP and inclusion in Scala 2.11.</p>

<p>A crucial part of the entire effort is the generation of the pickling code at compile time. For example, one would expect to be able to call <code>pickle</code> on an arbitrary object, via an implicit conversion or an implicit class. For example,</p>

<pre><code>implicit class PickleOps[T](x: T) {
  def pickle(implicit pickler: Pickler[T]): Pickle[T] = ...
}</code></pre>

<p>Note that the implicit <code>pickler</code> argument should be generated automatically. There are some difficulties. For example, if <code>T</code> is a class <code>C</code> with private fields, then the <code>Pickler[C]</code> would need to have access to those fields.</p>

<p>One approach would be to generate this <code>Pickler[C]</code> in <code>C</code>&#8217;s companion object. However, when compiling class <code>C</code> it cannot, in general, be known whether instances of this class are going to be pickled in other parts of the program (those other parts could be separately compiled). There is a case, though, where we have more information. For example, when class <code>C</code> is compiled in a compilation unit which also contains code which requires an implicit value of type <code>Pickler[C]</code>, then we know instances of class <code>C</code> are potentially pickled. In that case, we could generate the pickler in <code>C</code>&#8217;s companion object.</p>

<p>If we cannot add the pickler to the companion object of a class, because we don&#8217;t know whether instances of that class are ever pickled, we need to fall back to a dynamically-generated pickler. Apart from a difference in accessing private fields, the code for a fall-back pickler should be the same as for a regular pickler, except that the generation of the fall back is executed at runtime.</p>

<pre><code>implicit val pickler: Pickler[C] = new Pickler[C] {
  def pickle(o: C): Pickle[C] = {
    // obtain types of fields
    // obtain superclass (if any)
    // ...
  }
}</code></pre>

<p>Another issue is constructor parameters. To get access to those for pickling, we could generate synthetic private fields inside the class, which could then be accessed inside the companion object.</p>

<pre><code>class Person(name: String, age: Int) {
  var grades = List[String]()
  // synthetic:
  private def ctorArgs: Array[Any]
}

object Person {
  implicit val pickler: Pickler[Person] = {
    // look up/generate picklers for types of fields: String, Int, List, ...
  }
}</code></pre>

<p>One tricky bit is to be able to add members both to the class and its companion object. To be idealistic, let&#8217;s assume we can do this for now.</p>

<p>The <code>Pickler[T]</code> trait contains a method <code>unpickle</code> which takes a pickled representation of type <code>T</code> (could be an <code>Array[Byte]</code>) and returns a <code>T</code>. The unpickling code comprises:</p>

<p>1. code to create a new instance of type <code>T</code> 2. code to re-initialize <code>T</code>&#8217;s fields</p>

<p>How to generate <em>unpickling code</em> for a <code>Pickler[C]</code> where <code>C</code> is a class with a superclass different from <code>AnyRef</code>? Example:</p>

<pre><code>class C extends D {
  var x: Int = _
}
class D {
  var s: String = _
}</code></pre>

<p>Idea: 1. create new instance <code>c</code> of class <code>C</code>. Re-initialize <code>c</code>&#8217;s fields using <code>reinit</code> methods (<code>fieldVals</code> is an <code>Array[Any]</code> with the unpickled field values):</p>

<pre><code>val c = new C
picklerC.reinit(c, fieldVals)</code></pre>

<p>The <code>reinit</code> method of <code>Pickler[C]</code> uses <code>reinit</code> of the looked-up <code>Pickler[D]</code>:</p>

<pre><code>def reinit(c: C, fieldVals: Array[Any]) {
  c.x = fieldVals.head.asInstanceOf[Int]
  picklerD.reinit(c, fieldVals.tail)
}</code></pre>

<h2 id='class_without_constructor_parameters_or_private_fields'>Class without constructor parameters or private fields</h2>

<p>Q: where to put the implicit picklers in that case?</p>

<p>How to support separate compilation? Let&#8217;s assume class <code>Person</code> has been compiled. Then, we compile code which demands a <code>Pickler[Person]</code>. We somehow need to generate accessors for <code>Person</code>s constructor parameters retro-actively in class <code>Person</code>.</p>

<p>(One approach could be to use a Java agent that rewrite the bytecode of class <code>Person</code> when <code>Person</code> is loaded.)</p>

<pre><code>person.pickle(&lt;implicit pickler&gt;)</code></pre>

<p>Table of picklers.</p>

<p>generate extra stuff for types <code>T</code> where in some part of the program we need an implicit of type <code>Pickler[T]</code>?</p>

<p>class C { private val privfld: String = &#8230; val pubfld: Int = &#8230; }</p>

<p>object C { implicit val pickler: Pickler<span>C</span> = &#8230; }</p>

<p>class C extends D {</p>

<p>}</p>

<p>class C(x: Int) { private val ctor_x: Int = x }</p>

<p>object C {</p>

<p>}</p>

<p>o: T o.pickle</p>
      </section>
      <aside>
        <nav>
          <ul>
            
            
          </ul>
        </nav>
        <ul>
          <li class="contact"><a href="mailto:"></a></li>
        </ul>
      </aside>
      <footer class="main">
        <p>
          <small>Themed with <a href="http://sdb.github.com/jb-theme-ghminimal/">ghminimal</a> based on <a href="http://github.com/orderedlist/minimal/">minimal</a>. Powered by <a href="http://github.com/mojombo/jekyll">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a>.</small>
        </p>
      </footer>
    </div>
    <script src="/js/scale.fix.js"></script>

  </body>
</html>