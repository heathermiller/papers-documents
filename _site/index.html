<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <title>Scala Pickling <i>[Design Document]</i></title>

    
    <meta name="author" content="">

    <link rel="stylesheet" href="/css/styles.css">
    <link rel="stylesheet" href="/css/pygment_trac.css">

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header class="main">
        <hgroup>
          <h1><a href="/"></a></h1>
          <h2>Design of the Scala pickler framework</h2>
        </hgroup>
        <ul class="buttons">
          <li><a href="http://github.com/heathermiller/pickling-design-doc" rel="me">Source <strong>GitHub</strong></a></li>
<!--           <li><a href="http://www.linkedin.com/in//" rel="me">Connect <strong>LinkedIn</strong></a></li>
          <li><a href="http://twitter.com//" rel="me">Follow <strong>Twitter</strong></a></li> -->
        </ul>
      </header>
      <section class="main">
        <h1>Scala Pickling <i>[Design Document]</i></h1>

<!-- Serialization, or _pickling_ in Scala has always depended Java-based
frameworks or libraries-- most famously, the JVM's built-in runtime
serialization. Most of these frameworks automatically take care of serialization for the
programmer, but do so at runtime, incurring a considerable runtime performance hit.

Pickler combinators have been long been thought of as the most robust approach
to serialization in functional languages. Pickler combinators compose
elegantly, but are considered a major source of boilerplate to manually write. -->
<p>There has never been a Scala-specific solution to serialization which can supports certain aspects of Scala&#8217;s type system, nor which can generate serialization-related boilerplate at compile-time. Even the fastest Java serialization frameworks must generate all pickler-related code at runtime, which in preliminary benchmarks</p>

<p><strong>Guiding principles:</strong></p>

<ul>
<li>Should be more typesafe than Java serialization.</li>

<li>Should be faster than Java serialization.</li>

<li>Should be more extensible than Java serialization.</li>

<li>Should not be more complicated to think about than Java serialization.</li>
</ul>

<p><strong>Short-term goal:</strong> submission to OOPSLA 2013.</p>

<p><strong>Medium-term goal:</strong> SIP and inclusion in Scala 2.11.</p>

<h2 id='design'>Design</h2>

<p>We&#8217;re building a framework for pickling (or serialization). The idea is to automatically generate picklers. The main contribution would be to extend existing approaches to pickler combinators with support for OO mechanisms, such as subclassing. An ideal plan for the design is below. The hope is that we can work together on the code generation parts of this.</p>

<p>A crucial part of the entire effort is the generation of the pickling code at compile time. For example, one would expect to be able to call <code>pickle</code> on an arbitrary object, via an implicit conversion or an implicit class. For example,</p>

<pre><code>implicit class PickleOps[T](x: T) {
  def pickle(implicit pickler: Pickler[T]): Pickle[T] = ...
}</code></pre>

<p>Note that the implicit <code>pickler</code> argument should be generated automatically. There are some difficulties. For example, if <code>T</code> is a class <code>C</code> with private fields, then the <code>Pickler[C]</code> would need to have access to those fields.</p>

<p>One approach would be to generate this <code>Pickler[C]</code> in <code>C</code>&#8217;s companion object. However, when compiling class <code>C</code> it cannot, in general, be known whether instances of this class are going to be pickled in other parts of the program (those other parts could be separately compiled). There is a case, though, where we have more information. For example, when class <code>C</code> is compiled in a compilation unit which also contains code which requires an implicit value of type <code>Pickler[C]</code>, then we know instances of class <code>C</code> are potentially pickled. In that case, we could generate the pickler in <code>C</code>&#8217;s companion object.</p>

<p>If we cannot add the pickler to the companion object of a class, because we don&#8217;t know whether instances of that class are ever pickled, we need to fall back to a dynamically-generated pickler. Apart from a difference in accessing private fields, the code for a fall-back pickler should be the same as for a regular pickler, except that the generation of the fall back is executed at runtime.</p>

<pre><code>implicit val pickler: Pickler[C] = new Pickler[C] {
  def pickle(o: C): Pickle[C] = {
    // obtain types of fields
    // obtain superclass (if any)
    // ...
  }
}</code></pre>

<p>Another issue is constructor parameters. To get access to those for pickling, we could generate synthetic private fields inside the class, which could then be accessed inside the companion object.</p>

<pre><code>class Person(name: String, age: Int) {
  var grades = List[String]()
  // synthetic:
  private def ctorArgs: Array[Any]
}

object Person {
  implicit val pickler: Pickler[Person] = {
    // look up/generate picklers for types of fields: String, Int, List, ...
  }
}</code></pre>

<p>One tricky bit is to be able to add members both to the class and its companion object. To be idealistic, let&#8217;s assume we can do this for now.</p>

<p>The <code>Pickler[T]</code> trait contains a method <code>unpickle</code> which takes a pickled representation of type <code>T</code> (could be an <code>Array[Byte]</code>) and returns a <code>T</code>. The unpickling code comprises:</p>

<p>1. code to create a new instance of type <code>T</code> 2. code to re-initialize <code>T</code>&#8217;s fields</p>

<p>How to generate <em>unpickling code</em> for a <code>Pickler[C]</code> where <code>C</code> is a class with a superclass different from <code>AnyRef</code>? Example:</p>

<pre><code>class C extends D {
  var x: Int = _
}
class D {
  var s: String = _
}</code></pre>

<p>Idea: 1. create new instance <code>c</code> of class <code>C</code>. Re-initialize <code>c</code>&#8217;s fields using <code>reinit</code> methods (<code>fieldVals</code> is an <code>Array[Any]</code> with the unpickled field values):</p>

<pre><code>val c = new C
picklerC.reinit(c, fieldVals)</code></pre>

<p>The <code>reinit</code> method of <code>Pickler[C]</code> uses <code>reinit</code> of the looked-up <code>Pickler[D]</code>:</p>

<pre><code>def reinit(c: C, fieldVals: Array[Any]) {
  c.x = fieldVals.head.asInstanceOf[Int]
  picklerD.reinit(c, fieldVals.tail)
}</code></pre>

<h2 id='class_without_constructor_parameters_or_private_fields'>Class without constructor parameters or private fields</h2>

<p>Q: where to put the implicit picklers in that case?</p>

<p>How to support separate compilation? Let&#8217;s assume class <code>Person</code> has been compiled. Then, we compile code which demands a <code>Pickler[Person]</code>. We somehow need to generate accessors for <code>Person</code>s constructor parameters retro-actively in class <code>Person</code>.</p>

<p>(One approach could be to use a Java agent that rewrite the bytecode of class <code>Person</code> when <code>Person</code> is loaded.)</p>

<pre><code>person.pickle(&lt;implicit pickler&gt;)</code></pre>

<p>Table of picklers.</p>

<p>generate extra stuff for types <code>T</code> where in some part of the program we need an implicit of type <code>Pickler[T]</code>?</p>

<p>class C { private val privfld: String = &#8230; val pubfld: Int = &#8230; }</p>

<p>object C { implicit val pickler: Pickler<span>C</span> = &#8230; }</p>

<p>class C extends D {</p>

<p>}</p>

<p>class C(x: Int) { private val ctor_x: Int = x }</p>

<p>object C {</p>

<p>}</p>

<p>o: T o.pickle</p>
      </section>
      <aside>
        <nav>
          <ul>
            
            
          </ul>
        </nav>
        <ul>
          <li class="contact"><a href="mailto:"></a></li>
        </ul>
      </aside>
      <footer class="main">
        <p>
          <small>Themed with <a href="http://sdb.github.com/jb-theme-ghminimal/">ghminimal</a> based on <a href="http://github.com/orderedlist/minimal/">minimal</a>. Powered by <a href="http://github.com/mojombo/jekyll">Jekyll</a> and <a href="http://pages.github.com/">GitHub Pages</a>.</small>
        </p>
      </footer>
    </div>
    <script src="/js/scale.fix.js"></script>

  </body>
</html>