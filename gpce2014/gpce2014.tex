%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{listings,xspace}
\usepackage{amsmath}
\usepackage{fontspec}
\usepackage{xcolor}

\lstdefinelanguage{Scala}%
{morekeywords={abstract,case,catch,char,class,%
    def,else,extends,final,%
    if,import,%
    match,module,new,null,object,override,package,private,protected,%
    public,return,super,this,throw,trait,try,type,val,var,with,implicit,%
    macro,sealed,%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

% \lstset{language=Scala,%
%   mathescape=true,%
%   columns=[c]fixed,%
%   basewidth={0.5em, 0.40em},%
%   basicstyle=\tt,%
%   xleftmargin=0.0cm
% }

% \lstset{tabsize=2,
% basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont,
% commentstyle=\itshape\rmfamily,
% numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=scala,moredelim=[il][\sffamily]{?},mathescape=false,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapechar=@, morekeywords=[1]{let,fn,val},deletekeywords={for},classoffset=0,belowskip=\smallskipamount
% }

\lstset{tabsize=2,
basicstyle=\ttfamily\fontsize{10pt}{1em}\selectfont,
commentstyle=\itshape\rmfamily,
language=scala,moredelim=[il][\sffamily]{?},mathescape=false,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapechar=@, morekeywords=[1]{let,fn,val},deletekeywords={for},classoffset=0,belowskip=\smallskipamount
}

\newcommand{\todo}{{\bf \colorbox{red}{\color{white}TODO:}}}
\newcommand{\ie}{{\em i.e.,~}}
\newcommand{\eg}{{\em e.g.,~}}
\newcommand{\term}[1]{\mbox{\texttt{#1}}}
\newcommand{\itl}[1]{\mbox{\textit{#1}}}


\begin{document}

\setmainfont[Mapping=tex-text]{Times New Roman}
\setmonofont[Scale=0.8,BoldFont={Consolas Bold}]{Consolas}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{GPCE'14}{September 14--15, 2014, V\"{a}ster\r{a}s, Sweden}
\copyrightyear{2014}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish,
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers,
                                  % short abstracts)

% \titlebanner{banner above paper title}        % These are ignored unless
% \preprintfooter{short description of paper}   % 'preprint' option specified.

% Materialization: Pluggable Type System Extensions
% Generative Self-Assembly: Language Extensions and Datatype Generic Programming
% Self-Assembling Type System Extensions
% Type System Extensions Through Generative Self-Assembly

\title{Generative Self-Assembly: Language Extensions and Datatype Generic Programming}
% \subtitle{Subtitle Text, if any}

\authorinfo{Heather Miller}
           {EPFL}
           {heather.miller@epfl.ch}
\authorinfo{Philipp Haller}
           {Typesafe, Inc.}
           {philipp.haller@typesafe.com}
\authorinfo{Bruno C. d. S. Oliveira}
           {The University of Hong Kong}
           {bruno@cs.hku.hk}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

The text of the paper begins here.~\cite{ComparingGPHaskellRodriquez, ComparingGPHaskellHinze, ScalaGenericProgrammers, RepLib, OOGP}

Implicits are a huge deal, because they provide \textbf{extensibility.} Users can easily customize generated code by making use of implicits in Scala.

Using this approach, we have implemented a full-featured serialization framework for Scala. Full-featured in that it handles all object-oriented concerns, such as subtyping polymorphism, object identity, etc. As well as advanced features of the type system. This is not a toy example. It's general!

Contributions.

Implicits and macros powerful tools for doing generative programming. In fact, so powerful, that we can do more than inlined and performant datatype generic programming. We can use these generative techniques to extend the compiler and type system in local but powerful ways.

\begin{itemize}
\item library
\item pattern
\end{itemize}

We first describe what we call the ``self-assembly pattern'' -- a technique for combining implicits and macros to generate complex in Section~\ref{sec:self-assembly-pattern} to generate type class instances.

\section{Background}
\label{sec:background}

\subsection{Singletons}
\label{sec:singletons}

...

\paragraph{Companion Objects} ...


\subsection{Implicits}
\label{sec:implicits}

\paragraph{Implicit Parameters.} In Scala, it is possible to select values
automatically based on type. These capabilities are enabled when using the
\term{implicit} keyword. For example, a method \term{log} with multiple
parameter lists may annotate their last parameter list using the
\term{implicit} keyword.\footnote{Example taken from~\cite{Oliveira2010}.}

\begin{lstlisting}
def log(msg: String)(implicit o: PrintStream) =
  o.println(msg)
\end{lstlisting}

This means that in an invocation of \term{log}, the implicit argument list may
be omitted if, for each parameter of that list, there is exactly one value of
the right type in the {\em implicit scope}. The implicit scope is an
adaptation of the regular variable scope; imported implicits, or implicits
declared in an enclosing scope are contained in the implicit scope of a method
invocation.

\begin{lstlisting}
    implicit val out = System.out
    log("Does not compute!")
\end{lstlisting}

In the above example, the implicit val \term{out} is in the implicit scope of
the invocation of \term{log}; since it has the right type, it is automatically
selected as an implicit argument.

%\todo Maybe we should change this example? It's out of Bruno's paper, and he's
%on the committee, he'll probably review our paper.

%\todo Talk about how we use implicit values in our framework here.

\paragraph{Implicit Conversions.} Implicit conversions can be thought of as
methods which, like implicit parameters, can be implicitly selected (\ie
invoked) based upon their type, and whether or not they are present in
implicit scope. As with implicit parameters, implicit conversions also carry
the \term{implicit} keyword before their declaration.

\begin{lstlisting}
 implicit def intWrapper(x: Int): Message =
    new Message {
      def message: String = "secret message!"
    }
\end{lstlisting}

In the example above, assuming there exists an abstract class \term{Message}
with abstract method \term{message}, the implicit conversion
\term{intWrapper} will be triggered when a method called \term{message}
is called on an \term{Int}. That is, simply calling
\term{39.message} will result in ``secret message!'' being
returned. Since the implicit conversion has the effect of adding a
``new'' method to type \term{Int}, \term{message} is typically called an
{\em extension method}. In our framework we use implicit conversions,
for example, for adding a \term{pickle} method to arbitrary objects.

% cite Adriaan's and Bruno's OOPSLA paper. Where? How?
% Example of a type class: maybe Ordering type class of std lib?
% Include info on importing implicit values, and implicit resolution by scoping.
% Example of a plain implicit parameter: could use implicit ExecutionContext in futures

% \subsection{Reflection}
% \label{sec:reflection}

% Reflection is the ability of a program to inspect, and possibly even modify
% itself at runtime. Before Scala 2.10, Scala did not have any reflection
% capabilities of its own. Instead, one could use Java reflection which provided
% basic but limited runtime reflection capabilities. In Scala 2.10, a new
% reflection library was introduced not only to address the shortcomings of
% Java's runtime reflection on Scala-specific and generic types, but to also add
% a more powerful toolbox of general reflective capabilities to Scala. Along
% with full-featured runtime reflection for Scala types and generics, Scala 2.10
% also ships with compile-time reflection capabilities, in the form of macros
% (covered in Section \ref{sec:macros}), as well as the ability to reify Scala
% expressions into abstract syntax trees.

% \paragraph{TypeTags.} One aspect of runtime reflection that was introduced in
% Scala 2.10 is the notion of \verb|TypeTag|s. As with other JVM languages,
% Scala's types are erased at compile time. \verb|TypeTag|s can be thought of as
% objects which carry along all type information available at compile time, to
% runtime. As we will see, \verb|TypeTag|s will prove to be invaluable in
% situations where precise type information would otherwise not be available at runtime.

% \paragraph{Unified Runtime/Compile-time Reflection API.} Another important
% aspect of Scala's reflection library is the one-to-one correspondence between
% Scala Reflection's compile-time (\ie macros) and runtime APIs. Each API is
% parameterized on a so-called \verb|Universe|, an object which serves as the
% entry point to Scala reflection, and which provides all principal concepts
% used in reflection, such as \verb|Type|s, \verb|Tree|s, and
% \verb|Annotation|s. Depending on the task at hand, the choice between runtime
% and compile-time reflection is as easy as selecting either a compile-time or a
% runtime \verb|Universe|. As we will see, this enables maximum code
% reuse in that a fallback runtime pickler generation mechanism can be achieved
% by simply reusing the code for static generation, and parameterizing it on a
% runtime \verb|Universe|.

\subsection{Type Classes}
\label{sec:type-classes}

...

\subsection{Macros}
\label{sec:macros}

Scala reflection enables a form of metaprogramming which makes it possible for
programs to modify themselves at compile-time. This compile-time reflection is
realized in the form of hygenic macros \cite{Burmako2012}, which {\em expand}
at compile-time to manipulate abstract syntax trees (ASTs). In our framework, we make
use of two principal types of macros.

\paragraph{Macro defs.} Macro defs are methods that are transparently loaded
by the compiler and executed (or expanded) during compilation. A macro is
defined as if it is a normal method, but it is linked using the \verb|macro|
keyword to an additional method that operates on abstract syntax trees.

\begin{lstlisting}
def assert(x: Boolean, msg: String): Unit =
  macro assert_impl
def assert_impl(c: Context)
  (x: c.Expr[Boolean], msg: c.Expr[String]):
                            c.Expr[Unit] = ...
\end{lstlisting}

In the above, the parameters of \verb|assert_impl| are syntax
trees, which the body of \verb|assert_impl| will operate on, itself returning
an AST of type \verb|Expr[Unit]|. It is \verb|assert_impl| which is
expanded and evaluated at compile-time, its result is then inlined at the
callsite of \verb|assert| and the inlined result is typechecked
It is also important to note that implicit defs as described earlier
in Section \ref{sec:implicits} can be implemented as macros.

As we will see, these macros defs, coupled with implicits in Scala enable the
boilerplate-free usage of the Scala pickling framework at the pickling use-
site.

% \paragraph{Macro Annotations.} Unlike macro defs, macro annotations are capable
% of {\em adding members} to classes which carry their annotation.

% \begin{lstlisting}
% @withNewToString
% class D { ... }
% \end{lstlisting}

% The \verb|withNewToString| annotation is defined using a standard class
% definition by extending a special \verb|MacroAnnotation| marker trait, and by
% implementing a special \verb|transform| method as a macro:

% \begin{lstlisting}
% class withNewToString extends MacroAnnotation {
%   def transform = macro transform_impl
%   def transform_impl = { ... }
% }
% \end{lstlisting}

% The \verb|transform| macro implementation is passed the AST of the annotated class
% definition (the AST of ``\verb|class D { ... }|''), and returns a possibly changed AST
% as the new class definition (which could have added members, changed
% constructor parameters etc.)

\section{The Self-Assembly Pattern}
\label{sec:self-assembly-pattern}

high-level overview of the pattern. macros generate calls to \\\verb|implicitly[T]| and generate the bodies of implicit objects. the macro also inspects the type and based on that, generates nested \verb|implicitly[S]| calls. these calls are resolved either using regular implicits, or by expanding the implicit macro recursively.

Suppose the goal is to automatically generate type class instances for a type class \verb|Show[T]|.

To be able to generate suitable instances for all possible types for which \verb|Show[T]| can be defined, we put an implicit macro into the companion object of \verb|Show[T]|. The fact that the implicit macro is inside the companion object means that whenever an instance \verb|Show[S]| is requested, Scala's implicit lookup mechanism searches the members of the companion object \verb|Show| where it finds the implicit macro:

\begin{lstlisting}
object Show {
  implicit def generate[T]: Show[T] =
    macro genQuery[T]
}
\end{lstlisting}
\noindent
Thus, the implicit lookup mechanism inserts an invocation of the macro method
\verb|genQuery|. Being a macro, \verb|genQuery| returns an abstract syntax
tree instead of a (runtime) value. It is declared as follows:

\begin{lstlisting}
def genQuery[T : c.WeakTypeTag](c: Context):
  c.Tree = ...
\end{lstlisting}
\noindent
Note that in this declaration the type parameter \verb|T| is annotated with a
so-called \emph{context bound} \verb|c.WeakTypeTag|. The context bound is an
alternative way of adding a synthetic implicit parameter:

\begin{lstlisting}
def genQuery[T](c: Context)
  (implicit ev: c.WeakTypeTag[T]): c.Tree = ...
\end{lstlisting}
\noindent
The evidence parameter \verb|ev| of type \verb|c.WeakTypeTag[T]| provides
access to the full static type information of type \verb|T|. The
\verb|genQuery| macro inspects this type information to generate a value of
the following shape:

\begin{lstlisting}
implicit object $instanceName extends Show[T] {
  def mkString(visitee: T): String = $tree
}
$instanceName
\end{lstlisting}
\noindent
As required, the generated value has type \verb|Show[T]|. Hygiene requires the
macro to generate a fresh (term) name \verb|$instanceName|. The actual
implementation of the type class (\verb|$tree|) is generated by inspecting the
type tag.

\subsection{Inspecting the type parameter}

\subsection{Generation of nested implicitly calls}


\section{Language Extensions with the \texttt{selfassembly} Library}
\label{sec:language-extensions-library}

We provide re-usable building blocks of our approach in the form of a Scala
library.\footnote{The library has been developed and tested using Scala 2.11,
but it should be possible to use it also with Scala 2.10, since no features
particular to Scala 2.11 are used.}

The library provides a set of traits for expressing generic functions that are
either (a) queries or (b) transformations. Basically, a query generates type
class instances that traverse an object graph and return a single result of a
possibly different type. In contrast, a transformation generates type class
instances that perform a deep copy of an object graph, applying
transformations to reachable objects of selected types.

\section{Related Work}
\label{sec:related-work}

\cite{TemplateYourBoilerplate}

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{bib}

% \bibliographystyle{abbrvnat}

% % The bibliography should be embedded for final submission.

% \begin{thebibliography}{}
% \softraggedright

% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...

% \end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

