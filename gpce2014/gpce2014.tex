%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{listings,xspace}
\usepackage{amsmath}
\usepackage{fontspec}
\usepackage{xcolor}

\lstdefinelanguage{Scala}%
{morekeywords={abstract,case,catch,char,class,%
    def,else,extends,final,%
    if,import,%
    match,module,new,null,object,override,package,private,protected,%
    public,return,super,this,throw,trait,try,type,val,var,with,implicit,%
    macro,sealed,%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

% \lstset{language=Scala,%
%   mathescape=true,%
%   columns=[c]fixed,%
%   basewidth={0.5em, 0.40em},%
%   basicstyle=\tt,%
%   xleftmargin=0.0cm
% }

% \lstset{tabsize=2,
% basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont,
% commentstyle=\itshape\rmfamily,
% numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=scala,moredelim=[il][\sffamily]{?},mathescape=false,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapechar=@, morekeywords=[1]{let,fn,val},deletekeywords={for},classoffset=0,belowskip=\smallskipamount
% }

\lstset{tabsize=2,
basicstyle=\ttfamily\fontsize{10pt}{1em}\selectfont,
commentstyle=\itshape\rmfamily,
language=scala,moredelim=[il][\sffamily]{?},mathescape=false,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapechar=@, morekeywords=[1]{let,fn,val},deletekeywords={for},classoffset=0,belowskip=\smallskipamount
}

\newcommand{\todo}{{\bf \colorbox{red}{\color{white}TODO:}}}
\newcommand{\ie}{{\em i.e.,~}}
\newcommand{\eg}{{\em e.g.,~}}
\newcommand{\term}[1]{\mbox{\texttt{#1}}}
\newcommand{\itl}[1]{\mbox{\textit{#1}}}

% commas and semicolons
\newcommand{\comma}{,\,}
\newcommand{\commadots}{\comma \ldots \comma}
\newcommand{\semi}{;\mbox{;};}
\newcommand{\semidots}{\semi \ldots \semi}

% spacing
\newcommand{\gap}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

% figures
\newcommand{\figurebox}[1]
        {\fbox{\begin{minipage}{\textwidth} #1 \medskip\end{minipage}}}
\newcommand{\twofig}[3]
        {\begin{figure*}[t]#3\ \hrulefill\
        \caption{\label{#1}#2}\end{figure*}}
\newcommand{\boxfig}[3]
        {\begin{figure*}\figurebox{#3\caption{\label{#1}#2}}\end{figure*}}
\newcommand{\figref}[1]
        {Figure~\ref{#1}}

% arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}


\begin{document}

\setmainfont[Mapping=tex-text]{Times New Roman}
\setmonofont[Scale=0.8,BoldFont={Consolas Bold}]{Consolas}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{GPCE'14}{September 14--15, 2014, V\"{a}ster\r{a}s, Sweden}
\copyrightyear{2014}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish,
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers,
                                  % short abstracts)

% \titlebanner{banner above paper title}        % These are ignored unless
% \preprintfooter{short description of paper}   % 'preprint' option specified.

% Materialization: Pluggable Type System Extensions
% Generative Self-Assembly: Language Extensions and Datatype Generic Programming
% Self-Assembling Type System Extensions
% Type System Extensions Through Generative Self-Assembly

\title{Generative Self-Assembly: Language Extensions and Datatype Generic Programming}
% \subtitle{Subtitle Text, if any}

\authorinfo{Heather Miller}
           {EPFL}
           {heather.miller@epfl.ch}
\authorinfo{Philipp Haller}
           {Typesafe, Inc.}
           {philipp.haller@typesafe.com}
\authorinfo{Bruno C. d. S. Oliveira}
           {The University of Hong Kong}
           {bruno@cs.hku.hk}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
\terms
term1, term2

\keywords
keyword1, keyword2

\section{Introduction}

The text of the paper begins here.~\cite{ComparingGPHaskellRodriquez, ComparingGPHaskellHinze, ScalaGenericProgrammers, RepLib, OOGP}

Implicits are a huge deal, because they provide \textbf{extensibility.} Users can easily customize generated code by making use of implicits in Scala.

Using this approach, we have implemented a full-featured serialization framework for Scala. Full-featured in that it handles all object-oriented concerns, such as subtyping polymorphism, object identity, etc. As well as advanced features of the type system. This is not a toy example. It's general!

Contributions.

Implicits and macros powerful tools for doing generative programming. In fact, so powerful, that we can do more than inlined and performant datatype generic programming. We can use these generative techniques to extend the compiler and type system in local but powerful ways.

\begin{itemize}
\item library
\item pattern
\end{itemize}

We first describe what we call the ``self-assembly pattern'' -- a technique for combining implicits and macros to generate complex in Section~\ref{sec:self-assembly-pattern} to generate type class instances.

\section{Background}
\label{sec:background}

\subsection{Singletons}
\label{sec:singletons}

...

\paragraph{Companion Objects} ...


\subsection{Implicits}
\label{sec:implicits}

\paragraph{Implicit Parameters.} In Scala, it is possible to select values
automatically based on type. These capabilities are enabled when using the
\term{implicit} keyword. For example, a method \term{log} with multiple
parameter lists may annotate their last parameter list using the
\term{implicit} keyword.\footnote{Example taken from~\cite{Oliveira2010}.}

\begin{lstlisting}
def log(msg: String)(implicit o: PrintStream) =
  o.println(msg)
\end{lstlisting}

This means that in an invocation of \term{log}, the implicit argument list may
be omitted if, for each parameter of that list, there is exactly one value of
the right type in the {\em implicit scope}. The implicit scope is an
adaptation of the regular variable scope; imported implicits, or implicits
declared in an enclosing scope are contained in the implicit scope of a method
invocation.

\begin{lstlisting}
    implicit val out = System.out
    log("Does not compute!")
\end{lstlisting}

In the above example, the implicit val \term{out} is in the implicit scope of
the invocation of \term{log}; since it has the right type, it is automatically
selected as an implicit argument.

%\todo Maybe we should change this example? It's out of Bruno's paper, and he's
%on the committee, he'll probably review our paper.

%\todo Talk about how we use implicit values in our framework here.

\paragraph{Implicit Conversions.} Implicit conversions can be thought of as
methods which, like implicit parameters, can be implicitly selected (\ie
invoked) based upon their type, and whether or not they are present in
implicit scope. As with implicit parameters, implicit conversions also carry
the \term{implicit} keyword before their declaration.

\begin{lstlisting}
 implicit def intWrapper(x: Int): Message =
    new Message {
      def message: String = "secret message!"
    }
\end{lstlisting}

In the example above, assuming there exists an abstract class \term{Message}
with abstract method \term{message}, the implicit conversion
\term{intWrapper} will be triggered when a method called \term{message}
is called on an \term{Int}. That is, simply calling
\term{39.message} will result in ``secret message!'' being
returned. Since the implicit conversion has the effect of adding a
``new'' method to type \term{Int}, \term{message} is typically called an
{\em extension method}. In our framework we use implicit conversions,
for example, for adding a \term{pickle} method to arbitrary objects.

% cite Adriaan's and Bruno's OOPSLA paper. Where? How?
% Example of a type class: maybe Ordering type class of std lib?
% Include info on importing implicit values, and implicit resolution by scoping.
% Example of a plain implicit parameter: could use implicit ExecutionContext in futures

% \subsection{Reflection}
% \label{sec:reflection}

% Reflection is the ability of a program to inspect, and possibly even modify
% itself at runtime. Before Scala 2.10, Scala did not have any reflection
% capabilities of its own. Instead, one could use Java reflection which provided
% basic but limited runtime reflection capabilities. In Scala 2.10, a new
% reflection library was introduced not only to address the shortcomings of
% Java's runtime reflection on Scala-specific and generic types, but to also add
% a more powerful toolbox of general reflective capabilities to Scala. Along
% with full-featured runtime reflection for Scala types and generics, Scala 2.10
% also ships with compile-time reflection capabilities, in the form of macros
% (covered in Section \ref{sec:macros}), as well as the ability to reify Scala
% expressions into abstract syntax trees.

% \paragraph{TypeTags.} One aspect of runtime reflection that was introduced in
% Scala 2.10 is the notion of \verb|TypeTag|s. As with other JVM languages,
% Scala's types are erased at compile time. \verb|TypeTag|s can be thought of as
% objects which carry along all type information available at compile time, to
% runtime. As we will see, \verb|TypeTag|s will prove to be invaluable in
% situations where precise type information would otherwise not be available at runtime.

% \paragraph{Unified Runtime/Compile-time Reflection API.} Another important
% aspect of Scala's reflection library is the one-to-one correspondence between
% Scala Reflection's compile-time (\ie macros) and runtime APIs. Each API is
% parameterized on a so-called \verb|Universe|, an object which serves as the
% entry point to Scala reflection, and which provides all principal concepts
% used in reflection, such as \verb|Type|s, \verb|Tree|s, and
% \verb|Annotation|s. Depending on the task at hand, the choice between runtime
% and compile-time reflection is as easy as selecting either a compile-time or a
% runtime \verb|Universe|. As we will see, this enables maximum code
% reuse in that a fallback runtime pickler generation mechanism can be achieved
% by simply reusing the code for static generation, and parameterizing it on a
% runtime \verb|Universe|.

\subsection{Type Classes}
\label{sec:type-classes}

...

\subsection{Macros}
\label{sec:macros}

Scala reflection enables a form of metaprogramming which makes it possible for
programs to modify themselves at compile-time. This compile-time reflection is
realized in the form of hygenic macros \cite{Burmako2012}, which {\em expand}
at compile-time to manipulate abstract syntax trees (ASTs). In our framework, we make
use of two principal types of macros.

\paragraph{Macro defs.} Macro defs are methods that are transparently loaded
by the compiler and executed (or expanded) during compilation. A macro is
defined as if it is a normal method, but it is linked using the \verb|macro|
keyword to an additional method that operates on abstract syntax trees.

\begin{lstlisting}
def assert(x: Boolean, msg: String): Unit =
  macro assert_impl
def assert_impl(c: Context)
  (x: c.Expr[Boolean], msg: c.Expr[String]):
                            c.Expr[Unit] = ...
\end{lstlisting}

In the above, the parameters of \verb|assert_impl| are syntax
trees, which the body of \verb|assert_impl| will operate on, itself returning
an AST of type \verb|Expr[Unit]|. It is \verb|assert_impl| which is
expanded and evaluated at compile-time, its result is then inlined at the
callsite of \verb|assert| and the inlined result is typechecked
It is also important to note that implicit defs as described earlier
in Section \ref{sec:implicits} can be implemented as macros.

As we will see, these macros defs, coupled with implicits in Scala enable the
boilerplate-free usage of the Scala pickling framework at the pickling use-
site.

% \paragraph{Macro Annotations.} Unlike macro defs, macro annotations are capable
% of {\em adding members} to classes which carry their annotation.

% \begin{lstlisting}
% @withNewToString
% class D { ... }
% \end{lstlisting}

% The \verb|withNewToString| annotation is defined using a standard class
% definition by extending a special \verb|MacroAnnotation| marker trait, and by
% implementing a special \verb|transform| method as a macro:

% \begin{lstlisting}
% class withNewToString extends MacroAnnotation {
%   def transform = macro transform_impl
%   def transform_impl = { ... }
% }
% \end{lstlisting}

% The \verb|transform| macro implementation is passed the AST of the annotated class
% definition (the AST of ``\verb|class D { ... }|''), and returns a possibly changed AST
% as the new class definition (which could have added members, changed
% constructor parameters etc.)

\section{The Self-Assembly Pattern}
\label{sec:self-assembly-pattern}

high-level overview of the pattern. macros generate calls to \\\verb|implicitly[T]| and generate the bodies of implicit objects. the macro also inspects the type and based on that, generates nested \verb|implicitly[S]| calls. these calls are resolved either using regular implicits, or by expanding the implicit macro recursively.

\subsection{Query pattern}

We start with a simplified view of types in Scala. In subsequent sections we
show how to generalize this view to richer types.

\begin{figure}
  \centering
$\ba[t]{l@{\hspace{2mm}}l@{\hspace{2mm}}}
T    ::= & \texttt{sealed trait}~C~\{~\bar{m}~\} \\
\gap ~|~ & \texttt{case class}~C(v~p_1: D_1, \ldots, v~p_n: D_n)~\{~\bar{m}~\} \\
\gap     & \texttt{~~extends}~E_1~\texttt{with}~ \ldots ~\texttt{with}~E_m \\
v    ::= & \texttt{var} \\
\gap ~|~ & \epsilon \\
m    ::= & \ldots \\
\ea$
  \caption{Grammar for simple datatypes in Scala.}
  \label{fig:type-syntax}
\end{figure}

In this first step we consider only closed ADT-style datatypes in Scala, which
can be described using the grammar in Figure~\ref{fig:type-syntax}.\footnote{Case
classes are considered to be final, even though in the current version of Scala
they can technically be extended; extension is deprecated, though.} For example,
an ADT for binary trees storing \verb|Int|s could be implemented as follows:

\begin{lstlisting}
sealed trait Tree
case class Fork(left: Tree, right: Tree)
  extends Tree
case class Leaf(elem: Int) extends Tree
\end{lstlisting}
\noindent
The goal of the self-assembly pattern is to derive type class instances of a
given type class for all supported datatypes (for now, the types in
Figure~\ref{fig:type-syntax}). The pattern assumes that the type class has the
following shape:
\begin{lstlisting}
trait Show[T] {
  def show(visitee: T): String
}
\end{lstlisting}
\noindent
Importantly, for now we only consider type classes with a single type
parameter. Moreover, the type class is supposed to have a single (abstract)
method that has a single parameter of the generic type and some return type
that (a) does not depend on the generic type, and (b) is a monoid.

Given a type class, say \verb|Show[T]|, and a datatype, say \verb|Tree|, the
self-assembly pattern systematically derives a type class instance
\verb|Show[Tree]|. Applying the pattern consists of the following steps:

\begin{enumerate}

\item Definition of an \emph{implicit object} that extends the type of the
      type class instance (\eg \verb|Show[Tree]|).

\item Looking up implicit instances for the components of the type.

\item Implementation of the type class according to the shape of the type
      using the component instances.

\item Introducing the implicit object into the right scope, so that implicit
      search locates it.

\end{enumerate}
\noindent
In the following we elaborate on each step; first, we consider a datatype
whose declaration has the shape:

\begin{math}
\texttt{case class}~C(p_1: D_1, \ldots, p_n: D_n)~\{~\bar{m}~\} \\
\texttt{~~~~~extends}~E_1~\texttt{with}~ \ldots ~\texttt{with}~E_m
\end{math}

The first step is the definition of an implicit object extending
\verb|Show[C]|:

\begin{lstlisting}
implicit object CShowInstance extends Show[C] {
  def show(visitee: C): String = ...
}
\end{lstlisting}
\noindent
We derive an implementation of the \verb|show| method by looking up type class
instances for each of the class parameters $p_i$ of $C$. Since type class
instances are declared as implicit values in Scala, we can use the following
method \verb|implicitly| to look up type class instances:

\begin{lstlisting}
def implicitly[T](implicit e: T): T = e
\end{lstlisting}
\noindent
Thus, an invocation \verb|implicitly[Show[D_i]]| returns an instance of
\verb|Show| for type \verb|D_i|.\footnote{The \texttt{implicitly} method is
defined in the \texttt{Predef} singleton object in Scala's standard library.}

Using \verb|implicitly| we can implement the type class instance as follows.
For each class parameter $p_i$ of $C$, we obtain the corresponding type class
instance (of type \verb|Show[D_i]|), and use it to obtain a result of type
\verb|String|. Since \verb|String| is a monoid, we can reduce the results
obtained for all parameters into a single \verb|String|:

\begin{lstlisting}
var result: String = ""
val inst_1 = implicitly[Show[D_1]]
result = result + inst_1.show(visitee.p_1)
...
val inst_n = implicitly[Show[D_n]]
result = result + inst_n.show(visitee.p_n)
\end{lstlisting}
\noindent
Making the \verb|CShowInstance| object \verb|implicit| enables support for
\emph{recursive types:} if one of the types $D_i = C$, then the corresponding
invocation \verb|implicitly[Show[D_i]]| simply returns \verb|CShowInstance|.

\subsubsection{Object identity}

In object-oriented languages like Scala, it is important to take \emph{object
identity} into account. Already simple datatypes as shown in
Figure~\ref{fig:type-syntax} permit cycles in object graphs via re-assignable
fields (using the \verb|var| modifier). It is therefore important to keep
track of objects that have already been visited to avoid infinite recursion.

To enable the detection of cycles in object graphs, we keep track of all
``visited'' objects during the object graph traversal performed by a type
class instance. However, it is not sufficient to maintain a single, global set
of visited objects, since implementations of one type class might depend on
other type classes; different type class instances could therefore interfere
with each other when accessing the same global set (yielding nonsensical
results). Thus, it is preferable to pass this set of visited objects on the
call stack. With the mechanics introduced so far, this is not possible.

To enable passing an additional context (the set of visited objects) on the call stack,
we require type classes to extend \\\verb|Queryable[T, R]|:

\begin{lstlisting}
trait Queryable[T, R] {
  def apply(visitee: T, visited: Set[Any]): R
}
\end{lstlisting}
\noindent
The \verb|Queryable[T, R]| trait declares an \verb|apply| method with an
additional \verb|visited| parameter (compared to the trait of the type class),
which is passed the set of visited objects. This extra method allows us to
distinguish between top-level invocations of type class methods and inner
invocations (of \verb|apply|). The only downside is that custom type class
instances are slightly more verbose to define, although the implementation of
\verb|apply| can typically be a trivial forwarder.

For example, consider the \verb|Show[T]| type class, now extending
\verb|Queryable[T, R]|:
\begin{lstlisting}
trait Show[T] extends Queryable[T, String] {
  def show(visitee: T): String
}
\end{lstlisting}
\noindent
A type class instance for integers can be implemented as follows:
\begin{lstlisting}
implicit val intHasShow = new Show[Int] {
  def show(visitee: Int): String = "" + x
  def apply(visitee: Int, visited: Set[Any]) =
    show(visitee)
}
\end{lstlisting}
\noindent
Note that the implementation of \verb|apply| is trivial.

To enable the detection of cycles in object graphs it is necessary to
adapt the implementation of the implicit object as follows.

\begin{lstlisting}
implicit object CShowInstance extends Show[C] {
  def show(visitee: C): String =
    apply(visitee, Set[Any]())
  def apply(visitee: C, visited: Set[Any]) =
    ...
}
\end{lstlisting}
\noindent
Note that an invocation of \verb|show| is treated as a \emph{top-level
invocation} forwarding to \verb|apply| passing an empty set of visited
objects. Crucially, when applying the type class instances for the class
parameters of $C$, instead of invoking \verb|show| directly, we invoke
\verb|apply| passing the \verb|visited| set extended with the current object
(\verb|visitee|).

\begin{lstlisting}
var result: String = ""
if (!visited(visitee.p_1)) {
  val inst_1 = implicitly[Show[D_1]]
  result = result +
   inst_1.apply(visitee.p_1, visited + visitee)
}
...
if (!visited(visitee.p_n)) {
  val inst_n = implicitly[Show[D_n]]
  result = result +
   inst_n.apply(visitee.p_n, visited + visitee)
}
\end{lstlisting}
\noindent


\subsection{Generation using macros}
Suppose the goal is to automatically generate type class instances for a type class \verb|Show[T]|.

To be able to generate suitable instances for all possible types for which \verb|Show[T]| can be defined, we put an implicit macro into the companion object of \verb|Show[T]|. The fact that the implicit macro is inside the companion object means that whenever an instance \verb|Show[S]| is requested, Scala's implicit lookup mechanism searches the members of the companion object \verb|Show| where it finds the implicit macro:

\begin{lstlisting}
object Show {
  implicit def generate[T]: Show[T] =
    macro genQuery[T]
}
\end{lstlisting}
\noindent
Thus, the implicit lookup mechanism inserts an invocation of the macro method
\verb|genQuery|. Being a macro, \verb|genQuery| returns an abstract syntax
tree instead of a (runtime) value. It is declared as follows:

\begin{lstlisting}
def genQuery[T : c.WeakTypeTag](c: Context):
  c.Tree = ...
\end{lstlisting}
\noindent
Note that in this declaration the type parameter \verb|T| is annotated with a
so-called \emph{context bound} \verb|c.WeakTypeTag|. The context bound is an
alternative way of adding a synthetic implicit parameter:

\begin{lstlisting}
def genQuery[T](c: Context)
  (implicit ev: c.WeakTypeTag[T]): c.Tree = ...
\end{lstlisting}
\noindent
The evidence parameter \verb|ev| of type \verb|c.WeakTypeTag[T]| provides
access to the full static type information of type \verb|T|. The
\verb|genQuery| macro inspects this type information to generate a value of
the following shape:

\begin{lstlisting}
implicit object $instanceName extends Show[T] {
  def mkString(visitee: T): String = $tree
}
$instanceName
\end{lstlisting}
\noindent
As required, the generated value has type \verb|Show[T]|. Hygiene requires the
macro to generate a fresh (term) name \verb|$instanceName|. The actual
implementation of the type class (\verb|$tree|) is generated by inspecting the
type tag.

\subsection{Inspecting the type parameter}

\subsection{Generation of nested implicitly calls}


\section{Language Extensions with the \texttt{selfassembly} Library}
\label{sec:language-extensions-library}

We provide re-usable building blocks of our approach in the form of a Scala
library.\footnote{The library has been developed and tested using Scala 2.11,
but it should be possible to use it also with Scala 2.10, since no features
particular to Scala 2.11 are used.}

The library provides a set of traits for expressing generic functions that are
either (a) queries or (b) transformations. Basically, a query generates type
class instances that traverse an object graph and return a single result of a
possibly different type. In contrast, a transformation generates type class
instances that perform a deep copy of an object graph, applying
transformations to reachable objects of selected types.

\section{Related Work}
\label{sec:related-work}

\cite{TemplateYourBoilerplate}

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.

% \acks

% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{bib}

% \bibliographystyle{abbrvnat}

% % The bibliography should be embedded for final submission.

% \begin{thebibliography}{}
% \softraggedright

% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
% P. Q. Smith, and X. Y. Jones. ...reference text...

% \end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

