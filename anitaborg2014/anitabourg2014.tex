% acmtr.tex
% revised 1/20/97
% updated 06/01/01
% $Header: acmtr.tex,v 1.5 2/14/96 11:07:57 boyland Exp $

\documentclass[acmtocl]{acmtrans2m}
%&t&{\tt #}&
%&v&\verb|#|&

\acmVolume{2}
\acmNumber{3}
\acmYear{01}
\acmMonth{09}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{subfig}
% \usepackage{natbib}
\usepackage[citestyle=numeric, maxbibnames=20, minbibnames=20]{biblatex}
\usepackage{url,fancyhdr}

\addtolength{\oddsidemargin}{-.8in}
\addtolength{\evensidemargin}{-.8in}
\addtolength{\textwidth}{1.6in}

% comments and notes
\newcommand{\comment}[1]{}
\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

\newcommand{\todo}{{\bf \colorbox{red}{\color{white}TODO:}}}
\newcommand{\ie}{{\em i.e.,~}}
\newcommand{\eg}{{\em e.g.,~}}

\addbibresource{bib.bib}

\newcommand{\BibTeX}{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\newcommand{\smbox}[1]{\mbox{\scriptsize #1}}

\setlength{\parskip}{10pt}
\setlength\parindent{0pt}

%%% Width of all Gnuplot figures
\newlength{\gnuplotWidth}
\setlength{\gnuplotWidth}{.98\columnwidth}

%%% Where figures are located
\graphicspath{{include/}}

\definecolor{HeatherBlue}{rgb}{0,0,0}
\definecolor{DarkBlue}{HTML}{265B8C}

%% hyperlinks
\usepackage{savesym}
\savesymbol{pdfbookmark}
\usepackage[colorlinks=true,urlcolor=DarkBlue,citecolor=DarkBlue]{hyperref}
\restoresymbol{HR}{pdfbookmark}

\markboth{\textcolor{Black}{Heather Miller}}{\textcolor{Black}{Anita Borg Scholarship}}

\title{{\color{Black}Anita Borg Scholarship}}
\author{\textcolor{Black}{\textbf{Heather Miller}}}

\begin{document}

\setmonofont[Mapping=tex-text,Scale=0.9]{Inconsolata}
%\setcounter{page}{111}
%
%\begin{bottomstuff}
%\end{bottomstuff}
\maketitle

{\em Note to reviewers: While I currently live in and am pursuing a PhD in
Switzerland, I was born in, raised in, and went to college in the US. Though I
live in Switzerland now, I am still very much a stranger to the cultural norms
of this country, and to high school and undergraduate education. For these
reasons, I'll be answering questions such as ``what cultural factors in your
country influence fewer women to select technical degrees?'' from the
perspective of the US, as it is the only country I have deep intuitions and
experiences with.}

\section*{\textbf{Essay 4:} Anita's 50/50 by 2020 Initiative}

\textbf{Computing should be seen as creative and captivating.}
After all, computer science is at heart the of beguiling and mind-bending new
fields like {brain-computer} interfacing -- where with non-invasive imaging
modalities such as EEG, users are able to play video games, type on a virtual
keyboard, pilot robots, and more, using thoughts alone.

Why is it then that popular culture depicts those who work in the field of
computing so undesirably? Harrowing images abound; men sporting apparel
fashionable in IBM's hallways during the nineties, wearing glasses with
aviator-sized lenses and thick clear plastic frames, hunched before a large
and yellowed CRT monitor. Or perhaps worse, the more recent and unfortunate
stereotype of male developers as a {single-bodied} {beer-guzzling},
{pizza-swallowing} mass, famously gender/sexuality/etc. insensitive at
hackathons and conferences -- an image that is sometimes a reality in
some of Silicon Valley's communities and which begot the {now-standard} code
of conduct at developer events.

With images like these permeating popular culture, it's no wonder that teenage
girls might be deterred from selecting computer science as a major in college.
It's natural to imagine that they might feel like they wouldn't fit in,
despite potentially even having an innate inclination for mathematics,
computers, or technology. In fact,
\href{https://www.girlscouts.org/research/pdf/generation\_stem\_full\_report.pdf}{Girl Scouts of America found}
\cite{Girlscouts} that a whopping 74\% teenage girls are interested in {\em
Science, Technology, Engineering, and Mathematics} (STEM) fields, but about
half feel that STEM isn't a typical career path for girls. 57\% of teenage
girls surveyed say that if they went into a STEM career, they feel they'd have
to work harder than a man to be taken seriously. Worse, 13\% of those
interested in pursuing a STEM career say it's their first choice.

This number ripples surprisingly well through to reality. Here at EPFL, for
instance, our bachelors and masters programs are typically comprised of
$\approx10\%$ women. Our PhD program fares slightly better -- due to
initiative to encourage applications from women, we can proudly tout a
student body comprised $\approx15\%-20\%$ of women.

Perhaps we should instead ask ourselves why we don't do more to change how
young people perceive our field.

[COMPUTING SHOULD BE CAPTIVATING AND CREATIVE]
Outfits like MIT's media lab regularly set out to change the way we interact with technology, from
Make magazine and the worldwide movement of events like ``Makers Faires''

% \comment{
% Building web applications designed to serve the needs of millions of users
% presents several challenges:

% \begin{itemize}

% \item {\em Concurrency.} Enabling a web application to scale to millions of
%   users is a huge concurrent programming challenge. It requires eliminating
%   bottlenecks through an event-driven architecture where all resources are
%   accessed asynchronously.

%   Currently, the landscape of concurrency abstractions
%   is fragmented in a way where it is often unclear which concurrency abstraction
%   is best-suited for a given coordination task. Moreover, combining different
%   abstractions is complicated and prone to concurrency hazards such as race
%   conditions.

% \item {\em Distribution.} Rapidly growing work loads with unpredictable spikes
%   have to be distributed on large clusters. In addition, typical applications
%   need to manage a heterogeneous mix of distributed back-end services for data
%   access (distributed file systems, SQL/NoSQL data storage), data processing
%   (e.g., MapReduce), and highly-reliable distributed synchronization, among
%   others.

%   Ensuring reliability under such conditions is extremely challenging.
%   Properties such as eventual consistency of data managed in the cloud further
%   complicate reasoning about system properties.

% \item {\em Interoperability.} Engineering the (web-based) front end typically
%   requires a completely different set of technologies and skills compared to
%   engineering the (cluster-based) back end. As a result, interoperability
%   between the front end and the back end is limited to ad-hoc, untyped
%   interfaces which makes it extremely difficult to ensure system-wide safety and
%   security properties.

%   Attempts to allow ``full stack'' development with a
%   single programming language used for both the front end and the back end so
%   far have required resorting to the least common denominator, JavaScript, thus
%   giving up static type safety, even for critical server infrastructure.

% \item {\em Data Access.} Data is often produced and consumed in the form of
%   real-time, asynchronous streams. These streams originate from both internal
%   and external data sources, introducing challenges for concurrency and
%   distribution. Data is typically provided in a multitude of formats, leading
%   to large amounts of boilerplate required for converting data between
%   different formats, often losing type information in the process.

% \end{itemize}
% }

% \comment{
%   \item Engineering the (web-based) front end typically requires a completely
%   different set of technologies and skills compared to engineering the
%   (cluster-based) back end. Attempts to reduce the number of programming
%   technologies used, in an effort to reduce costs, so far have required
%   resorting to the least common denominator, JavaScript, thus giving up
%   static type safety, even for critical server infrastructure.

% \item The cluster-based back end typically requires coordination of a variety of
%   \emph{concurrent and parallel services} for data access (distributed file systems,
%   SQL/NoSQL data storage), data processing (e.g., MapReduce), and highly-reliable
%   distributed synchronization, among others.

% \item Data is often produced and consumed in the form of real-time, asynchronous
%   streams. These streams originate from both internal and external data sources,
%   introducing challenges for concurrency and distribution. Data is typically provided in a multitude
%   of formats, leading to large amounts of boilerplate required for converting
%   data between different formats.

% \item Services are built using low-level tools with ad-hoc interfaces for
%   interoperability between different technologies. This makes it extremely
%   difficult to ensure system-wide safety and security properties. For example,
%   communication between clients and servers is typically untyped.
% }

% \comment{
% These challenges put an enormous pressure on the programming languages,
% frameworks, and tools we use to build such software systems.}


% The software industry is undergoing a fundamental shift toward Software-as-a-Service
% making applications accessible from anywhere via any device. Web
% browsers, traditionally ``thin'' clients, have become powerful enough to host
% even standard-bearers like word processors. This shift is radically changing
% the technologies and skills needed by software engineers to build this new
% generation of cloud-hosted applications:

% \comment{due to the underlying hardware and software infrastructure:}

% \begin{enumerate}

% \item The requirement of applications to scale to high volumes of users or data
% makes it indispensable to distribute work loads across large clusters.
% Practical programming models for this new cluster computing setting are still
% at an early stage, and often leave programmers no choice other than solving
% difficult concurrency problems using low-level abstractions, resulting in bugs that
% are hard to diagnose.

% \item The runtime platform for these new applications is fundamentally
% heterogeneous. While cluster-side code runs on ``traditional'' runtimes like
% the Java Virtual Machine, client-side code typically runs on markedly
% different execution engines for dynamic languages like JavaScript.
% However, enforcing safety and security properties is very difficult in distributed, multi-language
% applications.

% \end{enumerate}

% \comment{This makes it very difficult to enforce safety
% and security properties, since growing portions of applications have to be kept consistent
% while being implemented in different programming languages.}

% \comment{be
% implemented in different programming languages.
% across entire applications, since }

% \comment{This makes it very difficult to enforce safety
% and security properties across both the client and the cluster side of an
% application.}

% \comment{
% I believe the challenges of this new cloud computing platform have the
% potential to fundamentally change future programming technology. A significant
% part of my research has been on programming abstractions to simplify
% concurrency and distribution, as well as their efficient implementation. My
% projects have regularly resulted in artifacts proven in wide production use.
% Both research and production environments benefit from embedding new
% programming models in general-purpose programming languages. To enable a
% richer class of embedded domain-specific languages I have worked on suitable
% language extensions, in particular for improving debugging and profiling
% capabilities. The rich topic of concurrent programming also gave me an
% opportunity to revisit foundational questions in type-and-effect systems
% (e.g., how to statically reason about object references) which has had a major
% impact on a new generation of approaches to structured aliasing in object-oriented
% programming languages.}

% This new cloud computing setting has been an ideal application area for much
% of my previous research. I have contributed to advances in both simpler,
% scalable concurrency and distribution, and programming languages for targeting
% heterogeneous platforms. My work has ranged from theoretical foundations to
% programming models and artifacts proven in wide production use. I believe the
% challenges of engineering reliable, scalable, and responsive systems and
% applications have the potential to change future programming technology in
% significant ways that will benefit not only cloud-hosted software.

% \comment{, but also
% software for ``big data'' applications, mobile and embedded software, and even
% hardware/software co-design}

% With Scala Actors~\cite{ActorsJournal,ActorsBook} I integrated the high-level
% actor concurrency model into the
% Scala language, through an embedded domain-specific language (DSL). Besides
% serving as a basis for subsequent research of my own
% (\eg \cite{Joins,Menthor}), the project has
% supported a substantial body of highly-visible research of others, \eg on
% formal analysis of Scala actor programs. As part of Scala's standard library
% Scala Actors have been proven in numerous production environments such as
% Twitter's core messaging system. The rich topic of concurrent programming gave me an opportunity to
% revisit foundational questions in type-and-effect systems (\eg how to
% statically reason about object references), resulting in a new uniqueness type
% system~\cite{Uniqueness} based on static capabilities. The type system has been a major
% influence (discussed in~\cite{GordonPPBD12}) on a variant of C\# for systems
% programming in development at Microsoft, in particular with respect to side-effect
% tracking and isolation. At Typesafe I led the specification of Scala's futures,
% a new concurrency package at the core of frameworks like Play, powering the
% websites of companies like LinkedIn and the Guardian. I have presented this
% and further work on asynchronous programming~\cite{AsyncSIP} at leading industrial conferences
% such as Strange Loop.

% \comment{I am also the main author of a book on Scala
% Actors. }

% \comment{A paper published at OOPSLA 2012~\cite{GordonPPBD12} discusses the close
% relationship to my work in-depth.}

% \comment{
% videos of
% my presentations have been published by InfoQ,\footnote{See
% \texttt{http://www.infoq.com/author/Philipp-Haller}} a web-based publication
% on enterprise software development with over 700'000 unique visitors per
% month.}

% \comment{contributed, in roles such as project and specification lead, to
% the design and development of concurrency libraries}

% \comment{
% I have also
% worked on domain-specific languages (DSLs), with a particular focus on
% language support for embedding DSLs in general-purpose programming languages,
% as well as tool support for debugging and profiling. The rich topic of
% concurrent programming gave me an opportunity to revisit foundational
% questions in type-and-effect systems (e.g., how to statically reason about
% object references) which has had a major impact on new approaches to
% structured aliasing in object-oriented programming languages.}

% \comment{The artifacts that I developed
% as part of these projects are being used by thousands of professional software
% developers.}

% \comment{
% Guided by the desire to significantly simplify programming software
% systems satisfying such stringent requirements, my main research
% projects have been along two lines: (1) the design and implementation
% of programming abstractions for concurrent and parallel programming,
% and (2) type-and-effect systems
% for checking the safety of imperative object-oriented programs with
% aliasing. In addition, I have worked on domain-specific languages
% (DSLs), with a particular focus on language support for embedding DSLs
% in general-purpose programming languages, as well as tool support for
% debugging and profiling.}

% \comment{
% My main research projects have all been carried out directly connected to the
% development of the Scala programming language. The features, libraries, and
% tools that I developed as part of these projects are being used by thousands
% of professional software developers. For example, the development of Scala
% Actors, one of my main projects, has been a significant influence on the
% general trend towards actor-based programming on the Java Virtual Machine;
% Scala is commonly cited as a language embracing actors as its main concurrency
% model. This trend continues to have a major impact on commercial software
% development.}

% Throughout these projects, my research approach has been (a) to identify a
% problem for which no satisfactory solution exists in mainstream software
% development (for example, the problem of statically enforcing the isolation of
% concurrent processes); (b) to search for solutions that are simple, elegant,
% reusable, and widely applicable; and (c) to try to generalize the problem as
% much as possible to increase the applicability of its solution. Moreover, I
% believe that practical, mature research results should be introduced in real
% programming languages and systems. Some of my projects have reached a level of
% maturity where this has been possible in the context of the mainline
% distribution of the Scala programming language. Other projects are more
% exploratory and require more research until truly practical solutions are
% discovered. I am also very interested in empirical studies to guide some of my
% future research. I believe carefully-designed empirical studies have the
% potential to significantly increase our understanding of the role of
% programming languages in practical software engineering; they might also help
% discover new real-world challenges of current programming technology.


% \comment{
% they
% while ensuring the problems we are working on are relevant

% it
% can ensure the problems I am working on are relevant to

% real-world programming
% languages and software engineering.}



% % \section*{CONCURRENT AND PARALLEL PROGRAMMING}
% % \section{Concurrent and Parallel Programming}
% \section*{Concurrent and Parallel Programming}

% \textsc{Actors.} As part of my thesis work I created Scala Actors
% \cite{ActorsJournal,ActorsBook}. The system demonstrated for the first time
% how the actor model of concurrency can be integrated in mainstream
% technologies, in particular the Java Virtual Machine, in a way that scales to
% a very large number of lightweight concurrent processes. Scala Actors also
% demonstrated as one of the first systems how to provide an expressive, high-level
% programming interface for concurrency as a DSL
% embedded in a general-purpose programming language. Scala's original actor
% library has been part of the Scala mainline distribution since September 2006;
% during that time Scala actors have influenced a considerable amount of further
% research on actors, and the framework has also been proven in
% production environments such as Twitter's Kestrel message queue system which
% comfortably sustained record-high traffic on its website during Obama's first
% inauguration in 2008\footnote{See
% \texttt{http://blog.twitter.com/2009/01/inauguration-day-on-twitter.html}} amongst
% many others. From 2009, Jonas Bon\'er {\em et al.} have been working on a
% new design for a Scala actor framework, called Akka, as the foundation of a
% distributed, event-driven middleware. Akka's design and implementation have
% been influenced to a large extent by Scala Actors. Thus, my research on Scala Actors
% laid the groundwork for what is today Typesafe's main
% middleware for concurrent, event-driven applications that scale to multicores
% and clusters.

% \textsc{Joins.} While actors provide a versatile concurrency model that scales to multicore
% processors and distributed systems, coordinating groups of actors remains a
% challenge. A certain class of coordination problems can be simplified using
% join patterns. Building on Scala's flexible pattern matching construct, I
% have devised a new implementation scheme for join patterns~\cite{Joins}
% that also integrates with actors.

% \comment{
% \textsc{Data-flow programming.} I have also contributed to parallel,
% collection-like data-flow abstractions~\cite{LCPC} implemented in Scala.
% These data structures have efficient, non-blocking implementations, utilizing
% virtual machine intrinsics such as compare-and-swap (CAS). Moreover, the data
% structures are designed to be lock-free.\footnote{A proof of lock freedom of
% one of the data structures appears in~\cite{FlowPoolsTR}.}  What this
% research shows is that it is possible to
% leverage the high parallelism of an execution model based on data flow while
% providing a familiar collection-style interface to the programmer.}

% \textsc{Data-flow programming.} I have also contributed to collection-like
% data-flow abstractions~\cite{LCPC} with efficient, non-blocking
% implementations that are provably lock-free. This research shows that it is
% possible to leverage the high degree of parallelism of an execution model
% based on data flow while providing a familiar collection-style interface to
% the programmer.

% \textsc{Asynchronous programming.} At Typesafe I have been co-leading the
% Scala Async project~\cite{AsyncSIP}. It introduces a way to suspend within a
% block of Scala code until a future, a placeholder for the result of an
% asynchronous computation, has been completed. This form of suspension avoids
% the drawbacks of programming in an event-driven style while
% enabling the use of efficient non-blocking concurrency abstractions under the
% hood. The novelty of our design is the fact that it does not require extending
% the Scala language, thus avoiding an increased language complexity, while
% enabling the same expressiveness as similar constructs of C\# and F\#. Scala
% Async has been proposed for inclusion in the Scala standard distribution.
% Building on Scala Async I have designed a new programming model~\cite{RAY}
% that unifies direct-style futures and asynchronous event streams, avoiding the
% well-known ``callback hell'' also in stateful, stream-based applications.

% \comment{
% Recently, I have worked on a new programming model, called RAY, that is
% designed to simplify working with asynchronous computations and event streams,
% which become more and more common as applications move to cloud-based
% platforms. RAY enables programming with both futures and asynchronous event
% streams in a familiar direct style, avoiding the well-known "callback hell".
% RAY is designed to integrate an asynchronous model reminiscent of F\# and C\#
% and the Reactive Extensions model well-known from the .NET platform.}

% \comment{(sometimes referred to as ``callback hell'')}

% % \section*{TYPE AND EFFECT SYSTEMS}
% % \section{Type and Effect Systems}
% \section*{Type and Effect Systems}

% Concurrent processes, such as actors, as provided by imperative,
% object-oriented languages typically suffer from the problem that process isolation is
% conventional rather than enforced by the programming language. As a result,
% even using message-passing concurrency in these languages is not guaranteed to
% prevent data races because of unsynchronized access to shared data. This
% problem has motivated my work on a new type system for unique references in
% object-oriented languages \cite{Uniqueness}. The type system is based on
% static capabilities which enable patterns such as ownership transfer of
% objects between concurrent actors. A prototype of the type system has been
% implemented as a pluggable type system in Scala, and it has been used to
% type-check substantial programs such as a subset of Scala's collections library as
% well as the parallel testing framework used to test the Scala compiler and
% standard library. I have also contributed to a framework for polymorphic
% effect checking~\cite{Effects}; this framework is particularly lightweight,
% which significantly reduces the burden of adding effect annotations on the
% programmer in order to check properties such as purity.

% \comment{
% I have also
% contributed to an ongoing project~\cite{Spores} that is revisiting the
% foundations of functional programming languages, in particular, closures, to
% increase their safety in concurrent and distributed settings. The idea is to
% enable checking richer safety properties through additional structure and type
% information.}

% % \section*{OTHER PROJECTS}
% % \section{Other Projects}
% %\section*{Other Projects}

% \section*{Data-Centric Programming}

% I have found that large-scale, parallel machine learning is a fruitful
% application area for programming language
% research~\cite{Menthor}. Advances in programming abstractions,
% optimizations, and DSLs~\cite{HOSC} can
% significantly increase the flexibility, efficiency, and scalability of machine
% learning frameworks. I have also contributed to a new approach for
% efficient, extensible serialization~\cite{MillerHBO13} which is central to
% frameworks for large-scale data analytics.


% \section*{FUTURE RESEARCH}

% I envision two major avenues for my future research: first, I would like to
% build on my experience in concurrency, type and effect systems, and
% data-centric programming. Second, I would like to expand my research to other areas
% of programming languages, compilers, and software engineering. More
% specifically, I am interested in pursuing research in the following areas:

% \textsc{Concurrency.} When talking to users of actors and futures in Scala, an
% often-voiced concern is concurrency hazards due to unsafe uses of libraries
% without static or dynamic checks. I would like to explore new ways to address
% this lack of robustness using several approaches that can initially be
% explored independently; however, to leverage synergies, ultimately, I'd like
% to bring them together in one integrated actor-based programming system.
% First, I'd like to find practical solutions to enforce correct usage of
% actors, futures, and combinations thereof in existing programming languages.
% To enable comprehensive safety checks, I plan to investigate the symbiosis of
% libraries and safe language subsets. In this approach, programs in the safe
% language subset are valid programs in the full language; thus, compilers and
% tooling can be reused. Second, I'd like to explore new ways to detect
% concurrency hazards, in particular data races. Encouraged by recent results on
% dynamic data race detection for event-driven programs, I plan to devise a new
% dynamic race detection algorithm for reactive programs based on actors and
% futures. Third, to increase programmer productivity, I'm interested in
% semi-automatic synthesis of actor programs based on partial implementations. I plan
% to leverage language subsetting to identify restricted actor models amenable
% to model checking. An important open question I'd like to answer is: what
% kinds of partial inputs are well-suited for reactive applications?



% \comment{ways to address this:
% (a) better concurrency model

% I would like to address this problem through a unified concurrency model,
% extending the actor model of computation with high-level coordination constructs.

% Once embedded in or implemented for mainstream runtime platforms it should reduce the need for

% (b)

% (c) explore new ways to synthesize actor programs based on partial implementations.
% To support semi-automatic program synthesis I would like to

% partially implement actor programs, and}


% \comment{
% to have a concurrency model leveraging novel data types with determinacy
% guarantees plus associated dynamic/static analyses

% first: state your goal, new concurrency model with determinate datatypes and static/dynamic analysis

% second: determinate datatypes, say how they can help the concurrency model

% third: static/dynamic analysis, say how they can help the concurrency model}

% \comment{
% \textsc{Reliable Concurrency.} When talking to users of Scala's futures and
% Akka, an often-voiced concern is concurrency hazards--in particular those that
% result from combining multiple concurrency abstractions, which is common in
% production systems. I would like to address this problem through a unified
% concurrency model leveraging (a) data types with determinacy properties, as
% well as (b) suitable static and dynamic analyses. Novel concurrent data types,
% such as FlowPools~\cite{LCPC}, can provide provably-strong determinacy
% properties without relying on advanced type annotations--often a barrier for
% adoption in mainstream software development. At the same time, the provided
% determinacy properties can help simplify associated static and dynamic
% analyses. New dynamic analysis techniques~\cite{RaychevVS13} have been shown
% to be particularly effective at detecting data races in event-driven web
% applications. One idea that appears promising given such a result is to take a
% new approach to language design where event-driven, concurrent programming
% models are designed together with their dynamic race detector. Essentially, I
% would like to explore a fascinating point in the design space where the
% concurrent programming model enforces ``just enough'' structure, so that
% associated analyses {\em that have been designed together with the programming
% model} are guaranteed to be effective.}

% \comment{My goal is to devise a programming
% system that is both reliable and developer-friendly enough to be deployed in
% production systems.}


% \comment{
% Essentially, one promising idea is to take a new approach to
% language design where event-driven, concurrent programming models are designed
% together with their dynamic race detector.

% New dynamic analysis techniques~\cite{RaychevVS13} have been shown to be
% particularly effective at detecting data races in event-driven web
% applications, which suggests that this approach might be feasible.

% By
% exploring a fascinating point in the design space where the concurrent
% programming model enforces ``just enough'' structure, so that associated
% analyses {\em that have been designed together with the programming model} are
% guaranteed to be effective. My goal is to devise a programming system that is
% both reliable and developer-friendly enough to be deployed in production
% systems.}


% \comment{that’s simple
% and expressive enough to be deployed in production systems by normal users

% I hope to make progress
% towards a programming systems that is both reliable and developer-friendly.

% improve the effectiveness of
% associated static and dynamic analyses and to simplify them.

% these determinacy
% properties can improve the effectiveness of associated static and dynamic
% analyses and make them simpler.

% that has been designed together with a set of suitable
% static and dynamic analyses.

% The idea is to explore a fascinating point in the
% design space of concurrent languages where the programming model enforces
% enough structure, so that associated static and dynamic analyses are
% particularly effective, ideally in a way that can be formalized and proven.

% The approach I would like to pursue builds on two avenues of previous work:
% first,  Second, dynamic analysis has been shown to be particularly
% effective at detecting data races in event-driven web
% applications~\cite{RaychevVS13}. An open question I would like to answer is:
% for which classes of event-driven concurrent programming models can data races
% be found effectively using dynamic analyses? An answer to this question also
% suggests a new approach to language design where concurrent programming models
% are designed together with their dynamic race detector.}


% \textsc{Type and Effect Systems.} Type systems based on static capabilities
% are effective at tracking disjoint object graphs in the
% heap~\cite{GordonPPBD12}. Among others, such heap partitions support safe
% concurrency and parallelism, thread locality optimization, and security.
% However, such type systems still require a non-negligible amount of additional
% type annotations in programs which typically limits their practical use to
% experts. I would like to investigate how far our capability-based type
% system~\cite{Uniqueness} can be specialized for programming models that
% already provide determinacy properties without such capabilities. Such a
% specialization could result in significant simplifications and much fewer
% required type annotations.


% \comment{
% Insight from James Larus:

% The "Cloud" is a wonderfully expansive phrase used to denote computation and
% data storage centralized in a large datacenter and elastically accessed across
% a network. The concept is not new; web sites and business servers have run in
% datacenters for a long time. These, however, were specialized applications,
% outside of the mainstream of desktop programs. The past few years has seen
% enormous change as the mainstream shifts from a single computer to mobile
% devices and clusters of computers. Three factors are driving this change. 1)
% Mobile computing, where apps run on a size- and power-constrained device and
% would be far less interesting without backend systems to augment computation
% and storage capacity. 2) Big data, which uses clusters of computers to extract
% valuable information from vast amounts of unstructured data. 3) Inexpensive,
% elastic computing, pioneered by Amazon Web Services, which enables everyone to
% rapidly obtain and use many servers.

% As a researcher from the language and compiler community, I firmly believe
% this sea change is at heart a programming problem. Cloud computing is far
% different from the environment in which most of today's languages and tools
% were developed, and few programmers have mastered its complexity. New
% challenges include pervasive parallelism, partial failure, high and variable
% communication latency, and replication for reliability and throughput.
% }


% \textsc{Compilers.} Scala-Virtualized~\cite{HOSC} enables compiler frameworks
% for embedded DSLs targeting heterogeneous platforms such as multicores, GPUs,
% and clusters. While such a language-based framework is well-suited for
% high-performance computing DSLs, it does not support general-purpose applications.
% I would like to develop a principled approach based on types and effects to
% identify portable code together with compiler technology for generating code
% for heterogeneous platforms including the ``glue code'' required to
% communicate between different runtime environments. One exciting outlook of
% this work is enabling ``full stack'' development where the entire code of a
% typical cloud application is written in a single programming language.


% \comment{
% cloud
% applications where code running on mobile devices, in browsers, and on the
% cluster, can be written in a single programming language.

% that
% can generate code for heterogeneous platforms together with the ``glue code''
% required to communicate between different runtime environments. One exciting
% outlook of this work is enabling ``full stack'' development of cloud
% applications where code running on mobile devices, in browsers, and on the
% cluster, can be written in a single programming language.}

% \comment{, removing the
% artificial division between ``front-end'' and ``back-end'' developer teams.}

% \textsc{Programming with Objects and Functions.} New computing paradigms, such
% as cloud computing or ``big data'' processing, present new challenges that
% current programming languages do not always support satisfactorily. I am very
% interested in revisiting the foundations of object-oriented and functional
% languages to better support these new computing paradigms. Besides a new
% approach to working with off-heap data~\cite{MillerHBO13}, I am currently
% exploring a variant of closures that provides more safety in concurrent and
% distributed settings.

% \comment{ (with applications
% in large-scale data analytics such as~\cite{Menthor})}
% \comment{ thanks to additional type information}

% \comment{
% Currently, I am working on a new approach to object
% serialization as well as a


% Besides
% ongoing work~\cite{MillerHBO13} on converting between typed and untyped
% objects, I am very interested in revisiting the foundations of object-oriented
% and functional languages, such as closures or data consistency models, to
% better support these new computing paradigms.}


% \comment{
% I have also
% contributed to an ongoing project~\cite{Spores} that is revisiting the
% foundations of functional programming languages, in particular, closures, to
% increase their safety in concurrent and distributed settings. The idea is to
% enable checking richer safety properties through additional structure and type
% information.}


% \comment{Besides
% ongoing work on efficient, extensible object serialization~\cite{MillerHBO13},}

% \comment{
% \textsc{Large-scale Data Processing.} In previous work~\cite{Menthor} we have
% done some first steps to parallelize large-scale machine learning tasks on big
% datasets using actors and functional programming techniques. However, numerous
% challenges remain to make large-scale data analytics performant and reliable.
% Our new approach to object serialization~\cite{MillerHBO13} enables simple,
% efficient conversion between data formats without boilerplate through
% pluggable data formats. However, there are several open questions: How to
% support schema evolution? How to support all data access modes required for
% real-time streaming data analytics?}

% \comment{that
% takes my experience from my involvement with the Scala project into account.}

% \bibliographystyle{siam}
% \bibliographystyle{plain}
% \bibliography{bib}

\printbibliography
% \printbibheading
% \printbibliography[type=book,heading=subbibliography,title={Books}]
% \printbibliography[type=article,heading=subbibliography,title={Journal Articles}]
% \printbibliography[type=inproceedings,heading=subbibliography,title={Conference and Workshop Papers}]
% \printbibliography[nottype=book,nottype=article,nottype=inproceedings,heading=subbibliography,title={Other Sources}]

% \begin{received}
% Prepared January 2011
% \end{received}

\end{document}


