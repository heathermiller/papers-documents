% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass[runningheads]{llncs}
%

%% Save the class definition of \subparagraph
\let\llncssubparagraph\subparagraph
%% Provide a definition to \subparagraph to keep titlesec happy
\let\subparagraph\paragraph
%% Load titlesec
\usepackage[compact]{titlesec}
%% Revert \subparagraph to the llncs definition
\let\subparagraph\llncssubparagraph
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{url}
\usepackage[xetex]{hyperref}
\usepackage{todonotes}
\usepackage{listings}
% \usepackage{fontspec}
\usepackage{fancyvrb}
\usepackage[labelfont=bf]{caption}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{times}
\usepackage[scaled=0.875]{inconsolata}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{lipsum}

\newcommand{\comment}[1]{}

% Member sequences
\newcommand{\seq}[1]{\overline{#1}}

% arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}
\newcommand{\sporeurl}{\url{https://github.com/scala/spores}}
% spacing
\newcommand{\gap}{\quad\quad}
\newcommand{\andalso}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

\newcommand{\ie}{{\em i.e.,~}}
\newcommand{\eg}{{\em e.g.,~}}
\newcommand{\etc}{{\em etc}}

\newcommand*\loc{\includegraphics[height=0.65em,keepaspectratio]{loc}}
\newcommand*\stars{\includegraphics[height=0.8em,keepaspectratio]{stars}}
\newcommand*\contribs{\includegraphics[height=0.8em,keepaspectratio]{contribs}}

\lstdefinelanguage{Scala}%
{morekeywords={abstract,case,catch,char,class,%
    def,else,extends,final,%
    if,import,%
    match,module,new,null,object,override,package,private,protected,%
    public,return,super,this,throw,trait,try,type,val,var,with,implicit,%
    macro,sealed,%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

% \lstset{language=Scala,%
%   mathescape=true,%
%   columns=[c]fixed,%
%   numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily,
%   basewidth={0.5em, 0.40em},%
%   basicstyle=\tt,%
%   xleftmargin=0.0cm
% }

% \setmainfont[
%   Ligatures=TeX,
%   SmallCapsFont={TeX Gyre Termes},
%   SmallCapsFeatures={Letters=SmallCaps},
% ]{Times New Roman}

\lstset{tabsize=2,
basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont,
commentstyle=\itshape\rmfamily,
numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=scala,moredelim=[il][\sffamily]{?},mathescape=false,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapechar=@, morekeywords=[1]{let,fn,val},deletekeywords={for},classoffset=0,belowskip=\smallskipamount
}

\definecolor{light-gray}{gray}{0.80}
\definecolor{lightGray}{rgb}{0.9, 0.9, 0.9}

\newcommand{\Hilight}{\makebox[0pt][l]{\color{light-gray}\rule[-0.45em]{\linewidth}{1.5em}}}

% \setlength{\belowcaptionskip}{-5pt}
\setlength{\textwidth}{12.4cm}
 \setlength\intextsep{ 0pt plus 2pt minus 2pt}

% \titlespacing{\section}{0pt}{\parskip}{-\parskip}

\begin{document}

% \fontspec[
%   SmallCapsFont={TeX Gyre Termes},
%   SmallCapsFeatures={Letters=SmallCaps},
% ]{Times New Roman}
\VerbatimFootnotes
% \setmonofont[Scale=0.8,BoldFont={Consolas Bold}]{Consolas}

%
\mainmatter              % start of the contributions


\title{Scalable Join Patterns for Reactive Streams}

\titlerunning{Running title}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Philipp Haller$^{1}$ \and Alon Dolev\footnote{Work done while at TU Delft.}
\and Heather Miller}

%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Philipp Haller,$^{1}$ Alon Dolev, and Heather Miller}

% \institute{EPFL and Typesafe, Inc$^{1}$\\

% \texttt{\scriptsize \{heather.miller, martin.odersky\}@epfl.ch}
% and \texttt{\scriptsize philipp.haller@typesafe.com}$^{1}$}


\institute{KTH Royal Institute of Technology$^{1}$\\
\texttt{heather.miller@epfl.ch}
and
\texttt{phaller@kth.se}$^{1}$}


\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
\authorrunning{P. Haller, A. Dolev, and H. Miller} % abbreviated author list (for running head)

\maketitle              % typeset the title of the contribution

\begin{sloppypar}
\begin{abstract}

This paper presents a new, scalable matching algorithm for
reactive streams.

\keywords{join calculus, concurrent programming, streams}
\end{abstract}


\section{Introduction}
\label{sec:introduction}

Introduce

\section{Background}

\subsection{Reactive Extensions}

The Rx programming model is based on two interface traits: \verb|Observable|
and \verb|Observer|. \verb|Observable| represents observable streams, i.e.,
streams that produce a sequence of events. These events can be observed by
registering an \verb|Observer| with the \verb|Observable|. The \verb|Observer|
provides methods which are invoked for each of the kinds of events produced by
the \verb|Observable|. In Scala, the two traits can be defined as shown in
Figure~\ref{fig:observable-observer}.

\begin{figure}[ht!]
  \centering
  \lstset{numbers=none,xleftmargin=0em}
  \begin{lstlisting}
  trait Observable[T] {
    def subscribe(obs: Observer[T]): Closable
  }

  trait Observer[T] extends (Try[T] => Unit) {
    def apply(tr: Try[T]): Unit
    def onNext(v: T) = apply(Success(v))
    def onFailure(t: Throwable) = apply(Failure(t))
    def onDone(): Unit
  }
  \end{lstlisting}
  \caption{The \texttt{Observable} and \texttt{Observer} traits.}
  \label{fig:observable-observer}
\end{figure}

The idea of the \verb|Observer| is that it can respond to three different
kinds of events, (1) the next regular event (\verb|onNext|), (2) a failure
(\verb|onFailure|), and (3) the end of the observable stream (\verb|onDone|).
Thus, the two traits constitute a variation of the classic subject/observer
pattern~\cite{EugsterFGK03}. Note that \verb|Observable|'s \verb|subscribe|
method returns a \verb|Closable|; it has only a single abstract \verb|close|
method which removes the subscription from the observable. The next listing
shows an example implementation.

Note that in our Scala version the \verb|Observer| trait extends the function
type \verb|Try[T] => Unit|. \verb|Try[T]| is a simple container type which
supports heap-based exception handling (as opposed to the traditional stack-based
exception handling using expressions like \verb|try-catch-finally|.)
There are two subclasses of \verb|Try[T]|: \verb|Success| (encapsulating a
value of type \verb|T|) and \verb|Failure| (encapsulating an exception). Given
the above definition, a concrete \verb|Observer| only has to provide
implementations for the \verb|apply| and \verb|onDone| methods. Since
\verb|apply| takes a parameter of type \verb|Try[T]| its implementation
handles the \verb|onNext| and \verb|onFailure| events all at once (in Scala,
this is tyically done by pattern matching on \verb|tr| with cases for
\verb|Success| and \verb|Failure|).

The \verb|Observer| and \verb|Observable| traits are used as follows. For
example, here is a factory method for creating an observable from a text input
field of typical GUI toolkits (this example is adapted from~\cite{RxCACM}):

\lstset{numbers=none,xleftmargin=0em}
\begin{lstlisting}
def textChanges(tf: JTextField): Observable[String] =
  new ObservableBase[String] {
    def subscribe(o: Observer[String]) = {
      val l = new DocumentListener {
        def changedUpdate(e: DocumentEvent) = {
          o.onNext(tf.getText())
        }
      }
      tf.addDocumentListener(l)
      new Closable() {
        def close() = {
          tf.removeDocumentListener(l)
        }
      }
    }
  }
\end{lstlisting}

This newly-defined \verb|textChanges| combinator can be used with other Rx
combinators as follows:

\begin{lstlisting}
textChanges(input)
.flatMap(word => completions(word))
.subscribe(observeChanges(output))
\end{lstlisting}

We start with the observable created using the \verb|textChanges| method from
above. Then we use the \verb|flatMap| combinator (called \verb|Select| in C\#)
to transform the observable into a new observable which is a stream of
completions for a given word (a string). On the resulting observable we call
\verb|subscribe| to register a consumer: \verb|observeChanges| creates an
observer which outputs all received events to the \verb|output| stream. (The
shown example suffers from a problem explained in~\cite{RxCACM} which
motivates the use of an additional \verb|Switch| combinator which is omitted
here for brevity.)

\section{Overview}

Join patterns are an elegant way to {\em declaratively} coordinate multiple
observables.

Consider the implementation of a method \verb|findProducts| for finding
products of a given name in a large database. For each product, the method
should not only return its description, but also reviews of the seller, and
images of the product. Furthermore, the method should find ``related''
products, e.g., as determined by a recommender system. Given the complexity of
the search, it is essential that the \verb|findProducts| method is {\em
asynchronous;} its callers should under no circumstance be blocked, waiting
until {\em all} results have been received.

\begin{figure}[ht]
\centering
\lstset{numbers=left}
\begin{lstlisting}
def findProducts(name: String) = {
  val search: Observable[Product] = db.searchProductsByName(name)
  search.flatMap(p => {
    val reviews = db.getSellerReviews(p.seller)
    val images = fileServer.getProductImages(p.id)
    val related = db.getRelatedProducts(p.id)

    Observable.just(p.description).zip(reviews).zip(images).merge(related)
  })
}
\end{lstlisting}
\caption{Finding products using the Reactive Extensions model}
\label{fig:find-products}
\end{figure}

Figure~\ref{fig:find-products} shows an implementation of the
\verb|findProducts| method using the Reactive Extensions model. First, the
method queries a \verb|db| object which returns a stream of products (an
\verb|Observable[Product]|). For each product \verb|p| in this stream we would
like to create a new stream that combines the product's description, images,
reviews, as well as related products. Using \verb|flatMap| these per-product
streams are combined into a single result stream that \verb|findProducts|
returns. In this example, a \verb|Product| has an \verb|id|, a
\verb|description|, and a \verb|seller|. A sequence of method calls obtains
seller reviews, product images, and related products from several different
sources (a database and a file server) in the form of observables to enable
asynchronous retrieval of several results. The per-product result stream is
created as follows: \verb|Observable.just(p.description)| creates a trivial
stream with just a single element (the description); \verb|a.zip(b)| creates a
stream of pairs $(a_1, b_1), (a_2, b_2), \ldots$ if stream \verb|a| emits
elements $a_1, a_2, \ldots$ and stream \verb|b| emits elements $b_1, b_2,
\ldots$; the \verb|merge| combinator merges multiple streams into one.

\subsection{Join patterns}

% !\colorbox{light-gray}{JoinObservable}![List[Review]]

\begin{figure}[ht]
\centering
\lstset{numbers=left}
\begin{lstlisting}[escapechar=!]
def findProducts(name: String) = {
  val search: Observable[Product] = db.searchProductsByName(name)
  search.flatMap(p => {
    val reviews = db.getSellerReviews(p.seller)!\colorbox{light-gray}{.p}!
    val images = fileServer.getProductImages(p.id)!\colorbox{light-gray}{.p}!
    val related = db.getRelatedProducts(p.id)!\colorbox{light-gray}{.p}!

    !\colorbox{light-gray}{join}! {
      !\colorbox{light-gray}{case reviews(r) \&\& images(i) => Next((p.description, r, i))}!
      !\colorbox{light-gray}{case related(x) => Next(x)}!
    }
  })
}
\end{lstlisting}
\caption{Finding products using join patterns}
\label{fig:find-products-joins}
\end{figure}

\noindent
Our extended programming model enables expressing the above example using {\em
join patterns}, as shown in Figure~\ref{fig:find-products-joins}. The
differences to the implementation without join patterns (see
Figure~\ref{fig:find-products}) are indicated by \colorbox{light-gray}{shading}.

First, \verb|reviews|, \verb|images|, and \verb|related| are no longer
observables. Instead, by invoking the \verb|p| {\em extension method} (TODO:
add reference to Scala spec) each original observable is turned into a
\verb|JoinObservable|, enabling its use in join patterns.\footnote{By
implementing additional methods, a \texttt{JoinObservable} is an {\em
extractor}~\cite{EmirOW07} for its underlying \texttt{Observable}.}

Second, the \verb|join| construct on line 8 introduces a join pattern. The
result of \verb|join| is an observable that emits events as defined by the
pattern block following the \verb|join| marker. A pattern block defines a list
of join pattern {\em cases}. The first pattern fires as soon as {\em both} the
\verb|reviews| {\em and} the \verb|images| observable have emitted an event.
Whenever a join pattern fires, the observable created by the \verb|join|
construct emits an event defined by the right-hand side of the join pattern
(following the \verb|=>| arrow). In the case of the first join pattern, the
resulting observable emits a triple consisting of the product description, the
received review, and the received image. The second join pattern fires as soon
as the \verb|related| observable emits an event. In this case, the created
observable simply emits the received event \verb|x|.

In the above example, the observable created using \verb|join| only emits
\verb|onNext| events, using the \verb|Next| constructor. It is equally
possible to match and emit \verb|onDone| and \verb|onFailure| events. The
following join pattern forwards all three types of events emitted by some
observable \verb|obs|:

\begin{lstlisting}
join {
  case obs(x)       => Next(x)
  case obs.done     => Done
  case obs.error(e) => throw e
}
\end{lstlisting}

\noindent
The semantics of matching events is that an event is only matched at most
once; this applies also to \verb|onDone| and \verb|onFailure| events. This
means that the following join patterns {\em race} to match the single
\verb|onDone| event of \verb|obs1|:

\begin{lstlisting}
join {
  case obs2(x) && obs1.done => Next(Some(x))
  case obs3(y) && obs1.done => Next(None)
}
\end{lstlisting}

\noindent
Note that the order in which patterns are matched is undefined by default. We
call this semantics \emph{non-deterministic choice}, and it is crucial to
achieve high scalability, as we show in Section~\ref{sec:evaluation}.
Nevertheless, sometimes it is useful to enforce the order in which the
patterns are matched, for example when encoding priority.

For example, we might launch two web requests to retrieve data to a search
term, one to an internal system and one to an external system:

\begin{lstlisting}
implicit val checkOrder = InOrder
join {
  case search(s) && internal(d) => Next((s, d))
  case search(s) && external(d) => Next((s, d))
}
\end{lstlisting}

\noindent
We define an implicit value \verb|checkOrder|, and set it to \verb|InOrder|.
Now, the \verb|join| construct uses a different algorithm that checks the
patterns in the order stated textually. This means that events from the
\verb|internal| system are prioritized. Although we have optimized the
performance of this {\em deterministic-choice} algorithm, in general it
performs worse than the {\em non-deterministic choice} algorithm, since the
latter can leverage more concurrency.


\section{Scalable Matching Algorithm}\label{sec:algorithm}

The main challenge of join-calculus pattern matching is ensuring {\em
atomicity:} messages in multiple buffers must be examined and dequeued
atomically. It is an additional challenge to guarantee atomicity in a {\em scalable}
way. Several join-calculus implementations rely on locks to ensure atomicity
(see Section~\ref{cha:related}). The scalability problems of locks are well
documented~\cite{Michael:1998}; in summary, lock-based implementations do not
guarantee thread safety in the most scalable way.

Turon \& Russo~\cite{Turon:2011} take up the challenge to provide a {\em
scalable} pattern-matching algorithm. They identify two main factors crucial
to scalability: lock freedom and fine-grained concurrency. Lock freedom mainly
means that no locks are used; instead, non-blocking concurrency primitives are
used. Fine-grained concurrency means that critical sections are as short as
possible. An important insight of Turon \& Russo's join patterns is that if
ordering constraints on message buffers are relaxed beyond the FIFO ordering
typically guaranteed by join-calculus implementations, additional concurrency
can be leveraged, and synchronization can happen as fine-grained as on the
level of individual messages. Relaxing the ordering of messages is valid as
far as compliance with the original join-calculus
semantics~\cite{Fournet:1996} is concerned; however, it is {\em incompatible}
with the semantics of observables.

To remedy this problem, we present a novel matching algorithm which guarantees
FIFO ordering of message buffers. The algorithm is inspired to a large extent
by Turon \& Russo's scalable, non-blocking algorithm. In the following we
first introduce our algorithm, and then we discuss the differences with regard
to Turon \& Russo.

% For a more detailed discussion of Turon \& Russo's
% algorithm see Section~\ref{sub:scalableJoinPatterns}.


\section{Evaluation}\label{sec:evaluation}


\section{Conclusion}\label{sec:conclusion}

Conclude

\bibliographystyle{abbrv}
\bibliography{bib}

\end{sloppypar}
\end{document}
