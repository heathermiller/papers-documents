% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass[runningheads]{llncs}
%

%% Save the class definition of \subparagraph
\let\llncssubparagraph\subparagraph
%% Provide a definition to \subparagraph to keep titlesec happy
\let\subparagraph\paragraph
%% Load titlesec
\usepackage[compact]{titlesec}
%% Revert \subparagraph to the llncs definition
\let\subparagraph\llncssubparagraph
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{url}
\usepackage[xetex]{hyperref}
\usepackage{todonotes}
\usepackage{listings}
% \usepackage{fontspec}
\usepackage{fancyvrb}
\usepackage[labelfont=bf]{caption}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{times}
\usepackage[scaled=0.875]{inconsolata}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{lipsum}

\newcommand{\comment}[1]{}

% Member sequences
\newcommand{\seq}[1]{\overline{#1}}

% arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}
\newcommand{\bda}{\[\ba}
\newcommand{\eda}{\ea\]}
\newcommand{\ei}{\end{array}}
\newcommand{\bcases}{\left\{\begin{array}{ll}}
\newcommand{\ecases}{\end{array}\right.}
\newcommand{\sporeurl}{\url{https://github.com/scala/spores}}
% spacing
\newcommand{\gap}{\quad\quad}
\newcommand{\andalso}{\quad\quad}
\newcommand{\biggap}{\quad\quad\quad}
\newcommand{\nextline}{\\ \\}
\newcommand{\htabwidth}{0.5cm}
\newcommand{\tabwidth}{1cm}
\newcommand{\htab}{\hspace{\htabwidth}}
\newcommand{\tab}{\hspace{\tabwidth}}
\newcommand{\linesep}{\ \hrulefill \ \smallskip}

\newcommand{\ie}{{\em i.e.,~}}
\newcommand{\eg}{{\em e.g.,~}}
\newcommand{\etc}{{\em etc}}

\newcommand*\loc{\includegraphics[height=0.65em,keepaspectratio]{loc}}
\newcommand*\stars{\includegraphics[height=0.8em,keepaspectratio]{stars}}
\newcommand*\contribs{\includegraphics[height=0.8em,keepaspectratio]{contribs}}

\lstdefinelanguage{Scala}%
{morekeywords={abstract,case,catch,char,class,%
    def,else,extends,final,%
    if,import,%
    match,module,new,null,object,override,package,private,protected,%
    public,return,super,this,throw,trait,try,type,val,var,with,implicit,%
    macro,sealed,%
  },%
  sensitive,%
  morecomment=[l]//,%
  morecomment=[s]{/*}{*/},%
  morestring=[b]",%
  morestring=[b]',%
  showstringspaces=false%
}[keywords,comments,strings]%

% \lstset{language=Scala,%
%   mathescape=true,%
%   columns=[c]fixed,%
%   numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily,
%   basewidth={0.5em, 0.40em},%
%   basicstyle=\tt,%
%   xleftmargin=0.0cm
% }

% \setmainfont[
%   Ligatures=TeX,
%   SmallCapsFont={TeX Gyre Termes},
%   SmallCapsFeatures={Letters=SmallCaps},
% ]{Times New Roman}

\lstset{tabsize=2,
basicstyle=\ttfamily\fontsize{9pt}{1em}\selectfont,
commentstyle=\itshape\rmfamily,
numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=scala,moredelim=[il][\sffamily]{?},mathescape=false,showspaces=false,showstringspaces=false,xleftmargin=15pt,escapechar=@, morekeywords=[1]{let,fn,val},deletekeywords={for},classoffset=0,belowskip=\smallskipamount
}

% \setlength{\belowcaptionskip}{-5pt}
\setlength{\textwidth}{12.4cm}
 \setlength\intextsep{ 0pt plus 2pt minus 2pt}

% \titlespacing{\section}{0pt}{\parskip}{-\parskip}

\begin{document}

% \fontspec[
%   SmallCapsFont={TeX Gyre Termes},
%   SmallCapsFeatures={Letters=SmallCaps},
% ]{Times New Roman}
\VerbatimFootnotes
% \setmonofont[Scale=0.8,BoldFont={Consolas Bold}]{Consolas}

%
\mainmatter              % start of the contributions


\title{Scalable Join Patterns for Reactive Streams}

\titlerunning{Running title}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Philipp Haller$^{1}$ \and Alon Dolev\footnote{Work done while at TU Delft.}
\and Heather Miller}

%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Philipp Haller,$^{1}$ Alon Dolev, and Heather Miller}

% \institute{EPFL and Typesafe, Inc$^{1}$\\

% \texttt{\scriptsize \{heather.miller, martin.odersky\}@epfl.ch}
% and \texttt{\scriptsize philipp.haller@typesafe.com}$^{1}$}


\institute{KTH Royal Institute of Technology$^{1}$\\
\texttt{heather.miller@epfl.ch}
and
\texttt{phaller@kth.se}$^{1}$}


\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
\authorrunning{P. Haller, A. Dolev, and H. Miller} % abbreviated author list (for running head)

\maketitle              % typeset the title of the contribution

\begin{sloppypar}
\begin{abstract}

This paper presents a new, scalable matching algorithm for
reactive streams.

\keywords{join calculus, concurrent programming, streams}
\end{abstract}


\section{Introduction}
\label{sec:introduction}

Introduce

\section{Background}

\subsection{Reactive Extensions}

The Rx programming model is based on two interface traits: \verb|Observable|
and \verb|Observer|. \verb|Observable| represents observable streams, i.e.,
streams that produce a sequence of events. These events can be observed by
registering an \verb|Observer| with the \verb|Observable|. The \verb|Observer|
provides methods which are invoked for each of the kinds of events produced by
the \verb|Observable|. In Scala, the two traits can be defined as shown in
Figure~\ref{fig:observable-observer}.

\begin{figure}[ht!]
  \centering
  \lstset{numbers=none,xleftmargin=0em}
  \begin{lstlisting}
  trait Observable[T] {
    def subscribe(obs: Observer[T]): Closable
  }

  trait Observer[T] extends (Try[T] => Unit) {
    def apply(tr: Try[T]): Unit
    def onNext(v: T) = apply(Success(v))
    def onFailure(t: Throwable) = apply(Failure(t))
    def onDone(): Unit
  }
  \end{lstlisting}
  \caption{The \texttt{Observable} and \texttt{Observer} traits.}
  \label{fig:observable-observer}
\end{figure}

The idea of the \verb|Observer| is that it can respond to three different
kinds of events, (1) the next regular event (\verb|onNext|), (2) a failure
(\verb|onFailure|), and (3) the end of the observable stream (\verb|onDone|).
Thus, the two traits constitute a variation of the classic subject/observer
pattern~\cite{EugsterFGK03}. Note that \verb|Observable|'s \verb|subscribe|
method returns a \verb|Closable|; it has only a single abstract \verb|close|
method which removes the subscription from the observable. The next listing
shows an example implementation.

Note that in our Scala version the \verb|Observer| trait extends the function
type \verb|Try[T] => Unit|. \verb|Try[T]| is a simple container type which
supports heap-based exception handling (as opposed to the traditional stack-based
exception handling using expressions like \verb|try-catch-finally|.)
There are two subclasses of \verb|Try[T]|: \verb|Success| (encapsulating a
value of type \verb|T|) and \verb|Failure| (encapsulating an exception). Given
the above definition, a concrete \verb|Observer| only has to provide
implementations for the \verb|apply| and \verb|onDone| methods. Since
\verb|apply| takes a parameter of type \verb|Try[T]| its implementation
handles the \verb|onNext| and \verb|onFailure| events all at once (in Scala,
this is tyically done by pattern matching on \verb|tr| with cases for
\verb|Success| and \verb|Failure|).

The \verb|Observer| and \verb|Observable| traits are used as follows. For
example, here is a factory method for creating an observable from a text input
field of typical GUI toolkits (this example is adapted from~\cite{RxCACM}):

\lstset{numbers=none,xleftmargin=0em}
\begin{lstlisting}
def textChanges(tf: JTextField): Observable[String] =
  new ObservableBase[String] {
    def subscribe(o: Observer[String]) = {
      val l = new DocumentListener {
        def changedUpdate(e: DocumentEvent) = {
          o.onNext(tf.getText())
        }
      }
      tf.addDocumentListener(l)
      new Closable() {
        def close() = {
          tf.removeDocumentListener(l)
        }
      }
    }
  }
\end{lstlisting}

This newly-defined \verb|textChanges| combinator can be used with other Rx
combinators as follows:

\begin{lstlisting}
textChanges(input)
.flatMap(word => completions(word))
.subscribe(observeChanges(output))
\end{lstlisting}

We start with the observable created using the \verb|textChanges| method from
above. Then we use the \verb|flatMap| combinator (called \verb|Select| in C\#)
to transform the observable into a new observable which is a stream of
completions for a given word (a string). On the resulting observable we call
\verb|subscribe| to register a consumer: \verb|observeChanges| creates an
observer which outputs all received events to the \verb|output| stream. (The
shown example suffers from a problem explained in~\cite{RxCACM} which
motivates the use of an additional \verb|Switch| combinator which is omitted
here for brevity.)

\section{Overview}

Join patterns are an elegant way to {\em declaratively} coordinate multiple
observables.

Consider the implementation of a method \verb|findProducts| for finding
products of a given name in a large database. For each product, the method
should not only find the description of the product, but also additional data,
such as product images and product reviews. Furthermore, the method should
find ``related'' products, e.g., as determined by a recommender system. Given
the complexity of the search, it is essential that the \verb|findProducts|
method is {\em asynchronous;} its callers should under no circumstance be
blocked, waiting until {\em all} results have been received.

\begin{figure}[ht]
\centering
\begin{lstlisting}
def findProducts(name: String): Unit = {
  val search: Observable[Product] = db.searchProductsByName(name)
  search.flatMap(p => {
    val reviews: Observable[List[Review]] = db.getReviews(p.id)
    val images: Observable[List[Image]] = fileServer.getProductImages(p.id)
    val related: Observable[(String, Int, List[Image])] = getRelatedProducts(p.id)
    Observable.just(p.description).zip(reviews).zip(images).merge(related)
  })
}
\end{lstlisting}
\caption{The \texttt{findProducts} method}
\label{fig:find-products}
\end{figure}

Figure~\ref{fig:find-products} shows an implementation of the
\verb|findProducts| method using the Reactive Extensions model.


\section{Conclusion}
\label{sec:conclusion}

Conclude

\bibliographystyle{abbrv}
\bibliography{bib}

\end{sloppypar}
\end{document}
