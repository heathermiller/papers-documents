---
layout: page
title: Synthetically Generating Members to Access Private State <i>[February 19th, 2013]</i>
---

**Issue:** The `introduceMember` macro API is very controversial. Therefore,
we should consider alternatives. To understand which alternatives would be
possible (from the perspective of the pickler project) we would first need to
understand in which scenario this is important.

Scenario where this is important:

    val obj: C = ...
    obj.pickle

Suppose class `C` has a private field. In the case where this code and the
code for `C` is compiled together, we can use `Context.introduceMember` to add
methods to `C` in order to expose its private members for pickling.

So what are the issues? Issues:

1. Scenario should be an optionally-supported scenario because many people
rely upon separate compilation. And in the case of separate compilation, it's
not possible to add methods to existing types.

2. This relies on the controversial `introduceMember` API that would be
available to macro def users.

So now the question: **Could there be a better compiler hook than `introduceMember`?**

_Pro:_ This way, it wouldn't have to be controversially added to macros.

_Con:_ Is it possible to come up with a non-controversial compiler hook? Because it
would still need to be invoked from the pickler macro. We'd need to do a cast
to get some internal compiler type, which would mean that the macro would
begin depending on the internal compiler API.

### Intended way for private state to be dealt with by pickler framework

Three cases that would arise for private state, and three intended ways of
dealing with them:

1. Private state, no separate compilaton. Desire: picklers generated at
compile-time.

2. Private state, with separate compilation. Desire: picklers generated at
compile-time.

  - Template generated at compile-time. Normal field accessors generated at
    compile-time.

  - Template generated at compile-time. Field accessors generated at compile-
    time using calls to runtime reflection.

3. Private state, with separate compilation. Deisre: just want picklers
generated, doesn't have to be at compile-time.

Case 1. is described in the previous section.

Case 2. there are two options (as alluded to above). A deliberate design goal
is not to rely upon the type system to mix-in a `Pickleable` marker trait, as
this causes a number of issues for Java serialization that we'd like to avoid.
As for Kryo, we'd like for any arbitrary type to be able to be pickled,
without having to involve the type system. However, for best performance (i.e.
so as not to have to generate picklers at runtime in this case), we'd like to
provide an option for users to achieve the robustness provided by the type
system in the situation where separate compilatoin is required. In this case,
one option is to use type macros to add the accessor methods for the private
state in question. (This is assuming that type macros are extended in a way
where subclasses of a class that mixes-in a type macro can re-trigger macro
expansion.)



