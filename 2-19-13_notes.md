---
layout: page
title: Dealing with Inheritance Through Functional Composition <i>[February 19th, 2013]</i>
---

While working out how to support inheritance in the generation and composition
of compile-time picklers, I came up with an elegant way to abstract the
problem, making it easier to reason about, and easy to formalize.

This approach can easily be generalized as a mechanism for in general dealing
with inheritance in a neat, functional, and totally composable way.
Furthermore, it seems the approach could conceivably be used as a component of
larger calculi, like DOT.

Basically, the idea is to consider types as abstract containers which have
qualities (members) that can be composed.

The composition of qualities and containers can be expressed using the
following functions:

    f1: (Q, Q) => Q
    f2: (C, C) => C
    f3: C => List[C]

The composition of a container C can then be expressed using

    def compose(c: C) = f3(c).foldLeft(c)(f2)

A container simply contains a set of qualities: {Q1, ..., Qn} \subseteq C

The purpose of function f3 is to find out what are the components of a
container. For example, when considering mix-in composition, for a given
container (a trait), f3 would return the list of traits in the linearization
order. Thus, the first step in carrying out the composition is to obtain the
super traits in linearization order.

The purpose of function f2 is to compose two containers C1 and C2 in the
following way. For each quality Q1 in C1, written Q1(C1), produce Q1(C) by
composing Q1(C1) and Q1(C2). That is, a quality in the resulting container is
obtained by composing the equivalent qualities of the component containers.

Finally, the purpose of function f1 is to define how two equivalent qualities
of two containers are composed to yield the corresponding quality of the
compound container.

This way of formulating composition can be used to express mix-in composition
as follows.

For example, the following trait

    trait C {
      type T
      val f: T
      val g: C => C
    }

has two qualities, a quality of types (just T), and a quality of its fields (f
and g). Now, if we consider a trait that extends C,

    trait D extends C {
      type T <: C
      val h: D
    }

then the quality of the type members of trait D is a refinement of the quality
of type members of trait C. Moreover, the quality of members of trait D has
been augmented with member h.

The composition of qualities becomes even more interesting when considering
the composition of multiple traits that override members:

    trait E extends C {
      override val f: E = this
    }

    trait F extends D with E

In this case, trait F composes the member qualities of D and E, so that its
member quality contains

    val f: E
    val g: C => C
    val h: D

