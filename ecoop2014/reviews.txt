*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=

First reviewer's review:

          >>> Summary of the submission <<<

Closures are often serialized to be shipped across different platforms and/or
to be executed latter.
However programmers still struggle with closure serialization because of
accidental capture of lexical variables.
E.g., is surprisingly easy to include references to non-serializable/mutable
data into the serialization process. Usually, such undesirable inclusion leads
to cryptic runtime exceptions.

In this paper, the authors propose a conservative type-based approach to detect
those errors at compile-time.
The approach is base on a new closure-like abstraction called spore.
Compared to closures, spores provide additional means to control the
environment in which their body will be executed.
A spore syntactically consists of a regular closure along with a header that
declares the free variables usable inside the closure's body.
The type of a spore is then defined by the type of its inner closure along with
the types of the free variables contained in the header.
The paper presents an implementation of the approach as a macro library for the
Scala language where spores are a subclass of regular closures.
Additionally the behavior of these macros is formalized as a type system that
allows the proof of basic safety properties such as ''Dynamically, a spore only
accesses its parameters or the variables in its header``.
Finally a small-scale evaluation has been conducted in order to quantify the
impact of introducing spores into existing Scala programs.

          >>> Evaluation <<<

Points in favour:
 - The paper tackles a well defined problem that is recognized by the
industry.
 - The solutions is well explained under different angles (many use cases +
formalization)
Points against:
 - The evaluation (section 5) is not very convincing since it only quantifies
the impact of introducing spores into Scala programs; not the actual benefit of
using them. The only way to actually validate this work would be by conducing
large scale studies and evaluate how spores can prevent runtime exception and
how they ease API usage.
From this paper only, I can not tell if spores are practical enough to be
widely used.
 - Spores requires programmers to enumerate all the free variables of a
closure. Since this can be very burdensome, the paper presents a macro that
caters to automatically convert a function literal to a spore. This reviewer is
not convinced of the usefulness of this technique for large programs with many
nested closures. The spores generated by the technique still need to be
manually checked.
 - The proposed solution only tackles the first level of reference. Real
programs commonly use objects which contain deeply nested object graphs.
  I understand that serializability is transitively guaranteed for such graphs
by using spores. However, for immutability this does not seem to be the case
(i.e. a val reference can still refer to an object with mutable fields). This
should be clarified in the final version should the paper be accepted.

*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*

Second reviewer's review:

          >>> Summary of the submission <<<

This paper describes a type-based scheme for preventing errors and
unwanted effects when using closures for parallel and distributed
programming.

          >>> Evaluation <<<

This paper does a good job clarifying concerns about capture in
closures in parallel/distributed programs. While not often the subject
of academic study, the topic is a very common practical concern with
history reaching back to the 1980s (Emerald and distributed object
frameworks), 1990s (mobile object frameworks), 2000's (Java enterprise
frameworks). The intro might mention some of the precedents beyond
those in use today in Scala.

While the mechanics seem OK, I'm unconvinced about the policy/usage of
"Excluded" sets. One would think that any exclusion list would
comprise of all non-Pickleable/Serializable types, suggesting that a
tagging interface would be more useful than one in which someone might
forget to mention one of the known hostile types. More discussion and
defense might be helpful here.

The paper should note that tagging classes with traits like Immutable
does not automatically make them so. This limits assurances.

The use of both macros and a somewhat strained application of
implicits is a little inelegant. One might think that one or the other
might suffice.

Section 3 on full type rules is distractingly mostly-redundant with
previous section. I don't have a good suggestion for improving this
though.

Sec 5: I suspect that explaining the problems with the two conversion
failures would be informative for readers struggling to understand the
interplay of so many different Scala features here.

It is not clear that the approach here is the most desirable solution
to actual problems. Across the usages discussed in this paper, the
programming intent is to create the minimal transmittable object that
perfroms the indicated function. However, it also seems possible to
adapt or enhance spores in this direction. Discussions of this and/or
other possible future work would be informative.

*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*

Third reviewer's review:

          >>> Summary of the submission <<<

This paper presents a new type system for closures that record information
about captured variables in these closures. Using this type system, one can
specify a constraint on captured variables, such as the serializability of
these variables. The type system is proven sound, and it forms the basis
of the authors' extension of Scala with what they call spores---closures
that carry further information on captured variables and their types. The
paper describes details of this extension, as well as the case study
which used small Scala programs and showed that it was easy to convert
closures in those programs from normal functions to spores.

          >>> Evaluation <<<

Pros:
1. Simplicity of the proposed construct, spore, and seamless integration of
spore
  with the existing Scala language. This makes it easy to use spores when
writing
  Scala programs.

2. They present a formal type system for spores and proved its soundness by
showing
  the standard progress and preservation properties.

Cons:
1. It is not clear to me how much spores could help Scala programmers. The
paper talks
  about various constraints that closures should satisfy when they are used in
special
  situations, such as in the context of distributed computation. Then, it says
that
  spores can help one to express and check these constraints. Although I agree
with
  this argument in theory, I would like to see a more realistic case study that
supports
  the argument.

* When people studied the type preserving compilation of function programs,
they found out
 that closures could be typed using existential types, where existentially
quantified types
 describe captured environments. Spores in the paper are different, and they do
not
 existentially quantify the types of captured variables, and they can also
impose
 conditions on them. However, I think that it is good to show how the work in
the paper
 is related to what people did before. One good paper to reference is "From
System F to Typed
 Assembly Language".

* p1: through an small ---> through a small
* p4: What do you mean by "local type inference"?
* p4: What are the examples of user-defined properties for captured types?
* p6: What do you mean by "unstable" when you say "unstable members"?
* p7: Figure 3a show's ---> Figure 3a shows
* p8: Spore has has ---> Spore has
* p8: Section 2.4 ---> Section 2.4.
* p9: which provides more ---> which provide more
* p9: I didn't quite get the semantics of the for comprehension for spores.
* p11: What do you mean by "pickling"?
* p16: the resulting spore, Delta ---> the resulting spore, Delta'
* p20: In the T-ESpore rule in Fig 12, you ensure that captured types are not
    subtypes of excluded types. On the other hand, The E-EAppSpore rule
    in Fig 13 does not use the subtyping relationship, and simply checks
    whether none of the captured types is excluded. Why is this ok?
* p24: closures in currently ---> closures is currently

*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*

Fourth reviewer's review:

          >>> Summary of the submission <<<

This paper describes Spores, a typed abstraction that represents closures, but
places customizable constraints on the variables they can capture. A spore
explicitly declares the variables it captures in a header block. The type of a
spore describes the type of variables it captures, a set of properties of those
types, and a set of types that it promises not to capture. A spore composition
operation is provided that properly combines the types of the composed spores.
A formal system describes the core of the approach more precisely, with a
soundness result proved using standard progress and preservation theorems. An
implementation is described, and an evaluation shows that existing programs
need not have many lines of code changed, and that Spores can capture closure
conventions used in parallelization and distributed system libraries.

          >>> Evaluation <<<

OVERVIEW

The approach described in this paper is novel. However, the paper overclaims
its contributions (see below for details). The actual formal system does not
enforce all the properties claimed in the introduction, because it does not
check objects that are transitively reachable from a closure. The empirical
evidence regarding overhead is somewhat, but not completely convincing, and
supporting data is not presently available. The empirical evidence regarding
benefits is weak; it shows that the system can enforce an idiom, but it does
not demonstrate how common that idiom is, nor whether that idiom is important
in avoiding typical errors (note that showing either of these might be
sufficient, as they are likely correlated).

The paper has no fundamental flaws, beyond misleading claims. However, given
that the actual contributions are somewhat weak with respect to both the theory
and practice claims, I argue against accepting this paper. Two weak
contributions do not add up to a strong contribution.


QUESTIONS FOR THE AUTHORS

Please address the question below about the need for an assumption on P in
order for property 1 in section 3.5 to hold.

If you want to respond to my review in other ways, focus on the issues in
"DETAILED EVALUATION" - that is mainly what I care about. Minor issues are
minor.


DETAILED EVALUATION

In more detail, here is my evaluation of the claimed contributions of this
paper:

 * Spores, a new closure-like abstraction and type system that offers the user
customizable control over variable capture.

The abstraction and its type system are clearly described through informal text
and examples. The design is novel and interesting. It provides the user with
the ability to control the types that are directly captured by a closure,
either as a list, or via properties of those types, or via a list of types to
exclude.

 * The "approach for type-based constraints [allows] expressing a variety of
properties from the literature including, but not limited to, serializability
and thread safety/immutability."

The system description in section 2 together with the two case studies in
section 6 show that the system can express constraints on the types that are
directly captured by a closure, ensuring that those types are marked as
serializable, or are not from an excluded list of unserializable types, or are
marked as immutable. In the case of a type that has an instance of the type
class Pickler, this is sufficient to express the semantic property that the
capture type is serializable.

In the case of excluded "unserializable" types, or immutable markers, however,
this is insufficient to express semantic serializability or immutability,
because the type captured may include a field referring to an unserializable or
mutable object. I conclude that the claim above is not careful. It could
mislead the reader to confuse the proposed approach with the approach of [16]
or of Murphy et al. (below), which do express and semantically enforce those
properties.

 * Spores are formalized and proven sound.

This claim is validated with the formal system and theorems in section 3. The
soundness theorem does not, however, directly enforce the properties that
motivate the paper, namely serializability and thread safety/immutability. It
enforces standard type safety along with some additional properties: that
captured variable types obey the property specifications, that a spore accesses
only its parameter and explicitly captured variables, and that the static and
dynamic spore composition rules match up. Because the unique properties appear
to be immediate consequences of syntactic checks and standard type safety, in
my opinion the formal result is "obvious" in the sense of not being very deep.
However, the formal system nevertheless has some value in making the ideas in
the paper precise.

Note: as far as I can tell, the system as given does not enforce property #1.
An additional assumption is required on P, that P follows behavioral subtyping,
so that for all tau, tau', pn with tau <: tau', tau' in P(pn) implies tau in
P(pn). Otherwise, you could statically type a closure that requires property pn
as capturing type tau', but when you run the program the dynamic type of the
object actually captured turns out to be the subtype tau, and if tau is not in
P(pn) we have violated property #1. I cannot see anywhere in the paper or TR
that states this assumption on P.

 * Spores are implementable

This is validated through an implementation, described in section 4.

 * Spores are practical

This is validated by an experiment measuring the overhead of converting a set
of existing programs to use Spores. The evidence presented is lines of code
added or changed.

While LOC is often a reasonable metric for syntactic overhead, I am not
convinced this metric is measuring what matters in this case. The overhead of
converting to spores appears to be mainly (A) adding the keyword "spore", (B)
changing the function type, if necessary, and (C) moving captured variables to
val declarations at the beginning of the function. My intuition is that in
these small programs, typical closures are short, often a single line of code.
Modifying such a short closure to a spore would only involve modifying one
line, even if that line of code got a lot longer and appeared a lot more
verbose.

I would be more comfortable if the original and modified programs were
available, so I could study them to see if this is really an issue, and/or if
there were a metric that more obviously matched the actual syntactic overhead
programmers encountered.

 * The type system "avoids typical hazards when using closures in a concurrent
or distributed setting."

As described before, the approach can make this theoretical guarantee for cases
such as pickling, but not the other use cases claimed. That leaves the question
of whether the system is practically useful. I don't know if it is; that would
depend on whether "typical" hazards involve the subset of things this type
system can help with (e.g. accidentally capturing an problematic object
directly, vs. accidentally capturing an object that points to an problematic
object via a field). There isn't empirical evidence given in the paper about
what typical errors are, nor is there any evidence for that cited in the
literature. I conclude that this claim is also not careful; it is the kind of
claim that can only be validated by a different empirical study design.

It might be better to avoid claims involving "typical hazards" and "expressing
serializability and thread safety/immutability" and rather claim that the
system enforces conventions that programmers in systems such as Spark already
follow, which are motivated by helping to check those properties but cannot
fully enforce them.

The case study in section 6.1 does demonstrate that the system can enforce
usage patterns which are used by some Spark programmers. The result would be
stronger if there were concrete evidence that this pattern is widely used,
and/or that it does reduce errors in practice.

The case study in section 6.2 is less convincing. There is no claim that the
type system is enforcing an existing idiom here. Furthermore, it seems to still
be quite easy for programmers to mess up, either by neglecting to use a wrapper
that triggers the enforcement, or by marking things as immutable that aren't
transitively so. I'm skeptical that this will help at all in practice, or that
it will be worth the bother of using the wrappers and spores.



OTHER SIGNIFICANT COMMENTS

A significant piece of related work that is missing is:

Tom Murphy VII, Karl Crary, and Robert Harper. Type-safe Distributed
Programming with ML5. Proc. Trustworthy Global Computing, LNCS vol 4912, 2007.

This paper is related as a type system that verifies that even when closures
are passed across a distributed system, computation never uses a resource that
does not exist on the local machine. This is a stronger property than the one
in this paper in two ways: first of all, it is transitive, meaning that it
checks not just what is captured directly by a function, but all things
reachable from it; second of all, it governs actual use, not mere reference,
such that a function that references an un-serializable resource can still be
serialized as long as it will not reference that resource without moving back
to the original machine. It is both earlier and more sophisticated that several
pieces of related work that are cited, such as [6]. Of course, some of the
distinctions made with work that was cited, particularly the later work [16],
also apply to this citation.



MINOR ISSUES

abstract: has even lead -> has even led

page 2: The Haskell example is somewhat obscure to a reader not familiar with
the SendPort and ProcessM abstractions. This is distracting but does not
critically interfere with understanding.

"unstable object members such as method calls" - I'm not sure what this means,
why method calls are object members, or why they are unstable.

section 2.1: separating all captured variables into a header looks clunky at
first glance, especially to a functional programmer accustomed to lightweight
lambdas. Motivating this design choice in more detail or providing more
evidence of Scala programmers doing this already would help make this choice
more understandable to the reader.

section 2.2: it's too bad that "f compose g" can't be written as "x => f(g(x))"
as usual, without losing typing information. It's not a terrible loss when what
you want to do is exactly compose f and g, but what if you want to put some
interesting logic into the composition and so you can't use the "compose"
operator directly? It seems like it is a significant limitation of the approach
that, as soon as you compose things in more general ways, you lose all the nice
typing properties.

page 9: that's -> that is [better in formal writing]

footnote 5: "and whether or not they are present in implicit scope": awkward
text/hard to understand in context. Rewrite?

page 13: "Captured returns, for a given refinement type, the set of types...."
- actually it is a *list* of types. Maybe it should be a set, if only PL type
systems had better support for sets, but it is a list in the rest of the
paper.

section 3.2: give the intuition behind what it means for property names to be
"active" while deriving the type T of term t. I had to reconstruct this through
some slightly painful cross-referencing.

Fig 9: Why does H-InsSpor1 replace t with t', but H-InsSpore2 not? This
inconsistency suggests either that there is an error, or that the replacement
does nothing (in which case it is unneeded in the first rule).


REPLY TO AUTHOR RESPONSE

Thank you for the author response, which I found very helpful.

With respect to transitive properties, the explanation in your response is
convincing. If this were added to the paper--and if the claims about what the
system does were modified to explain that additional type systems such as OIGJ
would have to be added to gain the desired properties--this would answer my
complaints.

Thanks also for clarifying the assumption needed for property 1--please add
this to the paper.

With the caveat that author responses are not generally supposed to include
more results, I will admit that I find the evidence described there is more
convincing to me than what is in the paper.

Overall, I still feel the evaluation in the paper--as submitted--is weaker than
I would like to see in an ECOOP paper, given the theoretical results as stated.
I could get into positive territory if:
 * The paper was modified as described in the author response
 * Claims were refined to better match the results
 * Data backing the empirical results were available
 * The empirical evidence from the author response was fleshed out a bit and
added to the paper, perhaps replacing some of the existing empirical
evaluation.

Given that other reviewers seem quite positive on this paper, I suspect it will
be accepted, so I hope the authors are able to make the changes above, which
could make for a nice paper.

*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*=--=*