% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{url}
\usepackage{todonotes}
%
\begin{document}
%
\mainmatter              % start of the contributions
%
\title{Spores: Function-Passing Style}
%
\titlerunning{Spores: Function-Passing Style}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Heather Miller\inst{1} \and Philipp Haller\inst{2}
\and Martin Odersky\inst{1}}
%
\authorrunning{Heather Miller et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Heather Miller, Philipp Haller, and Martin Odersky}
%
\institute{EPFL, Switzerland\\
\and
Typesafe, Switzerland}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Go.
\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%
\section{Introduction}

We introduce a model for concurrent and distributed computing where the data is stationary and functions are mobile. This is a dual to the actor model, where functionality is stationary, and data is made mobile. 

In theory you can migrate actors, in practice, you cannot. Can we use these insights to find a way to migrate actors cleanly?

\subsection{Problems of actors}

\begin{itemize}

\item Migrating actors is not supported in mainstream actor frameworks and
languages. For example, neither Akka nor Erlang support migrating actors from
one node to another.

\item Sending spores as messages to actors comes with the problem of matching
on the types of the spore which is not supported due to erasure in Scala.

\end{itemize}

We describe a pattern for distributing lambdas in a principled way. We
implement this pattern in a family of spore-agent abstractions which enforce
the rules of the pattern.

We discuss problems in distributed programming that are simplified using the
spore-agent abstraction compared to equivalent actor-based solutions.
Moreover, we argue that spore-agents are dual to actors.

Finally, we show that this spore-agent abstraction can be implemented
efficiently; we show that our spore-agent implementation can outperform state-
of-the-art actor frameworks on a set of applications where distributing
lambdas is at the core.

\subsection{Brainstorming}

Should focus on re-usable building blocks. Spores are re-usable by several
frameworks. What else is re-usable? A composition mechanism?

One thing could be to provide a mechanism to compose spores, but leave it open
how to execute that on a distributed middleware.

Make it easy to build an execution engine like the one from Spark.

\subsection{Motivation}

Distributed programming supposed to be made easier by going functional. But a problem of object-oriented languages with lambdas and functional programming languages alike is that functions can have free variables. Closures that close over some tricky environment. This means that regardless of the paradigm, framework designers can't confidently expose lambdas in APIs to users.

Call on trend towards in-memory distributed computing.

Section on jargon. Lambdas, functions, closures. Introduce a baseline
vocabulary with respect to environment for duration of paper.

\subsection{Functions Across Languages}

A survey of the way different languages deal with functions and closures. How
the environment is kept, scoping, stack frames, etc.

Languages to compare with closures:

\begin{itemize}
\item Scala
\item Objective C
\item Java
\item VB.net
\item Python
\item Ruby
\item Javascript
\item Lisp
\item Perl
\item Lisp
\item Racket
\item Scheme
\item Clojure
\item Rust
\item Go
\item Dart
\item Haskell
\item ML
\item C++
\item Lua
\item Smalltalk
\item ECMAScript
\item C\# (Supports functions, but not closures. Emulates with delegates.)
\end{itemize}

\section{Lambda the Ultimate Distributive: The Pattern}

Lambdas provide a simple, principled way of handling the different kinds of
objects that are fundamental in distributed systems. Some of these objects are
data that should be processed (like a large collection), some of these objects
represent services of the runtime environment (e.g., for scheduling or
communication).

Given the kind of object that is involved in a distributed computation, the
object has to be handled specially:
\begin{itemize}

\item (a) an object can be data that must be shipped between nodes to accomplish
some task;

\item (b) an object can be a runtime service, such as a scheduler, which is not
shippable, but must be used on each node;

\item (c) an object can be data which is not shippable for some reason, but might
have to be retrieved on multiple nodes.

\end{itemize}

The idea of ``lambda the ultimate distributive'' is that closures can handle
all of these kinds of objects in a principled and well-defined way (no
guessing needed):

\begin{itemize}

\item objects of kind (a) can be safely captured by the closure since they are shippable;

\item objects of kind (b) must be parameters of the closure; on each machine,
a reference the (local) runtime environment is passed as an argument to the
closure; (Individual services, like a scheduler, could be fields of a
wrapping ``environment'' object.)

\item objects of kind (c) must be parameters of the closure; on each machine,
they have to be retrieved first using an object of kind (b), and then passed
to the closure as an argument.

\end{itemize}

Using lambdas in this way allows modeling all situations in a distributed
system in a principled way, without special tricks or hacks.


\section{The Spore-Agent Abstraction}


\section{Function-Passing Paradigm}

Frameworks this new paradigm would enable. Relationship to NoSQL?

\subsection{General Model}

Goal of general model: to take this mess of closures and functions and trouble with environments that pains people across languages and propose an abstraction that gets rid of this confusion.

Include in the general model typing rules that makes this abstraction guaranteeably shippable
given some baseline simplified formalism.

\subsection{Meat}

Need to work out structure of this and an appropriate title for this section. Would include stuff like type system and type constraints for spores perhaps (or keep that in the general model section?). Composing spores with type constraints. Subtyping and type constraints.

\subsubsection{OO}

The question of -- I capture something of type MyActor
and the spore forbids capturing type Actor, and MyActor <: Actor
then what happens.

\section{Implementation}

Comparison and relationship with Java8 SAM stuff.

\section{Use-Cases?}

We could show in an example-driven (or even paradigm-driven) way how the
active objects pattern can be implemented on top of spores. And then we can
show how spores help enforce certain safety properties that are important for
that pattern. For example, in the active objects pattern it's important to
either capture only immutable things, or clone things upon capturing.

Paradigms or patterns built on top of spores:

\begin{itemize}
\item Distributed collections like Spark
\item Active objects
\item Futures
\item Hot-swapping actors
\item Distributed pipelines / distributed streams
\end{itemize}

\section{Implementation}

\section{Evaluation}

It's difficult to convincingly evaluate a new programming model, upon which a number of new abstractions have not yet been built. Therefore, we evaluate the spore-agent model in the following important ways; (1) we provide a detailed case analysis of a number of distributed applications that can be enabled or greatly facilitated by basing these frameworks on spores, (2) we show a number of important and useful scenarios that the actor model is not able to or is not well-suited to support, and finally (3) we show that in some of these scenarios, the spores-agent model is both more natural and performant.

Can persist them and have remoting in a way that doesn't slow down everything else. Still provides efficient local computation.

\section{Related Work}

Non-academic related work: functions in Rust, 3 different types based on
different possibilities for environments \cite{RustFunctions}; functions,
closures, and procedures. Procedures are shippable.

Parallel closures \cite{ParallelClosures}. First known example of closures
with effectively immutable environment.

CloudHaskell \cite{CloudHaskell}. Introduces a type system that rejects anything
that is not static. Too strict.

C++ 11 comes with a capture syntax. Though, it's not possible to guarantee that construction is correct. If you require certain things from the closure, how is it expressed? If a method declares a parameter type which is a closure, the important thing is that in this parameter type, you can specify the requirements about capturing. So it's ensured that whatever's passed as an argument to the method satisfies these requirements. This isn't possible with C++ 11 closures. \cite{Cplusplus11Spec}

Active objects also related. \cite{ActiveObjects}

Clojure comes with the notion of an agent~\cite{ClojureAgents} which is similar to our synchronization mechanism in that in the Clojure model, functions are sent to other agents which manage some sort of mutable, shared state. The spores-agent model focuses on more than managing mutable state. No notion of shippability, fully-focused on multicore single-machine scenario.

\bibliographystyle{abbrv}
\bibliography{bib}

\end{document}
