% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{url}
\usepackage{todonotes}
%
\begin{document}
%
\mainmatter              % start of the contributions
%
\title{Spores: Function-Passing Style\todo{bad title}}
%
\titlerunning{Spores: Function-Passing Style}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Heather Miller\inst{1} \and Philipp Haller\inst{2}
\and Martin Odersky\inst{1}}
%
\authorrunning{Heather Miller et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Heather Miller, Philipp Haller, and Martin Odersky}
%
\institute{EPFL, Switzerland\\
\and
Typesafe, Switzerland}

\maketitle              % typeset the title of the contribution

\begin{abstract}

Functional programming is regularly touted as the way forward for bringing
parallel, concurrent, and distributed programming to the mainstream. The
popularity of the rationale behind this viewpoint (immutable data transformed
by function application) has even lead to a number of imperative and  object-
oriented programming languages adopting building blocks such as lambdas
(functions)\todo{say something instead about closures}. This paper takes a
step towards more principled {\em function-passing style}\todo{should probably
say something like "open programming"}~by introducing a new closure-like
abstraction and type system, called {\em spores}, that can guarantee closures
to be serializable, thread-safe, or even have custom user-defined properties.
We present a model and type system for expressing general type constraints and
apply it to the problem of guaranteeing serializability and thread-safety of
closures. We implement our approach as a module for Scala, and show the power
of these guarantees through a detailed case analysis of new distributed and
concurrent frameworks that this safe foundation for migratable closures
enables.

\keywords{functions, closures, distributed programming, concurrent programming, type systems}
\end{abstract}
%
\section{Introduction}

With the growing trend towards cloud computing and mobile applications,
distributed programming has entered the mainstream. The traditional view of
software development as being focused on a program running on a single
machine, interacting directly with the user, has become largely obsolete.
Popular paradigms in software engineering such as software as a service
(SaaS), RESTful services, or the rise of multitudes of different models and
systems for big data processing and interactive analytics, evidence this
trend.
% From big data to paradigms like software as a service, RESTful blah, the . 
Whether we consider a cluster of commodity machines
churning through a massive data-parallel job, or a smartphone interacting with
a social network, all are ``distributed'' jobs, and all share the need to
interact in typically asynchronous, reactive ways with other clients or
services. \todo{make nod to functional futures, etc?} \todo{maybe make a nod to open programming?}

At the same time, the functional programming paradigm has irrefutably gained
traction in recent years, as is evidenced by the ongoing trend of
traditionally object-oriented or imperative languages being extended with
functional features, such as lambdas in Java~\cite{JavaLambdas},
C++~\cite{CplusplusLambas}, and \todo{add more}, as well as the increase in
use of functional languages on software repositories~\cite{find-something},
the perceived importance of functional programming in general empirical
studies on software developers~\cite{PLAdoption}\todo{check Leo's paper, add
others}, and the measurable popularity of functional programming massively
online open courses (MOOCs)~\cite{ICSEMOOC}.

Functions don't concern only functional programming languages anymore.

One reason \todo{make this less strong, or cite something}for the rise in
popularity of functional programming languages and features is the basic
philosophy of transforming immutable data via function application, and the
observation that this mode of reasoning about data in parallel, concurrent,
and distributed code is more tractable.

\todo{cite one or some of the lambda the ultimate papers here?}
\todo{need to cite a few papers that claim that FP is the way forward for parallel and distributed computing}

While purported to the way forward for bringing parallel, concurrent, and
distributed programming to the mainstream, functional programming languages
haven't yet taken off as the languages of choice for distributed and
concurrent programming in practice. There still exist numerous hurdles at the
language-level for even these most basic of building blocks of functional
languages to overcome in order to be reliable and easy to reason about in
concurrent or distributed environments. For instance, a natural model for
functional languages to support is that of {\em moving functionality to
data}\todo{this is a really common idea, cite a bunch of stuff that aims for
this}. While a popular idea, there exist few distributed systems which embody
this approach, the most notable of which being Spark~\cite{Spark}, a fault-
tolerant, in-memory distributed collections abstraction.

\todo{talk about issues of serializing lambdas in Java, Scala -- OO languages. Then discuss the problems of functional languages like Haskell too}

This paper takes a step towards more principled {\em function-passing
style}\todo{should probably say something like "open programming"}~by
introducing a new closure-like abstraction and type system that can guarantee
closures to be serializable, thread-safe, or even have user-defined
properties, called {\em spores}.

We first present a and then focus on an implementation of spores in Scala, a
hybrid object-oriented and functional programming language which faces the
issues brought by closures on all sides -- the issues encountered in
functional languages such as Haskell~\cite{CloudHaskell}, as well as issues
encountered by integrating closures with an object system, inheritance and
subtyping.

Need to talk about related work here.

% == NOTES ==
% We introduce a model for concurrent and distributed computing where the data is stationary and functions are mobile. This is a dual to the actor model, where functionality is stationary, and data is made mobile. 

% In theory you can migrate actors, in practice, you cannot. Can we use these insights to find a way to migrate actors cleanly?

% We describe a pattern for distributing lambdas in a principled way. We
% implement this pattern in the new spore-agent abstraction which enforces the
% rules of the pattern.

% We discuss problems in distributed programming that are simplified using the
% spore-agent abstraction compared to equivalent actor-based solutions.
% Moreover, we argue that spore-agents are dual to actors.

% Finally, we show that this spore-agent abstraction can be implemented
% efficiently; we show that our spore-agent implementation can outperform state-
% of-the-art actor frameworks on a set of applications where distributing
% lambdas is at the core.

% Distributed programming supposed to be made easier by going functional. But a problem of object-oriented languages with lambdas and functional programming languages alike is that functions can have free variables. Closures that close over some tricky environment. This means that regardless of the paradigm, framework designers can't confidently expose lambdas in APIs to users.

% Call on trend towards in-memory distributed computing.

% The design of our framework is guided by the following principles...

% In this paper, we present a model and type system for introducing general {\em type constraints}, and demonstrate its applicability 

\subsection{Motivation}

{\bf Motivations:}
\begin{itemize}
\item problems with distribution
\item problems with concurrency
\end{itemize}

\subsection{Contributions}

\begin{itemize}
\item we present a general model of \textit{spores}, functions that are guaranteed to be 
\item sdf
\end{itemize}


This paper makes the following contributions:

\subsection{Jargon?}

Section on jargon. Lambdas, functions, closures. Introduce a baseline
vocabulary with respect to environment for duration of paper.

\subsection{Functions Across Languages}

A survey of the way different languages deal with functions and closures. How
the environment is kept, scoping, stack frames, etc.

Languages to compare with closures:

\begin{itemize}
\item Scala
\item Objective C
\item Java
\item VB.net
\item Python
\item Ruby
\item Javascript
\item Lisp
\item Perl
\item Lisp
\item Racket
\item Scheme
\item Clojure
\item Rust
\item Go
\item Dart
\item Haskell
\item ML
\item C++
\item Lua
\item Smalltalk
\item ECMAScript
\item C\# (Supports functions, but not closures. Emulates with delegates.)
\end{itemize}

\section{Function-Passing Paradigm}

Frameworks this new paradigm would enable. Relationship to NoSQL?

\subsection{General Model}

Goal of general model: to take this mess of closures and functions and trouble with environments that pains people across languages and propose an abstraction that gets rid of this confusion.

Include in the general model typing rules that makes this abstraction guaranteeably shippable
given some baseline simplified formalism.

\subsection{Meat}

Need to work out structure of this and an appropriate title for this section. Would include stuff like type system and type constraints for spores perhaps (or keep that in the general model section?). Composing spores with type constraints. Subtyping and type constraints.

\subsubsection{OO}

The question of -- I capture something of type MyActor
and the spore forbids capturing type Actor, and MyActor <: Actor
then what happens.

\section{Implementation}

Comparison and relationship with Java8 SAM stuff.

\section{Use-Cases?}

We could show in an example-driven (or even paradigm-driven) way how the
active objects pattern can be implemented on top of spores. And then we can
show how spores help enforce certain safety properties that are important for
that pattern. For example, in the active objects pattern it's important to
either capture only immutable things, or clone things upon capturing.

Paradigms or patterns built on top of spores:

\begin{itemize}
\item Distributed collections like Spark
\item Active objects
\item Futures
\item Hot-swapping actors
\item Distributed pipelines / distributed streams
\end{itemize}

\section{Implementation}

\section{Evaluation}

It's difficult to convincingly evaluate a new programming model, upon which a number of new abstractions have not yet been built. Therefore, we evaluate the spore-agent model in the following important ways; (1) we provide a detailed case analysis of a number of distributed applications that can be enabled or greatly facilitated by basing these frameworks on spores, (2) we show a number of important and useful scenarios that the actor model is not able to or is not well-suited to support, and finally (3) we show that in some of these scenarios, the spores-agent model is both more natural and performant.

Can persist them and have remoting in a way that doesn't slow down everything else. Still provides efficient local computation.

\section{Related Work}

Non-academic related work: functions in Rust, 3 different types based on
different possibilities for environments \cite{RustFunctions}; functions,
closures, and procedures. Procedures are shippable.

Parallel closures \cite{ParallelClosures}. First known example of closures
with effectively immutable environment.

CloudHaskell \cite{CloudHaskell}. Introduces a type system that rejects anything
that is not static. Too strict.

C++ 11 comes with a capture syntax. Though, it's not possible to guarantee that construction is correct. If you require certain things from the closure, how is it expressed? If a method declares a parameter type which is a closure, the important thing is that in this parameter type, you can specify the requirements about capturing. So it's ensured that whatever's passed as an argument to the method satisfies these requirements. This isn't possible with C++ 11 closures. \cite{Cplusplus11Spec}

Active objects also related. \cite{ActiveObjects}

Clojure comes with the notion of an agent~\cite{Clojure} which is similar to our synchronization mechanism in that in the Clojure model, functions are sent to other agents which manage some sort of mutable, shared state. The spores-agent model focuses on more than managing mutable state. No notion of shippability, fully-focused on multicore single-machine scenario.

\bibliographystyle{abbrv}
\bibliography{bib}

\end{document}
