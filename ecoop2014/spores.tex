% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{url}
\usepackage{todonotes}
%
\begin{document}
%
\mainmatter              % start of the contributions
%
\title{Spores: Function-Passing Style}
%
\titlerunning{Spores: Function-Passing Style}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Heather Miller\inst{1} \and Philipp Haller\inst{2}
\and Martin Odersky\inst{1}}
%
\authorrunning{Heather Miller et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Heather Miller, Philipp Haller, and Martin Odersky}
%
\institute{EPFL, Switzerland\\
\and
Typesafe, Switzerland}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Go.
\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%
\section{Introduction}


\subsection{Motivation}

Distributed programming supposed to be made easier by going functional. But a problem of object-oriented languages with lambdas and functional programming languages alike is that functions can have free variables. Closures that close over some tricky environment. This means that regardless of the paradigm, framework designers can't confidently expose lambdas in APIs to users.

Section on jargon. Lambdas, functions, closures. Introduce a baseline
vocabulary with respect to environment for duration of paper.

\subsection{Functions Across Languages}

A survey of the way different languages deal with functions and closures. How
the environment is kept, scoping, stack frames, etc.

Languages to compare with closures: 

\begin{itemize}
\item Scala
\item Objective C
\item Java
\item VB.net
\item Python
\item Ruby
\item Javascript
\item Lisp
\item Perl
\item Lisp
\item Racket
\item Scheme
\item Clojure
\item Rust
\item Go
\item Dart
\item Haskell
\item ML
\item C++
\item Lua
\item Smalltalk
\item ECMAScript
\item C\# (Supports functions, but not closures. Emulates with delegates.)
\end{itemize}

\subsection{Function-Passing Paradigm}

Frameworks this new paradigm would enable. Relationship to NoSQL?

\subsection{General Model}

Goal of general model: to take this mess of closures and functions and trouble with environments that pains people across languages and propose an abstraction that gets rid of this confusion.

Include in the general model typing rules that makes this abstraction guaranteeably shippable
given some baseline simplified formalism.

\subsection{Meat}

Need to work out structure of this and an appropriate title for this section. Would include stuff like type system and type constraints for spores perhaps (or keep that in the general model section?). Composing spores with type constraints. Subtyping and type constraints.

\subsubsection{OO}

The question of -- I capture something of type MyActor
and the spore forbids capturing type Actor, and MyActor <: Actor
then what happens.

\subsection{Implementation}

Comparison and relationship with Java8 SAM stuff.

\subsection{Related Work}

Non-academic related work: functions in Rust, 3 different types based on
different possibilities for environments \cite{RustFunctions}; functions,
closures, and procedures. Procedures are shippable.

Parallel closures \cite{ParallelClosures}. First known example of closures
with effectively immutable environment.

CloudHaskell \cite{CloudHaskell}. Introduces a type system that rejects anything
that is not static. Too strict.


\bibliographystyle{abbrv}
\bibliography{bib}

\end{document}
