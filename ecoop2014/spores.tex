% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}  % allows for indexgeneration
\usepackage{url}
\usepackage{todonotes}
%
\begin{document}
%
\mainmatter              % start of the contributions
%
\title{Spores: Function-Passing Style}
%
\titlerunning{Spores: Function-Passing Style}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Heather Miller\inst{1} \and Philipp Haller\inst{2}
\and Martin Odersky\inst{1}}
%
\authorrunning{Heather Miller et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Heather Miller, Philipp Haller, and Martin Odersky}
%
\institute{EPFL, Switzerland\\
\and
Typesafe, Switzerland}

\maketitle              % typeset the title of the contribution

\begin{abstract}
Go.
\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%
\section{Introduction}

We introduce a model for concurrent and distributed computing where the data is stationary and functions are mobile. This is a dual to the actor model, where functionality is stationary, and data is made mobile. 

In theory you can migrate actors, in practice, you cannot. Can we use these insights to find a way to migrate actors cleanly?

\subsection{Problems of actors}

\begin{itemize}

\item Migrating actors is not supported in mainstream actor frameworks and
languages. For example, neither Akka nor Erlang support migrating actors from
one node to another.

\item Sending spores as messages to actors comes with the problem of matching
on the types of the spore which is not supported due to erasure in Scala.

\end{itemize}

We describe a pattern for distributing lambdas in a principled way. We
implement this pattern in a family of spore-agent abstractions which enforce
the rules of the pattern.

We discuss problems in distributed programming that are simplified using the
spore-agent abstraction compared to equivalent actor-based solutions.
Moreover, we argue that spore-agents are dual to actors.

Finally, we show that this spore-agent abstraction can be implemented
efficiently; we show that our spore-agent implementation can outperform state-
of-the-art actor frameworks on a set of applications where distributing
lambdas is at the core.

\subsection{Brainstorming}

Should focus on re-usable building blocks. Spores are re-usable by several
frameworks. What else is re-usable? A composition mechanism?

One thing could be to provide a mechanism to compose spores, but leave it open
how to execute that on a distributed middleware.

Make it easy to build an execution engine like the one from Spark.

\subsection{Motivation}

Distributed programming supposed to be made easier by going functional. But a problem of object-oriented languages with lambdas and functional programming languages alike is that functions can have free variables. Closures that close over some tricky environment. This means that regardless of the paradigm, framework designers can't confidently expose lambdas in APIs to users.

Call on trend towards in-memory distributed computing.

Section on jargon. Lambdas, functions, closures. Introduce a baseline
vocabulary with respect to environment for duration of paper.

\subsection{Functions Across Languages}

A survey of the way different languages deal with functions and closures. How
the environment is kept, scoping, stack frames, etc.

Languages to compare with closures:

\begin{itemize}
\item Scala
\item Objective C
\item Java
\item VB.net
\item Python
\item Ruby
\item Javascript
\item Lisp
\item Perl
\item Lisp
\item Racket
\item Scheme
\item Clojure
\item Rust
\item Go
\item Dart
\item Haskell
\item ML
\item C++
\item Lua
\item Smalltalk
\item ECMAScript
\item C\# (Supports functions, but not closures. Emulates with delegates.)
\end{itemize}

\section{Function-Passing Paradigm}

Frameworks this new paradigm would enable. Relationship to NoSQL?

\subsection{General Model}

Goal of general model: to take this mess of closures and functions and trouble with environments that pains people across languages and propose an abstraction that gets rid of this confusion.

Include in the general model typing rules that makes this abstraction guaranteeably shippable
given some baseline simplified formalism.

\subsection{Meat}

Need to work out structure of this and an appropriate title for this section. Would include stuff like type system and type constraints for spores perhaps (or keep that in the general model section?). Composing spores with type constraints. Subtyping and type constraints.

\subsubsection{OO}

The question of -- I capture something of type MyActor
and the spore forbids capturing type Actor, and MyActor <: Actor
then what happens.

\section{Implementation}

Comparison and relationship with Java8 SAM stuff.

\section{Use-Cases?}

We could show in an example-driven (or even paradigm-driven) way how the
active objects pattern can be implemented on top of spores. And then we can
show how spores help enforce certain safety properties that are important for
that pattern. For example, in the active objects pattern it's important to
either capture only immutable things, or clone things upon capturing.

Paradigms or patterns built on top of spores:

\begin{itemize}
\item Distributed collections like Spark
\item Active objects
\item Futures
\item Hot-swapping actors
\item Distributed pipelines / distributed streams
\end{itemize}

\section{Related Work}

Non-academic related work: functions in Rust, 3 different types based on
different possibilities for environments \cite{RustFunctions}; functions,
closures, and procedures. Procedures are shippable.

Parallel closures \cite{ParallelClosures}. First known example of closures
with effectively immutable environment.

CloudHaskell \cite{CloudHaskell}. Introduces a type system that rejects anything
that is not static. Too strict.

C++ 11 comes with a capture syntax. Though, it's not possible to guarantee that construction is correct. If you require certain things from the closure, how is it expressed? If a method declares a parameter type which is a closure, the important thing is that in this parameter type, you can specify the requirements about capturing. So it's ensured that whatever's passed as an argument to the method satisfies these requirements. This isn't possible with C++ 11 closures. \cite{Cplusplus11Spec}

Active objects also related. \cite{ActiveObjects}


\bibliographystyle{abbrv}
\bibliography{bib}

\end{document}
